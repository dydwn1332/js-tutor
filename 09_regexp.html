<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>정규식</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 9;</script></head>

<article>
<nav><a href="08_error.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="10_modules.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>9</span>정규식</h1>

<blockquote>

<p><a class="p_ident" id="p_MWUwIAb0uO" href="#p_MWUwIAb0uO" tabindex="-1" role="presentation"></a>어떤 사람들은 문제에 직면했을 때 '알겠습니다. 정규식을 사용하겠습니다'라고 생각합니다. 이제 두 가지 문제가 있습니다.</p>

<footer>Jamie Zawinski</footer>

</blockquote>

<blockquote>

<p><a class="p_ident" id="p_icxlw7+18l" href="#p_icxlw7+18l" tabindex="-1" role="presentation"></a>Yuan-Ma가 말하기를 '나무결을 자를 때는 힘이 많이 필요하다. 문제의 핵심에 대해 프로그래밍할 때 많은 코드가 필요합니다.'</p>

<footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>

</blockquote><figure class="chapter square-framed"><img src="img/chapter_picture_9.jpg" alt="A railroad diagram"></figure>

<p><a class="p_ident" id="p_mYvGNMWwx9" href="#p_mYvGNMWwx9" tabindex="-1" role="presentation"></a>프로그래밍 도구와 기술은 혼란스럽고 진화적인 방식으로 생존하고 확산됩니다. 항상 예쁘거나 뛰어난 것이 승리하는 것이 아니라 적절한 틈새 시장 내에서 충분히 잘 작동하거나 우연히 다른 성공적인 기술과 통합되는 것이 승리합니다.</p>

<p><a class="p_ident" id="p_iH3Aqi6y2A" href="#p_iH3Aqi6y2A" tabindex="-1" role="presentation"></a>이 장에서는 그러한 도구 중 하나인 정규식에 대해 설명합니다. 정규식은 문자열 데이터의 패턴을 설명하는 방법입니다. 그것들은 JavaScript 및 기타 많은 언어 및 시스템의 일부인 작고 별도의 언어를 형성합니다.</p>

<p><a class="p_ident" id="p_cxbejyPUGl" href="#p_cxbejyPUGl" tabindex="-1" role="presentation"></a>정규식은 매우 어색하지만 매우 유용합니다. 그것들의 구문은 비밀스럽고 JavaScript가 제공하는 프로그래밍 인터페이스는 서투릅니다. 그러나 문자열을 검사하고 처리하기 위한 강력한 도구입니다. 정규식을 올바르게 이해하면 보다 효과적인 프로그래머가 됩니다.</p>

<h2><a class="h_ident" id="h_5w4yGFJRYl" href="#h_5w4yGFJRYl" tabindex="-1" role="presentation"></a>정규식 만들기</h2>

<p><a class="p_ident" id="p_u/9SKAI2Yi" href="#p_u/9SKAI2Yi" tabindex="-1" role="presentation"></a>정규식은 객체 타입입니다. <code>RegExp</code> 생성자를 구성하거나 슬래시(<code>/</code>) 문자로 패턴을 묶어 리터럴 값으로 작성할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_O1I2rl+HTy" href="#c_O1I2rl+HTy" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">re1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;abc&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">re2</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/</span>;</pre>

<p><a class="p_ident" id="p_dviEva2QQM" href="#p_dviEva2QQM" tabindex="-1" role="presentation"></a>이러한 정규식 객체는 모두 동일한 패턴을 나타냅니다. <em>a</em> 문자 다음에 <em>b</em> 다음에 <em>c</em>가 옵니다.</p>

<p><a class="p_ident" id="p_qv8UWLVrTv" href="#p_qv8UWLVrTv" tabindex="-1" role="presentation"></a><code>RegExp</code> 생성자를 사용할 때 패턴은 일반 문자열로 작성되므로 백슬래시에는 일반적인 규칙이 적용됩니다.</p>

<p><a class="p_ident" id="p_0mNIcPpslS" href="#p_0mNIcPpslS" tabindex="-1" role="presentation"></a>슬래시 문자 사이에 패턴이 나타나는 두 번째 표기법은 백슬래시를 다소 다르게 취급합니다. 첫째, 슬래시가 패턴을 끝내기 때문에 패턴의 일부가 되고자 하는 슬래시 앞에 백슬래시를 넣어야 합니다. 또한 특수 문자 코드의 일부가 아닌 백슬래시는 (<code>\n</code>와 같은) 문자열에 있는 것처럼 무시되지 않고 유지되고 패턴의 의미를 변경합니다. 물음표 및 더하기 기호와 같은 일부 문자는 정규식에서 특별한 의미를 가지며 문자 자체를 나타내려면 백슬래시가 앞에 와야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uRzUiBSrul" href="#c_uRzUiBSrul" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">eighteenPlus</span> <span class="cm-operator">=</span> <span class="cm-string-2">/eighteen\+/</span>;</pre>

<h2><a class="h_ident" id="h_vPyyYjMEtz" href="#h_vPyyYjMEtz" tabindex="-1" role="presentation"></a>부합 테스트</h2>

<p><a class="p_ident" id="p_SHaMWlzFzk" href="#p_SHaMWlzFzk" tabindex="-1" role="presentation"></a>정규식 객체에는 여러 메서드가 있습니다. 가장 간단한 것은 <code>test</code>입니다. 문자열을 전달하면 문자열에 표현식의 패턴이 일치하는지 여부를 알려주는 부울 값이 반환됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Szn1CmrIV5" href="#c_Szn1CmrIV5" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;abcde&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/abc/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;abxde&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_YGcbMDV493" href="#p_YGcbMDV493" tabindex="-1" role="presentation"></a>비특수 문자로만 구성된 정규식은 단순히 해당 문자 수열을 나타냅니다. <em>abc</em>가 테스트 문자열에서 어는 곳인가 발생하면 <code>test</code>는 <code>true</code>를 반환합니다.</p>

<h2><a class="h_ident" id="h_8EFR0DU1xd" href="#h_8EFR0DU1xd" tabindex="-1" role="presentation"></a>문자 집합</h2>

<p><a class="p_ident" id="p_ZyB7HeLr75" href="#p_ZyB7HeLr75" tabindex="-1" role="presentation"></a>문자열에 <em>abc</em>가 포함되어 있는지 여부를 알아내는 것은 <code>indexOf</code>에 대한 호출로 수행할 수 있습니다. 정규 표현식을 사용하면 더 복잡한 패턴을 표현할 수 있습니다.</p>

<p><a class="p_ident" id="p_i/99SEfu9y" href="#p_i/99SEfu9y" tabindex="-1" role="presentation"></a>임의의 숫자와 일치시키고 싶다고 가정해 봅시다. 정규식에서 대괄호 사이에 문자 집합을 넣으면 표현식의 해당 부분이 대괄호 사이의 모든 문자와 일치합니다.</p>

<p><a class="p_ident" id="p_sC+2E08KnL" href="#p_sC+2E08KnL" tabindex="-1" role="presentation"></a>다음 표현식은 모두 숫자가 포함된 모든 문자열과 부합합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Z3UJdL//cY" href="#c_Z3UJdL//cY" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0123456789]/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;in 1992&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/[0-9]/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;in 1992&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_i0WYLVUede" href="#p_i0WYLVUede" tabindex="-1" role="presentation"></a>대괄호 내에서 두 문자 사이의 하이픈(<code>-</code>)을 사용하여 문자 범위를 나타낼 수 있습니다. 여기서 순서는 문자의 유니코드 번호에 따라 결정됩니다. 0에서 9까지의 문자는 이 순서(코드 48에서 57까지)에서 서로 바로 옆에 위치하므로 <code>[0-9]</code>를 포함하고 모든 숫자와 부합됩니다.</p>

<p><a class="p_ident" id="p_1qtYlDfA/1" href="#p_1qtYlDfA/1" tabindex="-1" role="presentation"></a>많은 공통 문자 그룹에는 자체 내장 단축키가 있습니다. 숫자는 그 중 하나입니다. <code>\d</code>는 <code>[0-9]</code>와 같은 의미입니다.</p>

<table>

<tr><td><code>\d</code></td><td>모든 숫자 문자</td>

</tr>

<tr><td><code>\w</code></td><td>영숫자 문자("단어 문자")</td>

</tr>

<tr><td><code>\s</code></td><td>모든 공백 문자(space, tab, newline 등)</td>

</tr>

<tr><td><code>\D</code></td><td>숫자가 아닌 문자</td>

</tr>

<tr><td><code>\W</code></td><td>영숫자가 아닌 문자</td>

</tr>

<tr><td><code>\S</code></td><td>공백이 아닌 문자</td>

</tr>

<tr><td><code>.</code></td><td>개행문자를 제외한 모든 문자</td>

</tr>

</table>

<p><a class="p_ident" id="p_yXMUKEYpwG" href="#p_yXMUKEYpwG" tabindex="-1" role="presentation"></a>따라서 01-30-2003 15:20과 같은 날짜 및 시간 형식은 다음과 같이 부합시킬 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y0e7M8nAL0" href="#c_Y0e7M8nAL0" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;01-30-2003 15:20&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;30-jan-2003 15:20&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_P0qAMYu0C/" href="#p_P0qAMYu0C/" tabindex="-1" role="presentation"></a>이러한 백슬래시 코드는 대괄호 안에도 사용할 수 있습니다. 예를 들어, <code>[\d.]</code>는 숫자 또는 마침표 문자를 의미합니다. 그러나 대괄호 사이의 마침표 자체는 특별한 의미를 잃습니다. <code>+</code>와 같은 다른 특수 문자도 마찬가지입니다.</p>

<p><a class="p_ident" id="p_HqQEZsitdl" href="#p_HqQEZsitdl" tabindex="-1" role="presentation"></a>문자 집합을 반전시키려면, 즉 집합에 있는 문자를 제외한 모든 문자와 일치시키고 싶다면 여는 괄호 뒤에 캐럿(<code>^</code>) 문자를 쓸 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_XH8deAcckk" href="#c_XH8deAcckk" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">notBinary</span> <span class="cm-operator">=</span> <span class="cm-string-2">/[^01]/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1100100010100110&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">notBinary</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1100100010200110&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<h2><a class="h_ident" id="h_iFI1qvUwY9" href="#h_iFI1qvUwY9" tabindex="-1" role="presentation"></a>패턴의 일부 반복</h2>

<p><a class="p_ident" id="p_crYiu/oAUM" href="#p_crYiu/oAUM" tabindex="-1" role="presentation"></a>이제 단일 숫자를 일치시키는 방법을 알았습니다. 정수(하나 이상의 숫자로 구성된 수열)를 일치시키려면 어떻게 하는가?</p>

<p><a class="p_ident" id="p_B4wupHzbR+" href="#p_B4wupHzbR+" tabindex="-1" role="presentation"></a>정규식에서 뒤에 더하기 기호(<code>+</code>)를 붙이면 요소가 두 번 이상 반복될 수 있음을 나타냅니다. 따라서 <code>/\d+/</code>는 하나 이상의 숫자 문자와 일치합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_9/5mFF4Ih4" href="#c_9/5mFF4Ih4" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;'123'&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d+'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;''&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;'123'&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/'\d*'/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;''&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_/oNBIVm41F" href="#p_/oNBIVm41F" tabindex="-1" role="presentation"></a>별표(<code>*</code>)는 비슷한 의미를 가지지만 패턴이 0번 일치하도록 허용합니다. 뒤에 별표가 있는 항목은 패턴 일치를 방해하지 않습니다. 일치할 적절한 텍스트를 찾을 수 없는 경우 0개의 인스턴스만 일치합니다.</p>

<p><a class="p_ident" id="p_77Y5t9C8NV" href="#p_77Y5t9C8NV" tabindex="-1" role="presentation"></a>물음표는 패턴의 일부를 선택 사항으로 만듭니다. 즉, 0번 또는 1번 발생할 수 있습니다. 다음 예에서 <em>u</em> 문자는 허용되지만 누락된 경우에도 패턴이 일치합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EiCIowdq+d" href="#c_EiCIowdq+d" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-operator">=</span> <span class="cm-string-2">/neighbou?r/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;neighbour&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">neighbor</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;neighbor&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_B4ikd8xN8i" href="#p_B4ikd8xN8i" tabindex="-1" role="presentation"></a>패턴이 정확한 횟수만큼 발생해야 함을 나타내려면 중괄호를 사용하십시오. 예를 들어 요소 뒤에 <code>{4}</code>를 붙이려면 정확히 4번 발생해야 합니다. 이 방법으로 범위를 지정할 수도 있습니다. <code>{2,4}</code>는 요소가 최소 두 번, 최대 네 번 발생해야 함을 의미합니다.</p>

<p id="date_regexp_counted"><a class="p_ident" id="p_a1yNHuI+49" href="#p_a1yNHuI+49" tabindex="-1" role="presentation"></a>다음은 한 자릿수 및 두 자릿수 일, 월 및 시간을 모두 허용하는 날짜 및 시간 패턴의 다른 버전입니다. 또한 해독하기가 약간 더 쉽습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Tw+K6Mxe45" href="#c_Tw+K6Mxe45" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">dateTime</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dateTime</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;1-30-2003 8:45&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_RjqN6VMQIa" href="#p_RjqN6VMQIa" tabindex="-1" role="presentation"></a>중괄호를 사용할 때 쉼표 뒤의 숫자를 생략하여 끝이 없는 범위를 지정할 수도 있습니다. 따라서 <code>{5,}</code>는 다섯 번 이상을 의미합니다.</p>

<h2><a class="h_ident" id="h_uICSDspz1I" href="#h_uICSDspz1I" tabindex="-1" role="presentation"></a>하위 표현식 그룹화</h2>

<p><a class="p_ident" id="p_pKTOYUDGIr" href="#p_pKTOYUDGIr" tabindex="-1" role="presentation"></a>한 번에 둘 이상의 요소에 <code>*</code> 또는 <code>+</code>를 사용하려면 괄호를 사용해야 합니다. 괄호로 묶인 정규식의 일부는 뒤에 오는 연산자에 관한 한 단일 요소로 간주됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P/f6a65XwI" href="#c_P/f6a65XwI" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">cartoonCrying</span> <span class="cm-operator">=</span> <span class="cm-string-2">/boo+(hoo+)+/i</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">cartoonCrying</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;Boohoooohoohooo&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_S5jkv2dMC+" href="#p_S5jkv2dMC+" tabindex="-1" role="presentation"></a>첫 번째와 두 번째 <code>+</code> 문자만 <em>boo</em>와 <em>hoo</em>에서 각각 두 번째 <em>o</em>에만 적용됩니다. 세 번째 <code>+</code>는 전체 그룹 <code>(hoo+)</code>에 적용되며, 다음과 같은 하나 이상의 수열과 일치합니다.</p>

<p><a class="p_ident" id="p_c4RlIM4/HI" href="#p_c4RlIM4/HI" tabindex="-1" role="presentation"></a>예에서 식의 끝에 <code>i</code>는 입력 문자열에서 대문자 <em>B</em>와 일치할 수 있도록 허용함(패턴이 소문자일지라도).</p>

<h2><a class="h_ident" id="h_CV5XL/TADP" href="#h_CV5XL/TADP" tabindex="-1" role="presentation"></a>부합과 그룹</h2>

<p><a class="p_ident" id="p_K3KRDzatsp" href="#p_K3KRDzatsp" tabindex="-1" role="presentation"></a><code>test</code> 메서드는 정규식을 일치시키는 가장 간단한 방법입니다. 일치 여부만 알려주고 다른 것은 표시하지 않습니다. 정규 표현식 에는 일치하는 항목이 없으면 반환하고 그렇지 않으면 일치 항목에 대한 정보가 포함된 개체를 반환하는 <code>exec</code> (execute) 메서드도 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JJMWZpk0iD" href="#c_JJMWZpk0iD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;one two 100&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>);
<span class="cm-comment">// → [&quot;100&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 8</span></pre>

<p><a class="p_ident" id="p_fJSwbQyG6w" href="#p_fJSwbQyG6w" tabindex="-1" role="presentation"></a><code>exec</code>에서 반환된 객체에는 문자열에서 성공적인 일치가 시작되는 위치를 알려주는 <code>index</code> 속성이 있습니다. 그 외에 객체는 문자열 배열처럼 보이며 첫 번째 요소가 일치된 문자열입니다. 이전 예에서 이것은 찾고 있던 숫자의 수열입니다.</p>

<p><a class="p_ident" id="p_VT4fpht7D7" href="#p_VT4fpht7D7" tabindex="-1" role="presentation"></a>문자열 값에는 유사하게 동작하는 <code>match</code> 메서드가 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uAkAqNYx+q" href="#c_uAkAqNYx+q" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;one two 100&quot;</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/\d+/</span>));
<span class="cm-comment">// → [&quot;100&quot;]</span></pre>

<p><a class="p_ident" id="p_/9rdcJO9zZ" href="#p_/9rdcJO9zZ" tabindex="-1" role="presentation"></a>정규식에 괄호로 묶인 하위 표현식이 포함되어 있으면 해당 그룹과 일치하는 텍스트도 배열에 표시됩니다. 전체 일치는 항상 첫 번째 요소입니다. 다음 요소는 첫 번째 그룹(표현식에서 여는 괄호가 먼저 오는 그룹)과 일치하는 부분이고, 그 다음 두 번째 그룹 등입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5E2M1BBsUm" href="#c_5E2M1BBsUm" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">quotedText</span> <span class="cm-operator">=</span> <span class="cm-string-2">/'([^']*)'/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">quotedText</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;she said 'hello'&quot;</span>));
<span class="cm-comment">// → [&quot;'hello'&quot;, &quot;hello&quot;]</span></pre>

<p><a class="p_ident" id="p_f4bciMASJ1" href="#p_f4bciMASJ1" tabindex="-1" role="presentation"></a>그룹이 전혀 일치하지 않는 경우(예: 뒤에 물음표가 있는 경우) 출력 배열에서 그룹의 위치는 <code>undefined</code>로 유지됩니다. 마찬가지로 그룹이 여러 번 일치하면 마지막 일치만 배열에서 끝납니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_j9t+gn+1eT" href="#c_j9t+gn+1eT" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/bad(ly)?/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;bad&quot;</span>));
<span class="cm-comment">// → [&quot;bad&quot;, undefined]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/(\d)+/</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;123&quot;</span>));
<span class="cm-comment">// → [&quot;123&quot;, &quot;3&quot;]</span></pre>

<p><a class="p_ident" id="p_GvLofvnQnz" href="#p_GvLofvnQnz" tabindex="-1" role="presentation"></a>그룹은 문자열의 일부를 추출하는 데 유용할 수 있습니다. 문자열에 날짜가 포함되어 있는지 여부만 확인하는 것이 아니라 이를 추출하고 이를 나타내는 객체를 구성하려는 경우 숫자 패턴을 괄호로 묶고 <code>exec</code> 결과에서 날짜를 직접 선택할 수 있습니다.</p>

<p><a class="p_ident" id="p_DzNUSBaBZb" href="#p_DzNUSBaBZb" tabindex="-1" role="presentation"></a>그러나 먼저 JavaScript에서 날짜 및 시간 값을 나타내는 기본 제공 방법에 대해 설명하는 간단한 우회를 사용합니다.</p>

<h2><a class="h_ident" id="h_8U7L7LCU27" href="#h_8U7L7LCU27" tabindex="-1" role="presentation"></a>Date 클래스</h2>

<p><a class="p_ident" id="p_2NeTRvucQq" href="#p_2NeTRvucQq" tabindex="-1" role="presentation"></a>JavaScript에는 날짜 또는 특정 시점을 나타내는 표준 클래스 <code>Date</code>가 있습니다. <code>new</code>를 사용하여 단순히 날짜 객체를 생성하면 현재 날짜와 시간을 얻을 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AjgqFetryg" href="#c_AjgqFetryg" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>());
<span class="cm-comment">// → Mon Nov 13 2017 16:19:11 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_IcV7kv3B1y" href="#p_IcV7kv3B1y" tabindex="-1" role="presentation"></a>특정 시간에 대한 객체를 만들 수도 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_2VCU0f4HsQ" href="#c_2VCU0f4HsQ" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>));
<span class="cm-comment">// → Wed Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2009</span>, <span class="cm-number">11</span>, <span class="cm-number">9</span>, <span class="cm-number">12</span>, <span class="cm-number">59</span>, <span class="cm-number">59</span>, <span class="cm-number">999</span>));
<span class="cm-comment">// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_cYaexzwHiw" href="#p_cYaexzwHiw" tabindex="-1" role="presentation"></a>JavaScript는 월 숫자가 0에서 시작하는 규칙을 사용하지만(12월은 11이 됨) 일 숫자는 1에서 시작합니다. 이것은 혼란스러우니 조심합니다.</p>

<p><a class="p_ident" id="p_gVdQSb0Lv9" href="#p_gVdQSb0Lv9" tabindex="-1" role="presentation"></a>마지막 4개의 인수(시, 분, 초 및 밀리초)는 선택 사항이며 지정하지 않으면 0으로 간주됩니다.</p>

<p><a class="p_ident" id="p_1mIMU5T5MA" href="#p_1mIMU5T5MA" tabindex="-1" role="presentation"></a>타임스탬프는 UTC 표준 시간대를 기준으로 1970년이 시작된 이후의 밀리초 수로 저장됩니다. 이것은 그 시기에 발명된 "Unix time"에 의해 설정된 규칙을 따릅니다. 1970년 이전의 시간에는 음수를 사용할 수 있습니다. 날짜 객체의 <code>getTime</code> 메서드는 이 숫자를 반환합니다. 그것은 상당히 큽니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_lMlCuckMIc" href="#c_lMlCuckMIc" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">2013</span>, <span class="cm-number">11</span>, <span class="cm-number">19</span>).<span class="cm-property">getTime</span>());
<span class="cm-comment">// → 1387407600000</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-number">1387407600000</span>));
<span class="cm-comment">// → Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_Cn9WUyCZhq" href="#p_Cn9WUyCZhq" tabindex="-1" role="presentation"></a><code>Date</code> 생성자에 단일 인수를 제공하면 해당 인수는 밀리초 카운트로 처리됩니다. 새 <code>Date</code> 객체를 만들고 <code>getTime</code>을 호출하거나 <code>Date.now</code>를 호출하여 현재 밀리초 수를 얻을 수 있습니다.</p>

<p><a class="p_ident" id="p_iqL2Ehg9D4" href="#p_iqL2Ehg9D4" tabindex="-1" role="presentation"></a>Date 객체는 <code>getFullYear</code>, <code>getMonth</code>, <code>getDate</code>, <code>getHours</code>, <code>getMinutes</code> 및 <code>getSeconds</code> 메서드를 제공하여 그 구성 요소를 추출합니다. 게다가 <code>getYear</code> 메서드를 통해 년도에서 1900을 뺀 값을 제공할 수 있습니다.</p>

<p><a class="p_ident" id="p_/RCtQyD3w/" href="#p_/RCtQyD3w/" tabindex="-1" role="presentation"></a>관심 있는 표현식 부분을 괄호로 묶으면 이제 문자열에서 날짜 객체를 만들 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xW0xfMnpiZ" href="#c_xW0xfMnpiZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">getDate</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">let</span> [<span class="cm-def">_</span>, <span class="cm-def">month</span>, <span class="cm-def">day</span>, <span class="cm-def">year</span>] <span class="cm-operator">=</span>
    <span class="cm-string-2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">string</span>);
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Date</span>(<span class="cm-variable-2">year</span>, <span class="cm-variable-2">month</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>, <span class="cm-variable-2">day</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">getDate</span>(<span class="cm-string">&quot;1-30-2003&quot;</span>));
<span class="cm-comment">// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p_YUOJEGEtSI" href="#p_YUOJEGEtSI" tabindex="-1" role="presentation"></a><code>_</code> (underscore) 바인딩은 <code>exec</code>에 의해 반환된 배열에서 완전 부합 요소를 무시하고 건너 뛰는데 사용합니다.</p>

<h2><a class="h_ident" id="h_26ixny78VY" href="#h_26ixny78VY" tabindex="-1" role="presentation"></a>단어 및 문자열 경계</h2>

<p><a class="p_ident" id="p_xdYJVr9vlf" href="#p_xdYJVr9vlf" tabindex="-1" role="presentation"></a><code>getDate</code>는 문자열에서 무의미한 날짜 00-1-3000을 <code>&quot;100-1-30000&quot;</code> 문자열에서 추출합니다. 이 경우 두 번째 문자에서 시작하여 마지막에서 두 번째 문자에서 끝납니다.</p>

<p><a class="p_ident" id="p_kLS7rqRrqG" href="#p_kLS7rqRrqG" tabindex="-1" role="presentation"></a>일치 항목이 전체 문자열에 걸쳐 있어야 하도록 하려면 마커 <code>^</code>와 <code>$</code>를 추가할 수 있습니다. 캐럿은 입력 문자열의 시작과 일치하는 반면 달러 기호는 끝과 일치합니다. 따라서 <code>/^\d+$/</code>는 완전히 하나 이상의 숫자로 구성된 문자열을 부합시키고, <code>/x^/</code>은 어떠한 문자열도 부합시키지 않습니다(문자열 시작 앞에 <em>x</em>가 있을 수 없음).</p>

<p><a class="p_ident" id="p_fEYS5Ev94W" href="#p_fEYS5Ev94W" tabindex="-1" role="presentation"></a>반면에 날짜가 단어 경계에서 시작하고 끝나는지 확인하려면 marker <code>\b</code>를 사용할 수 있습니다. 단어 경계는 문자열의 시작 또는 끝이거나 한쪽에 단어 문자(<code>\w</code>에서와 같이)가 있고 다른쪽에 단어가 아닌 문자가 있는 문자열의 임의의 지점일 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_6U0b866tUk" href="#c_6U0b866tUk" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/cat/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;concatenate&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\bcat\b/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;concatenate&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_btxd6luedx" href="#p_btxd6luedx" tabindex="-1" role="presentation"></a>경계 마커는 실제 문자와 일치하지 않습니다. 패턴에 나타나는 위치에서 특정 조건이 유지되는 경우에만 정규식이 일치하도록 강요합니다.</p>

<h2><a class="h_ident" id="h_In3b+t6uOO" href="#h_In3b+t6uOO" tabindex="-1" role="presentation"></a>선택 패턴</h2>

<p><a class="p_ident" id="p_G5RTt0AFku" href="#p_G5RTt0AFku" tabindex="-1" role="presentation"></a>텍스트 부분에 숫자뿐만 아니라 숫자 뒤에 <em>pig</em>, <em>cow</em> 또는 <em>chicken</em>이라는 단어 중 하나 또는 복수형이 포함되어 있는지 알고 싶다고 가정해 보겠습니다.</p>

<p><a class="p_ident" id="p_GcEbQJT+nS" href="#p_GcEbQJT+nS" tabindex="-1" role="presentation"></a>세 개의 정규 표현식을 작성하고 차례로 테스트할 수 있지만 더 좋은 방법이 있습니다. 파이프 문자(<code>|</code>)는 왼쪽 패턴과 오른쪽 패턴 사이의 선택을 나타냅니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_z0soEIN8RB" href="#c_z0soEIN8RB" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">animalCount</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+ (pig|cow|chicken)s?\b/</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;15 pigs&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">animalCount</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;15 pigchickens&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_bPWKulKcxf" href="#p_bPWKulKcxf" tabindex="-1" role="presentation"></a>괄호는 파이프 연산자가 적용되는 패턴의 일부를 제한하는 데 사용할 수 있으며, 이러한 연산자를 여러 개 나란히 배치하여 둘 이상의 대안 중에서 선택을 표현할 수 있습니다.</p>

<h2><a class="h_ident" id="h_AzxCBCKdvY" href="#h_AzxCBCKdvY" tabindex="-1" role="presentation"></a>매칭의 역학</h2>

<p><a class="p_ident" id="p_SXQOi9ZwwH" href="#p_SXQOi9ZwwH" tabindex="-1" role="presentation"></a>개념적으로 <code>exec</code> 또는 <code>test</code>를 사용할 때 정규식 엔진은 일치하는 항목을 찾거나 문자열의 끝 부합을 시도합니다. 찾을 수 있는 첫 번째 일치 항목을 반환하거나 일치 항목을 전혀 찾지 못합니다.</p>

<p><a class="p_ident" id="p_HJjJAo8dQp" href="#p_HJjJAo8dQp" tabindex="-1" role="presentation"></a>실제 부합을 수행하기 위해 엔진은 정규식을 흐름도와 같이 취급합니다. 다음은 이전 예의 가축 표현에 대한 다이어그램입니다.</p><figure><img src="img/re_pigchickens.svg" alt="Visualization of /\b\d+ (pig|cow|chicken)s?\b/"></figure>

<p><a class="p_ident" id="p_SNiUdMyezk" href="#p_SNiUdMyezk" tabindex="-1" role="presentation"></a>다이어그램의 왼쪽에서 오른쪽으로 경로를 찾을 수 있으면 표현식이 일치합니다. 문자열의 현재 위치를 유지하고 상자를 이동할 때마다 현재 위치 뒤의 문자열 부분이 해당 상자와 일치하는지 확인합니다.</p>

<p><a class="p_ident" id="p_MB99a8uIlE" href="#p_MB99a8uIlE" tabindex="-1" role="presentation"></a>따라서 위치 4로부터 <code>&quot;the 3 pigs&quot;</code>의 부합을 시도하면, 서도를 통한 진행 상황은 다음과 같습니다.</p>

<ul>

<li>

<p><a class="p_ident" id="p_bgxoerTVW4" href="#p_bgxoerTVW4" tabindex="-1" role="presentation"></a>위치 4에는 단어 경계가 있으므로 첫 번째 상자를 지나갈 수 있습니다.</p></li>

<li>

<p><a class="p_ident" id="p_YCV1/H+Rbe" href="#p_YCV1/H+Rbe" tabindex="-1" role="presentation"></a>여전히 위치 4에서 숫자를 찾았으므로 두 번째 상자를 지나갈 수도 있습니다.</p></li>

<li>

<p><a class="p_ident" id="p_fQdWHxKgCF" href="#p_fQdWHxKgCF" tabindex="-1" role="presentation"></a>위치 5에서 한 경로는 두 번째(숫자) 상자 앞으로 루프백되고 다른 경로는 단일 공백 문자가 있는 상자를 통해 앞으로 이동합니다. 여기에 숫자가 아닌 공백이 있으므로 두 번째 경로를 선택해야 합니다.</p></li>

<li>

<p><a class="p_ident" id="p_KItk5iNp9m" href="#p_KItk5iNp9m" tabindex="-1" role="presentation"></a>이제 위치 6(<em>pigs</em> 시작)과 다이어그램의 세 방향 분기에 있습니다. 여기서는 <em>cow</em> 또는 <em>chicken</em>을 보지 못하지만, <em>pig</em>를 볼 수 있습니다. 따라서 그쪽 분기를 취합니다.</p></li>

<li>

<p><a class="p_ident" id="p_SowlGZC6lM" href="#p_SowlGZC6lM" tabindex="-1" role="presentation"></a>위치 9에서 세 방향 분기후 한 경로는 <em>s</em> 상자를 건너뛰고 최종 단어 경계로 곧장 이동하고 다른 경로는 <em>s</em>와 일치합니다. 여기에는 단어 경계가 아닌 <em>s</em> 문자가 있으므로 <em>s</em> 상자를 살펴봅니다.</p></li>

<li>

<p><a class="p_ident" id="p_oJRMcnDoAt" href="#p_oJRMcnDoAt" tabindex="-1" role="presentation"></a>위치 10(문자열의 끝)에 있으며 단어 경계만 일치시킬 수 있습니다. 문자열의 끝은 단어 경계로 간주되므로 마지막 상자를 살펴보면 이 문자열과 성공적으로 일치했습니다.</p></li></ul>

<h2 id="backtracking"><a class="h_ident" id="h_NFMtGK0tD3" href="#h_NFMtGK0tD3" tabindex="-1" role="presentation"></a>역추적</h2>

<p><a class="p_ident" id="p_tCd15MFAty" href="#p_tCd15MFAty" tabindex="-1" role="presentation"></a>정규식 <code>/<wbr>\b([01]+b|[\da-f]+h|\d+)\b/<wbr></code>은 <em>b</em>를 수반하는 이진수, <em>h</em>를 수반하는 16진수 또는 어떠한 접미사도 갖지 않는 정규 십진수를 부합시킵니다. 이는 다음 다이아그램과 같습니다.</p><figure><img src="img/re_number.svg" alt="Visualization of /\b([01]+b|\d+|[\da-f]+h)\b/"></figure>

<p><a class="p_ident" id="p_MypvfTaiTG" href="#p_MypvfTaiTG" tabindex="-1" role="presentation"></a>이러한 표현식을 부합시킬 때 입력에 실제로 이진수가 포함되지 않은 경우에도 상위(이진) 분기가 입력되는 경우가 종종 있습니다. 예를 들어 <code>&quot;103&quot;</code> 문자열을 일치시킬 때 3에서만 잘못된 분기에 있다는 것이 분명해집니다. 문자열은 현재 분기가 아닌 식을 부합시킵니다.</p>

<p><a class="p_ident" id="p_SjTCKE9hvf" href="#p_SjTCKE9hvf" tabindex="-1" role="presentation"></a>이리하여 따라서 matcher는 역추적합니다. 분기에 들어갈 때 현재 위치(이 경우 문자열의 시작 부분, 다이어그램의 첫 번째 경계 상자 바로 지나서)를 기억하므로 현재 분기가 제대로 작동하지 않으면 돌아가서 다른 분기를 시도할 수 있습니다. 문자열의 <code>&quot;103&quot;</code>의 경우 세 개의 문자를 만난 후 16진수에 대한 분기를 시도하기 시작합니다. 숫자 뒤에 h가 없기 때문에 다시 실패합니다. 그래서 십진수 분기를 시도합니다. 이것은 적합하고 결국 일치가 보고 됩니다.</p>

<p><a class="p_ident" id="p_VymH7raTcU" href="#p_VymH7raTcU" tabindex="-1" role="presentation"></a>matcher는 전체 일치 항목을 찾는 즉시 중지합니다. 즉, 여러 분기가 잠재적으로 문자열과 일치할 수 있는 경우 첫 번째 분기(정규 표현식에서 분기가 나타나는 위치에 따라 정렬됨)만 사용됩니다.</p>

<p><a class="p_ident" id="p_zEBIV8lYeb" href="#p_zEBIV8lYeb" tabindex="-1" role="presentation"></a>역추적은 + 및 <code>*</code>와 같은 반복 연산자에 대해서도 발생합니다. <code>&quot;abcxe&quot;</code>에 관해 <code>/^.*x/</code>를 부합시키면, <code>.*</code> 부분은 먼저 전체 문자열을 사용하려고 시도합니다. 그러면 엔진은 패턴과 일치하기 위해 <em>x</em>가 필요하다는 것을 알게 됩니다. 문자열 끝에 <em>x</em>가 없기 때문에 별 연산자는 한 문자 적게 일치시키려고 합니다. 그러나 matcher는 <code>abcx</code> 뒤에도 <em>x</em>를 찾지 못하므로 다시 역추적하여 star 연산자를 <code>abc</code>에 일치시킵니다. 이제 필요한 위치에서 x를 찾고 위치 0에서 4까지의 성공적인 일치를 보고합니다.</p>

<p><a class="p_ident" id="p_0MBBMH8aI2" href="#p_0MBBMH8aI2" tabindex="-1" role="presentation"></a>많은 역추적을 수행하는 정규식을 작성하는 것이 가능합니다. 이러한 문제는 패턴이 다양한 방식으로 입력과 일치할 때 발생합니다. 예를 들어, 이진수 정규식을 작성하는 동안 혼란스러워지면 실수로 <code>/([01]+)+b/</code>와 같이 작성할 수 있습니다.</p><figure><img src="img/re_slow.svg" alt="Visualization of /([01]+)+b/"></figure>

<p><a class="p_ident" id="p_5cI0Ma3Wy8" href="#p_5cI0Ma3Wy8" tabindex="-1" role="presentation"></a>후행 <em>b</em> 문자가 없는 긴 일련의 0과 1을 일치시키려고 하면 matcher는 먼저 숫자가 다 떨어질 때까지 내부 루프를 거칩니다. 그런 다음 b가 없다는 것을 알아차리고 한 위치를 역추적하고 외부 루프를 한 번 통과하고 다시 포기하고 내부 루프에서 다시 한 번 역추적을 시도합니다. 이 두 루프를 통해 가능한 모든 경로를 계속 시도합니다. 이는 캐릭터가 추가될 때마다 작업량이 2배가 됨을 의미합니다. 수십 개의 문자만 있어도 결과적으로 일치하는 데는 거의 영원히 걸릴 것입니다.</p>

<h2><a class="h_ident" id="h_k0YuTOu54D" href="#h_k0YuTOu54D" tabindex="-1" role="presentation"></a>대체 메서드</h2>

<p><a class="p_ident" id="p_HMQv5qrs78" href="#p_HMQv5qrs78" tabindex="-1" role="presentation"></a>문자열 값에는 문자열의 일부를 다른 문자열로 바꾸는 데 사용할 수 있는 <code>replace</code> 메서드가 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_dPdIdK/Wyi" href="#c_dPdIdK/Wyi" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;papa&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string">&quot;p&quot;</span>, <span class="cm-string">&quot;m&quot;</span>));
<span class="cm-comment">// → mapa</span></pre>

<p><a class="p_ident" id="p_jjBKX9l81o" href="#p_jjBKX9l81o" tabindex="-1" role="presentation"></a>첫 번째 인수는 정규식일 수도 있으며 이 경우 정규식의 첫 번째 일치 항목이 대체됩니다. <code>g</code>옵션이 (<em>global</em>에 관해) 정규 표현식에 추가될 때, 모든 부합된 문자열이 대체됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ztGnSKyKy1" href="#c_ztGnSKyKy1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Borobudur&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/</span>, <span class="cm-string">&quot;a&quot;</span>));
<span class="cm-comment">// → Barobudur</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Borobudur&quot;</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[ou]/g</span>, <span class="cm-string">&quot;a&quot;</span>));
<span class="cm-comment">// → Barabadar</span></pre>

<p><a class="p_ident" id="p_BTzyExrWv3" href="#p_BTzyExrWv3" tabindex="-1" role="presentation"></a>하나의 일치 항목을 교체하거나 모든 일치 항목을 교체하는 것 중 하나를 선택하는 것이 <code>replace</code>에 대한 추가 인수를 통해 또는 다른 <code>replaceAll</code> 메서드를 제공하여 이루어진 경우 합리적이었을 것입니다. 그러나 선택은 정규 표현식의 속성에 의존합니다.</p>

<p><a class="p_ident" id="p_/5YU/Qo2Np" href="#p_/5YU/Qo2Np" tabindex="-1" role="presentation"></a><code>replace</code>와 함께 정규식을 사용하는 진정한 힘은 대체 문자열에서 일치하는 그룹을 참조할 수 있다는 사실에서 나옵니다. 예를 들어, 사람의 이름을 포함하는 큰 문자열이 있고 한 줄에 하나씩 형식으로 <code>Lastname, Firstname</code>을 포함하는 큰 문자열을 갖는 경우에 이러한 이름을 바꾸고 쉼표를 제거하여 <code>Firstname Lastname</code> 형식을 얻으려면 다음 코드를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5P5aZAbVLL" href="#c_5P5aZAbVLL" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(
  <span class="cm-string">&quot;Liskov, Barbara\nMcCarthy, John\nWadler, Philip&quot;</span>
    .<span class="cm-property">replace</span>(<span class="cm-string-2">/(\w+), (\w+)/g</span>, <span class="cm-string">&quot;$2 $1&quot;</span>));
<span class="cm-comment">// → Barbara Liskov</span>
<span class="cm-comment">//   John McCarthy</span>
<span class="cm-comment">//   Philip Wadler</span></pre>

<p><a class="p_ident" id="p_sEudLRqyzC" href="#p_sEudLRqyzC" tabindex="-1" role="presentation"></a>대체 문자열에서 <code>$1</code>과 <code>$2</code>는 패턴 내에 괄호 그룹을 참조합니다. <code>$1</code>은 첫 번째 그룹과 일치하는 텍스트로 대체되고 <code>$2</code>는 두 번째에 의한 것으로 대체되는 방식을 취합니다(<code>$9</code>에 이르기까지). 전체 부합은 <code>$&amp;</code>로 참조될 수 있습니다.</p>

<p><a class="p_ident" id="p_BpgnqwKFHn" href="#p_BpgnqwKFHn" tabindex="-1" role="presentation"></a><code>replace</code>에 대한 두 번째 인수로 문자열이 아닌 함수를 전달할 수 있습니다. 각 교체에 대해 함수는 일치하는 그룹(및 전체 일치)을 인수로 사용하여 호출되고 반환 값이 새 문자열에 삽입됩니다.</p>

<p><a class="p_ident" id="p_GbNoBizUD+" href="#p_GbNoBizUD+" tabindex="-1" role="presentation"></a>간단한 예:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fwgl3+oeyX" href="#c_fwgl3+oeyX" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">s</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;the cia and fbi&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">s</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\b(fbi|cia)\b/g</span>,
            <span class="cm-def">str</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">str</span>.<span class="cm-property">toUpperCase</span>()));
<span class="cm-comment">// → the CIA and FBI</span></pre>

<p><a class="p_ident" id="p_EXxvdgdiP1" href="#p_EXxvdgdiP1" tabindex="-1" role="presentation"></a>보다 흥미로운 예:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Zo/y2Vv93l" href="#c_Zo/y2Vv93l" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">stock</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;1 lemon, 2 cabbages, and 101 eggs&quot;</span>;
<span class="cm-keyword">function</span> <span class="cm-def">minusOne</span>(<span class="cm-def">match</span>, <span class="cm-def">amount</span>, <span class="cm-def">unit</span>) {
  <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-variable">Number</span>(<span class="cm-variable-2">amount</span>) <span class="cm-operator">-</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) { <span class="cm-comment">// only one left, remove the 's'</span>
    <span class="cm-variable-2">unit</span> <span class="cm-operator">=</span> <span class="cm-variable-2">unit</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">unit</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">amount</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">amount</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;no&quot;</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">+</span> <span class="cm-string">&quot; &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">unit</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stock</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/(\d+) (\w+)/g</span>, <span class="cm-variable">minusOne</span>));
<span class="cm-comment">// → no lemon, 1 cabbage, and 100 eggs</span></pre>

<p><a class="p_ident" id="p_bv4e/DVilz" href="#p_bv4e/DVilz" tabindex="-1" role="presentation"></a>이것은 문자열을 취하고 영숫자 단어가 뒤따르는 숫자의 모든 발생을 찾고 그러한 모든 발생이 1씩 감소하는 문자열을 반환합니다.</p>

<p><a class="p_ident" id="p_H94SX/MJX8" href="#p_H94SX/MJX8" tabindex="-1" role="presentation"></a><code>(\d+)</code> 그룹은 함수에서 <code>amount</code> 인수로 끝나고, <code>(\w+)</code> 그룹은 <code>unit</code>와 결합됩니다. 함수는 <code>amount</code>를 수로 변환하고(<code>\d+</code>와 부합되었기 때문에) 하나 또는 영 개만 남아 있는 경우 몇 가지 조정을 수행합니다.</p>

<h2><a class="h_ident" id="h_kiECehz+i+" href="#h_kiECehz+i+" tabindex="-1" role="presentation"></a>Greed</h2>

<p><a class="p_ident" id="p_VccKwuX/1m" href="#p_VccKwuX/1m" tabindex="-1" role="presentation"></a>JavaScript 코드에서 모든 주석을 제거하는 함수를 작성하는 데 <code>replace</code>를 사용할 수 있습니다. 다음은 첫 번째 시도입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_u0oKSJTOA2" href="#c_u0oKSJTOA2" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="cm-string">&quot;&quot;</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 + /* 2 */3&quot;</span>));
<span class="cm-comment">// → 1 + 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;x = 10;// ten!&quot;</span>));
<span class="cm-comment">// → x = 10;</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="cm-comment">// → 1  1</span></pre>

<p><a class="p_ident" id="p_DkzBCJQQdu" href="#p_DkzBCJQQdu" tabindex="-1" role="presentation"></a><em>or</em> 연산자 앞의 부분은 두 개의 슬래시 문자 다음에 임의의 수의 개행 문자가 아닌 문자가 오는 것과 일치합니다. 여러 줄 주석에 대한 부분은 더 복잡합니다. <code>[^]</code>를 어떤 문자와도 일치시키는 방법으로 사용합니다. 블록 주석이 새 줄에서 계속될 수 있고 마침표 문자가 줄 바꿈 문자와 일치하지 않기 때문에 여기에서 마침표를 사용할 수 없습니다.</p>

<p><a class="p_ident" id="p_s9E9JYjAYp" href="#p_s9E9JYjAYp" tabindex="-1" role="presentation"></a>그러나 마지막 라인의 출력이 잘못되었습니다.</p>

<p><a class="p_ident" id="p_atS1ERkauC" href="#p_atS1ERkauC" tabindex="-1" role="presentation"></a>역추적 부분에서 설명한 대로 표현식의 <code>[^]*</code>의 일부는 가능한 한 먼저 부합됩니다. 이로 인해 패턴의 다음 부분이 실패하면 매처는 한 문자 뒤로 이동하고 거기에서 다시 시도합니다. 예에서 매처는 먼저 문자열의 나머지 전체를 일치시키려고 시도한 다음 거기에서 다시 이동합니다. 4개의 문자로 돌아가서 일치시킨 후 <code>*/</code>의 발생을 찾습니다. 이것은 원하는 것이 아닙니다. 의도는 단일 주석을 일치시키는 것이지, 코드 끝까지 가서 마지막 블록 주석의 끝을 찾는 것이 아닙니다.</p>

<p><a class="p_ident" id="p_eNtLSVH65f" href="#p_eNtLSVH65f" tabindex="-1" role="presentation"></a>이러한 동작때문에 반복 연산자들이 (<code>+</code>, <code>*</code>, <code>?</code> 및 <code>{}</code>) <em>greedy</em>하다고 합니다. 그것들 다음에 물음표를 사용하면(<code>+?</code>, <code>*?</code>, <code>??</code>, <code>{}?</code>), 욕심이 없어져서 최대한 적게 매칭을 시작하고 나머지 패턴이 작은 매칭에 맞지 않을 때만 매칭을 더 많이 합니다.</p>

<p><a class="p_ident" id="p_0L47KZXZKa" href="#p_0L47KZXZKa" tabindex="-1" role="presentation"></a>이것이 바로 이 경우에 원하는 것입니다. 별이 <code>*/</code>로 이끄는 가장 작은 문자와 일치하게 함으로써 하나의 블록 주석을 소비하고 그 이상은 사용하지 않습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_MCNF7GxfR1" href="#c_MCNF7GxfR1" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">stripComments</span>(<span class="cm-def">code</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">code</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="cm-string">&quot;&quot;</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">stripComments</span>(<span class="cm-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="cm-comment">// → 1 + 1</span></pre>

<p><a class="p_ident" id="p_o+3JCFC4Dr" href="#p_o+3JCFC4Dr" tabindex="-1" role="presentation"></a>정규식 프로그램의 많은 버그는 욕심이 없는 연산자가 더 잘 작동하는 욕심 많은 연산자를 의도하지 않게 사용하여 추적할 수 있습니다. 반복 연산자를 사용할 때 nongreedy 변형을 먼저 고려하십시오.</p>

<h2><a class="h_ident" id="h_Rhu25fogrG" href="#h_Rhu25fogrG" tabindex="-1" role="presentation"></a>RegExp 개체를 동적으로 생성</h2>

<p><a class="p_ident" id="p_34PsyHYX4x" href="#p_34PsyHYX4x" tabindex="-1" role="presentation"></a>코드를 작성할 때 일치시켜야 하는 정확한 패턴을 모를 수 있는 경우가 있습니다. 텍스트에서 사용자 이름을 찾고 눈에 띄도록 밑줄 문자로 묶고 싶다고 가정해 보겠습니다. 프로그램이 실제로 실행된 후에야 이름을 알 수 있으므로 슬래시 기반 표기법을 사용할 수 없습니다.</p>

<p><a class="p_ident" id="p_KAQggWa80Y" href="#p_KAQggWa80Y" tabindex="-1" role="presentation"></a>그러나 문자열을 만들고 <code>RegExp</code> 생성자를 사용할 수 있습니다. 다음은 예입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_3yQimfD35d" href="#c_3yQimfD35d" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">name</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;harry&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Harry is a suspicious character.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;\\b(&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable">name</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;)\\b&quot;</span>, <span class="cm-string">&quot;gi&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">&quot;_$1_&quot;</span>));
<span class="cm-comment">// → _Harry_ is a suspicious character.</span></pre>

<p><a class="p_ident" id="p_J6H1NBoQy/" href="#p_J6H1NBoQy/" tabindex="-1" role="presentation"></a><code>\b</code> 경계 마커를 만들 때 슬래시로 묶인 정규식이 아닌 일반 문자열로 작성하기 때문에 두 개의 백슬래시를 사용해야 합니다. <code>RegExp</code> 생성자에 대한 두 번째 인수에는 정규식(이 경우 전역에 관해서는 <code>&quot;gi&quot;</code> 및 대소문자 구분 안함)에 대한 옵션이 포함되어 있습니다.</p>

<p><a class="p_ident" id="p_UPAgEiKHfS" href="#p_UPAgEiKHfS" tabindex="-1" role="presentation"></a>그러나 사용자가 괴상하기 때문에 이름이 <code>&quot;dea+hl[]rd&quot;</code>으로 지정된 경우에는 어떻게 될까요? 그러면 실제로 사용자 이름과 일치하지 않는 무의미한 정규식이 생성됩니다.</p>

<p><a class="p_ident" id="p_Q+hqmMv8NT" href="#p_Q+hqmMv8NT" tabindex="-1" role="presentation"></a>이 문제를 해결하기 위해 특별한 의미가 있는 문자 앞에 백슬래시를 추가할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VVThPW6YGV" href="#c_VVThPW6YGV" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">name</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;dea+hl[]rd&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;This dea+hl[]rd guy is super annoying.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">escaped</span> <span class="cm-operator">=</span> <span class="cm-variable">name</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/[\\[.+*?(){|^$]/g</span>, <span class="cm-string">&quot;\\$&amp;&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">regexp</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">RegExp</span>(<span class="cm-string">&quot;\\b&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable">escaped</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;\\b&quot;</span>, <span class="cm-string">&quot;gi&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-variable">regexp</span>, <span class="cm-string">&quot;_$&amp;_&quot;</span>));
<span class="cm-comment">// → This _dea+hl[]rd_ guy is super annoying.</span></pre>

<h2><a class="h_ident" id="h_Txg7z4j/ei" href="#h_Txg7z4j/ei" tabindex="-1" role="presentation"></a>검색 방법</h2>

<p><a class="p_ident" id="p_3QlEdRm5L2" href="#p_3QlEdRm5L2" tabindex="-1" role="presentation"></a><code>indexOf</code> 문자열 메서드는 정규식으로 호출할 수 없습니다. 그러나 정규식을 필요로 하는 또 다른 <code>search</code> 메서드가 있습니다. <code>indexOf</code>와 마찬가지로 표현식이 발견된 첫 번째 인덱스를 반환하거나 찾지 못한 경우 -1을 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_diUfxE6ifs" href="#c_diUfxE6ifs" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;  word&quot;</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;    &quot;</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>));
<span class="cm-comment">// → -1</span></pre>

<p><a class="p_ident" id="p_tqlyvUKoi5" href="#p_tqlyvUKoi5" tabindex="-1" role="presentation"></a>불행히도 매치가 주어진 오프셋에서 시작되어야 함을 나타낼 수 있는 방법은 없습니다(<code>indexOf</code>에 대한 두 번째 인수로 할 수 있는 것처럼). 이는 종종 유용할 것입니다.</p>

<h2><a class="h_ident" id="h_duFTd2hqd0" href="#h_duFTd2hqd0" tabindex="-1" role="presentation"></a>lastIndex 속</h2>

<p><a class="p_ident" id="p_MvO8+re1D+" href="#p_MvO8+re1D+" tabindex="-1" role="presentation"></a><code>exec</code>와 마찬가지로 문자열의 지정된 위치에서 검색을 시작하는 편리한 방법을 제공하지 않지만, 편리한 방식을 제공합니다.</p>

<p><a class="p_ident" id="p_F+JgzwxLtK" href="#p_F+JgzwxLtK" tabindex="-1" role="presentation"></a>정규식 객체는 속성들을 가집니다. 이러한 속성 중 하나는 <code>source</code>로 표현식이 생성된 문자열을 포함합니다. 또 다른 속성은 <code>lastIndex</code>로 제한된 상황에서 다음 부합이 시작되는 위치를 제어합니다.</p>

<p><a class="p_ident" id="p_Ld5Vcdy0jB" href="#p_Ld5Vcdy0jB" tabindex="-1" role="presentation"></a>이러한 상황은 정규식에 전역(<code>g</code>) 또는 고정(<code>y</code>) 옵션이 활성화되어 있어야 하고 일치가 <code>exec</code> 메서드를 통해 발생해야 합니다. 다시 말하지만 덜 혼란스러운 솔루션은 추가 인수를 <code>exec</code>에 전달하는 것이었지만 JavaScript의 정규식 인터페이스의 필수 기능입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nXsHtqIJdF" href="#c_nXsHtqIJdF" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">pattern</span> <span class="cm-operator">=</span> <span class="cm-string-2">/y/g</span>;
<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
<span class="cm-keyword">let</span> <span class="cm-def">match</span> <span class="cm-operator">=</span> <span class="cm-variable">pattern</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyzzy&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">match</span>.<span class="cm-property">index</span>);
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">pattern</span>.<span class="cm-property">lastIndex</span>);
<span class="cm-comment">// → 5</span></pre>

<p><a class="p_ident" id="p_hjLQ+57mDd" href="#p_hjLQ+57mDd" tabindex="-1" role="presentation"></a>일치에 성공하면 <code>exec</code>에 대한 호출이 일치 후를 가리키도록 <code>lastIndex</code> 속성을 자동으로 업데이트합니다. 일치하는 항목이 없으면 <code>lastIndex</code>는 새로 구성된 정규식 객체에 있는 값이기도 한 0으로 다시 설정됩니다.</p>

<p><a class="p_ident" id="p_dQPVkpMm7y" href="#p_dQPVkpMm7y" tabindex="-1" role="presentation"></a>전역 옵션과 고정 옵션의 차이점은 고정 옵션이 활성화되면 <code>lastIndex</code>에서 직접 시작하는 경우에만 일치가 성공하는 반면 전역 옵션을 사용하면 일치가 시작될 수 있는 위치를 미리 검색한다는 것입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_98GwGRIMj8" href="#c_98GwGRIMj8" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">global</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">global</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyz abc&quot;</span>));
<span class="cm-comment">// → [&quot;abc&quot;]</span>
<span class="cm-keyword">let</span> <span class="cm-def">sticky</span> <span class="cm-operator">=</span> <span class="cm-string-2">/abc/y</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sticky</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;xyz abc&quot;</span>));
<span class="cm-comment">// → null</span></pre>

<p><a class="p_ident" id="p_042bNmzNZK" href="#p_042bNmzNZK" tabindex="-1" role="presentation"></a>여러 <code>exec</code> 호출에 대해 공유 정규식 값을 사용할 때 <code>lastIndex</code> 속성에 대한 이러한 자동 업데이트로 인해 문제가 발생할 수 있습니다. 정규식은 실수로 이전 호출에서 남겨진 인덱스에서 시작될 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wrx2wO0P8M" href="#c_wrx2wO0P8M" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">digit</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\d/g</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;here it is: 1&quot;</span>));
<span class="cm-comment">// → [&quot;1&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">digit</span>.<span class="cm-property">exec</span>(<span class="cm-string">&quot;and now: 1&quot;</span>));
<span class="cm-comment">// → null</span></pre>

<p><a class="p_ident" id="p_9l7tQ3SsME" href="#p_9l7tQ3SsME" tabindex="-1" role="presentation"></a>전역 옵션의 또 다른 흥미로운 효과는 문자열에 대한 <code>match</code> 메서드가 작동하는 방식을 변경한다는 것입니다. <code>exec</code>에 의해 반환되는 것과 유사한 배열을 반환하는 대신에 전역식으로 호출될 때 한 때 <code>match</code>는 문자열에서 모든 부합 패턴을 찾아 부합 문자열을 포함하는 배열을 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_weT/d5+8vE" href="#c_weT/d5+8vE" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Banana&quot;</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/an/g</span>));
<span class="cm-comment">// → [&quot;an&quot;, &quot;an&quot;]</span></pre>

<p><a class="p_ident" id="p_zFHO63a2iV" href="#p_zFHO63a2iV" tabindex="-1" role="presentation"></a>따라서 전역 정규 표현식에 주의하십시오. <code>replace</code>에 대한 호출과 <code>lastIndex</code>를 명시적으로 사용하고자 하는 위치는 일반적으로 사용하려는 유일한 위치입니다.</p>

<h3><a class="i_ident" id="i_m0fs21dHEg" href="#i_m0fs21dHEg" tabindex="-1" role="presentation"></a>부합을 통한 순회</h3>

<p><a class="p_ident" id="p_Rhy/hnaaT+" href="#p_Rhy/hnaaT+" tabindex="-1" role="presentation"></a>문자열과 관련하여 일반적으로 하는 일은 패턴의 모든 출현을 거맥하는 것인데 루프 몸체에서 부합 객체에 점근하는 방식이 사용됩니다. <code>lastIndex</code>와 <code>exec</code>를 사용하여 이를 수행할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rSzEnbVHja" href="#c_rSzEnbVHja" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;A string with 3 numbers in it... 42 and 88.&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/\b\d+\b/g</span>;
<span class="cm-keyword">let</span> <span class="cm-def">match</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">match</span> <span class="cm-operator">=</span> <span class="cm-variable">number</span>.<span class="cm-property">exec</span>(<span class="cm-variable">input</span>)) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Found&quot;</span>, <span class="cm-variable">match</span>[<span class="cm-number">0</span>], <span class="cm-string">&quot;at&quot;</span>, <span class="cm-variable">match</span>.<span class="cm-property">index</span>);
}
<span class="cm-comment">// → Found 3 at 14</span>
<span class="cm-comment">//   Found 42 at 33</span>
<span class="cm-comment">//   Found 88 at 40</span></pre>

<p><a class="p_ident" id="p_ZdCI2+edqA" href="#p_ZdCI2+edqA" tabindex="-1" role="presentation"></a>이것은 배정 표현식(<code>=</code>)의 값이 할당된 값이라는 사실을 이용합니다. 따라서 <code>while</code> 문장에서 조건과 같은 <code>match = number.<wbr>exec(input)</code>을 사용하여 각 반복이 시작될 때 일치를 수행하고 결과를 바인딩에 저장하고 더 이상 일치하는 항목이 발견되지 않으면 반복을 중지합니다.</p>

<h2 id="ini"><a class="h_ident" id="h_RGsf6ah1EY" href="#h_RGsf6ah1EY" tabindex="-1" role="presentation"></a>INI 파일 해독</h2>

<p><a class="p_ident" id="p_JbrLORqV9r" href="#p_JbrLORqV9r" tabindex="-1" role="presentation"></a>마지막으로 정규 표현식이 필요한 문제를 살펴보겠습니다. 인터넷에서 적에 대한 정보를 자동으로 수집하는 프로그램을 작성한다고 상상해보십시오(여기서 실제로 프로그램을 작성하지 않고 구성 파일을 읽는 부분만 작성함). 구성 파일은 다음과 같습니다.</p>

<pre class="snippet cm-s-default" data-language="text/plain" ><a class="c_ident" id="c_RV3f5fiptq" href="#c_RV3f5fiptq" tabindex="-1" role="presentation"></a>searchengine=https://duckduckgo.com/?q=$1
spitefulness=9.7

; comments are preceded by a semicolon...
; each section concerns an individual enemy
[larry]
fullname=Larry Doe
type=kindergarten bully
website=http://www.geocities.com/CapeCanaveral/11451

[davaeorn]
fullname=Davaeorn
type=evil wizard
outputdir=/home/marijn/enemies/davaeorn</pre>

<p><a class="p_ident" id="p_OgIQS1TJxB" href="#p_OgIQS1TJxB" tabindex="-1" role="presentation"></a>이 형식에 대한 (일반적으로 <em>INI</em> 파일이라고 하는 널리 사용되는 형식) 정확한 규칙은 다음과 같습니다.</p>

<ul>

<li>

<p><a class="p_ident" id="p_jIewfc/40B" href="#p_jIewfc/40B" tabindex="-1" role="presentation"></a>빈 줄과 세미콜론으로 시작하는 줄은 무시됩니다.</p></li>

<li>

<p><a class="p_ident" id="p_O/dGCr+aR5" href="#p_O/dGCr+aR5" tabindex="-1" role="presentation"></a><code>[</code>와 <code>]</code>를 갖는 라인은 새로운 섹션을 시작합니다.</p></li>

<li>

<p><a class="p_ident" id="p_l2Yjl1fUVB" href="#p_l2Yjl1fUVB" tabindex="-1" role="presentation"></a>영숫자 식별자 뒤에 <code>=</code> 문자가 오는 라인은 현재 섹션에 설정을 추가합니다.</p></li>

<li>

<p><a class="p_ident" id="p_bCaQwCXJCi" href="#p_bCaQwCXJCi" tabindex="-1" role="presentation"></a>다른 것은 무효입니다.</p></li></ul>

<p><a class="p_ident" id="p_clbD+OAS4y" href="#p_clbD+OAS4y" tabindex="-1" role="presentation"></a>여기서 작업은 이와 같은 문자열을 첫 번째 섹션 헤더 이전에 작성된 설정에 대한 문자열을 보유하고 섹션에 대한 하위 객체를 보유하는 객체로 변환하는 것입니다. 이러한 하위 객체는 섹션의 설정을 보유합니다.</p>

<p><a class="p_ident" id="p_8U3vMRn7g4" href="#p_8U3vMRn7g4" tabindex="-1" role="presentation"></a>형식을 한 줄씩 처리해야 하므로 파일을 별도의 줄로 나누는 것이 좋습니다. 4장의 <code>split</code> 메서드를 참조합니다. 그러나 일부 운영 체제에서는 줄 바꿈 문자를 사용하는 것이 아니라 줄 바꿈(<code>&quot;\r\n&quot;</code>)이 오는 캐리지 리턴 문자를 사용합니다. 메서드가 인수로 <code>/\r?\n/</code>와 같은 정규식을 허용한다는 점을 감안할 때 두 줄 과 줄 사이를 모두 허용하는 <code>&quot;\n&quot;</code>과 <code>&quot;\r\n&quot;</code>의 방식으로 정규식을 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_neI86/XXg2" href="#c_neI86/XXg2" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">parseINI</span>(<span class="cm-def">string</span>) {
  <span class="cm-comment">// Start with an object to hold the top-level fields</span>
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">let</span> <span class="cm-def">section</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>;
  <span class="cm-variable-2">string</span>.<span class="cm-property">split</span>(<span class="cm-string-2">/\r?\n/</span>).<span class="cm-property">forEach</span>(<span class="cm-def">line</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">match</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^(\w+)=(.*)$/</span>)) {
      <span class="cm-variable-2">section</span>[<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">match</span>[<span class="cm-number">2</span>];
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>.<span class="cm-property">match</span>(<span class="cm-string-2">/^\[(.*)\]$/</span>)) {
      <span class="cm-variable-2">section</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>[<span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]] <span class="cm-operator">=</span> {};
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-string-2">/^\s*(;.*)?$/</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">line</span>)) {
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Line '&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">line</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;' is not valid.&quot;</span>);
    }
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parseINI</span>(<span class="cm-string-2">`</span>
<span class="cm-string-2">name=Vasilis</span>
<span class="cm-string-2">[address]</span>
<span class="cm-string-2">city=Tessaloniki`</span>));
<span class="cm-comment">// → {name: &quot;Vasilis&quot;, address: {city: &quot;Tessaloniki&quot;}}</span></pre>

<p><a class="p_ident" id="p_86q0K3iF4C" href="#p_86q0K3iF4C" tabindex="-1" role="presentation"></a>코드는 파일의 라인들에 관해 객체를 생성합니다. 맨 위에 있는 속성은 해당 개체에 직접 저장되는 반면 섹션에 있는 속성은 별도의 섹션 객체에 저장됩니다. <code>section</code> 바인딩은 객체의 바인딩 지점입니다.</p>

<p><a class="p_ident" id="p_ixTfvSC1VN" href="#p_ixTfvSC1VN" tabindex="-1" role="presentation"></a>중요한 라인에는 섹션 헤더 또는 속성 라인의 두 가지 종류가 있습니다. 라인이 일반 속성인 경우 현재 섹션에 저장됩니다. 섹션 헤더인 경우 새 섹션 객체가 생성되고 <code>section</code>이 이를 가리키도록 설정됩니다.</p>

<p><a class="p_ident" id="p_FPzqsloIkT" href="#p_FPzqsloIkT" tabindex="-1" role="presentation"></a>표현식이 일부가 아니라 전체 행과 일치하는지 확인하기 위해 <code>^</code>와 <code>$</code>를 반복적으로 사용하는 것에 유의 하십시오. 이를 제외하면 대부분은 작동하지만 일부 입력에 대해서는 이상하게 동작하는 코드가 생성되어 추적하기 어려운 버그가 될 수 있습니다.</p>

<p><a class="p_ident" id="p_ACT8bIScp+" href="#p_ACT8bIScp+" tabindex="-1" role="presentation"></a>패턴 <code>if (match = string.<wbr>match(.<wbr>.<wbr>.<wbr>))</code>은 <code>while</code>에 대한 조건으로 할당을 사용하는 트릭과 유사합니다. <code>match</code>에 대한 호출이 성공할지 확신할 수 없는 경우가 많으므로 이를 테스트하는 <code>if</code> 명령문 내에서만 결과 객체에 액세스할 수 있습니다. <code>else if</code> 형식 체인을 끊지 않기 위해 일치 결과를 바인딩에 할당하고 즉시 해당 할당을 <code>if</code> 명령문에 대한 테스트로 사용합니다.</p>

<p><a class="p_ident" id="p_mwlBKfUu5D" href="#p_mwlBKfUu5D" tabindex="-1" role="presentation"></a>행이 섹션 헤더 또는 속성이 아닌 경우 함수는 표현식을 사용하여 주석인지 빈 행인지 식 <code>/^\s*(;.*)?$/</code>을 사용하여 확인합니다. 괄호 사이의 부분은 주석과 일치하며 <code>?</code>는 공백만 포함된 행과도 일치하는지 확인합니다. 줄이 예상되는 형식과 일치하지 않으면 함수에서 예외가 발생합니다.</p>

<h2><a class="h_ident" id="h_+y54//b0l+" href="#h_+y54//b0l+" tabindex="-1" role="presentation"></a>국제 문자</h2>

<p><a class="p_ident" id="p_2zJ37rLrbl" href="#p_2zJ37rLrbl" tabindex="-1" role="presentation"></a>JavaScript의 초기 단순 구현과 이 단순한 접근 방식이 나중에 표준 동작으로 확정되었다는 사실 때문에 JavaScript의 정규식은 영어로 표시되지 않는 문자에 대해 다소 멍청합니다. 예를 들어, JavaScript의 정규 표현식에 관한 한 "단어 문자"는 라틴 알파벳(대문자 또는 소문자), 10진수 및 어떤 이유로 밑줄 문자의 26개 문자 중 하나일 뿐입니다. <em>é</em> 또는 <em>β</em>와 같은 것들은 확실한 단어의 문자이지만 <code>\w</code>에 부합하지 못합니다.</p>

<p><a class="p_ident" id="p_Ln5OarYp4l" href="#p_Ln5OarYp4l" tabindex="-1" role="presentation"></a>또 다른 문제는 기본적으로 정규식은 실제 문자가 아닌 5장에서 논의한 것처럼 코드 단위에서 작동한다는 것입니다. 이는 두 개의 코드 단위로 구성된 문자가 이상하게 동작함을 의미합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CfMTYxun8D" href="#c_CfMTYxun8D" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/🍎{3}/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;🍎🍎🍎&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/&lt;.&gt;/</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;&lt;🌹&gt;&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/&lt;.&gt;/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;&lt;🌹&gt;&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_j4Kcv6J/rF" href="#p_j4Kcv6J/rF" tabindex="-1" role="presentation"></a>문제는 첫 번째 라인의 🍎 가 두 개의 코드 단위로 처리되어 <code>{3}</code> 부분이 두 번째 줄에만 해당 부분이 적용된다는 점입니다. 마찬가지로, 점은 장미 이모티콘을 구성하는 두 개의 코드 단위가 아니라 단일 코드 단위와 일치합니다.</p>

<p><a class="p_ident" id="p_1OZOJ3sk/b" href="#p_1OZOJ3sk/b" tabindex="-1" role="presentation"></a>이러한 문자를 올바르게 처리하려면 정규 표현식에 <code>u</code>옵션(유니코드용)을 추가해야 합니다. 잘못된 동작은 불행히도 기본값으로 유지됩니다. 변경하면 이에 의존하는 기존 코드에 문제가 발생할 수 있기 때문입니다.</p>

<p><a class="p_ident" id="p_MmzTSqcyKg" href="#p_MmzTSqcyKg" tabindex="-1" role="presentation"></a>이것은 단지 표준화되었을 뿐이고, 작성 당시에는 아직 널리 지원되지 않지만, 유니코드 표준이 지정된 모든 문자와 일치하도록 정규식(유니코드 옵션을 활성화해야 함)에서 <code>\p</code>를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+jV1oln0sr" href="#c_+jV1oln0sr" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Script=Greek}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Script=Arabic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Alphabetic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;α&quot;</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">/\p{Alphabetic}/u</span>.<span class="cm-property">test</span>(<span class="cm-string">&quot;!&quot;</span>));
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_5NxQGhRrMq" href="#p_5NxQGhRrMq" tabindex="-1" role="presentation"></a>유니코드는 많은 유용한 속성을 정의하지만 필요한 속성을 찾는 것이 항상 쉬운 것은 아닙니다. <code>\p{Property=Value}</code> 표기법을 사용하여 해당 속성에 대해 지정된 값을 가진 모든 문자와 일치시킬 수 있습니다. <code>\p{Name}</code>에서와 같이 속성 이름이 생략된 경우 이름은 <code>Alphabetic</code> 또는 <code>Number</code>와 같은 이진 속성 범주로 간주됩니다.</p>

<h2 id="summary_regexp"><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_/hQX04GtpS" href="#p_/hQX04GtpS" tabindex="-1" role="presentation"></a>정규식은 문자열의 패턴을 나타내는 객체입니다. 그것들은 이러한 패턴을 표현하기 위해 자체 언어를 사용합니다.</p>

<table>

<tr><td><code>/abc/</code></td><td>일련의 문자</td>

</tr>

<tr><td><code>/[abc]/</code></td><td>문자 집합의 모든 문자</td>

</tr>

<tr><td><code>/[^abc]/</code></td><td>문자 집합에 없는 모든 문자</td>

</tr>

<tr><td><code>/[0-9]/</code></td><td>문자 범위의 모든 문자</td>

</tr>

<tr><td><code>/x+/</code></td><td>하나 이상의 패턴 <code>x</code>의 출현</td>

</tr>

<tr><td><code>/x+?/</code></td><td>하나이상 발생</td>

</tr>

<tr><td><code>/x*/</code></td><td>0개 이상 발생</td>

</tr>

<tr><td><code>/x?/</code></td><td>영 또는 하나 출현</td>

</tr>

<tr><td><code>/x{2,4}/</code></td><td>2~4회 출현</td>

</tr>

<tr><td><code>/(abc)/</code></td><td>그룹</td>

</tr>

<tr><td><code>/a|b|c/</code></td><td>여러 패턴 중의 하나</td>

</tr>

<tr><td><code>/\d/</code></td><td>모든 숫자 문자</td>

</tr>

<tr><td><code>/\w/</code></td><td>영숫자 문자("단어 문자")</td>

</tr>

<tr><td><code>/\s/</code></td><td>모든 공백 문자</td>

</tr>

<tr><td><code>/./</code></td><td>개행 문자를 제외한 모든 문자</td>

</tr>

<tr><td><code>/\b/</code></td><td>단어 경계</td>

</tr>

<tr><td><code>/^/</code></td><td>입력 시작</td>

</tr>

<tr><td><code>/$/</code></td><td>입력 끝</td>

</tr>

</table>

<p><a class="p_ident" id="p_AVY5pFcEyH" href="#p_AVY5pFcEyH" tabindex="-1" role="presentation"></a>정규식에는 주어진 문자열이 일치하는지 여부를 테스트 하는 메서드 <code>test</code>가 있습니다. 또한 일치하는 항목이 발견되면 일치하는 모든 그룹을 포함하는 배열을 반환하는 <code>exec</code> 메서드도 있습니다. 이러한 배열에는 일치가 시작된 위치를 나타내는 <code>index</code> 속성이 있습니다.</p>

<p><a class="p_ident" id="p_FoVJlvxp9q" href="#p_FoVJlvxp9q" tabindex="-1" role="presentation"></a>문자열에는 정규식과 일치시키는 <code>match</code> 메서드와 일치하는 시작 위치만 반환하여 검색하는 <code>search</code> 메서드가 있습니다. 그것들의 code>replace</code> 메서드는 패턴의 일치를 대체 문자열이나 함수로 대체할 수 있습니다.</p>

<p><a class="p_ident" id="p_APfM9C3A6j" href="#p_APfM9C3A6j" tabindex="-1" role="presentation"></a>정규식에는 닫는 슬래시 뒤에 쓰여지는 옵션이 있을 수 있습니다. <code>i</code> 옵션은 대소문자를 구분하지 않습니다. <code>g</code> 옵션은 표현식을 전역으로 만들고, 무엇보다도 <code>replace</code> 메서드가 첫 번째 인스턴스가 아닌 모든 인스턴스를 대체하도록 합니다. <code>y</code> 옵션을 사용하면 고정이 됩니다. 즉, 일치 항목을 찾을 때 미리 검색하지 않고 문자열의 일부를 건너뛰지 않습니다. <code>u</code> 옵션은 두 개의 코드 단위를 차지하는 문자 처리와 관련된 여러 문제를 수정하는 유니코드 모드를 설정합니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_vDM8PzwQWU" href="#i_vDM8PzwQWU" tabindex="-1" role="presentation"></a>Regexp golf</h3>

<p><a class="p_ident" id="p_1t8xXpFN7O" href="#p_1t8xXpFN7O" tabindex="-1" role="presentation"></a><em>Code golf</em>는 특정 프로그램을 최대한 적은 글자로 표현하려는 게임을 일컫는 용어이다. 유사하게, <em>regexp golf</em>는 주어진 패턴과 그 패턴 만을 일치시키기 위해 가능한 한 작은 정규 표현식을 작성하는 연습입니다.</p>

<p><a class="p_ident" id="p_VGCqgCur6C" href="#p_VGCqgCur6C" tabindex="-1" role="presentation"></a>다음 각 항목에 대해 정규식을 작성하여 주어진 하위 문자열이 문자열에서 발생하는지 여부를 테스트하십시오. 정규식은 설명된 하위 문자열 중 하나를 포함하는 문자열과만 일치해야 합니다. 명시적으로 언급되지 않는 한 단어 경계에 대해 걱정하지 마십시오. 표현식이 작동하면 더 작게 만들 수 있는지 확인하십시오.</p>

<ol>

<li>

<p><a class="p_ident" id="p_togdFO+/b9" href="#p_togdFO+/b9" tabindex="-1" role="presentation"></a><em>car</em> and <em>cat</em></p></li>

<li>

<p><a class="p_ident" id="p_2Q37Tsr9DS" href="#p_2Q37Tsr9DS" tabindex="-1" role="presentation"></a><em>pop</em> and <em>prop</em></p></li>

<li>

<p><a class="p_ident" id="p_2Ah4dFikw1" href="#p_2Ah4dFikw1" tabindex="-1" role="presentation"></a><em>ferret</em>, <em>ferry</em>, and <em>ferrari</em></p></li>

<li>

<p><a class="p_ident" id="p_ttiBCcePDl" href="#p_ttiBCcePDl" tabindex="-1" role="presentation"></a>Any word ending in <em>ious</em></p></li>

<li>

<p><a class="p_ident" id="p_XnqTy5SopM" href="#p_XnqTy5SopM" tabindex="-1" role="presentation"></a>A whitespace character followed by a period, comma, colon, or semicolon</p></li>

<li>

<p><a class="p_ident" id="p_Ku7hE3qqDn" href="#p_Ku7hE3qqDn" tabindex="-1" role="presentation"></a>A word longer than six letters</p></li>

<li>

<p><a class="p_ident" id="p_mFDWQqRtWe" href="#p_mFDWQqRtWe" tabindex="-1" role="presentation"></a>A word without the letter <em>e</em> (or <em>E</em>)</p></li>

</ol>

<p><a class="p_ident" id="p_Tzjl1Axr+h" href="#p_Tzjl1Axr+h" tabindex="-1" role="presentation"></a>몇 가지 테스트 문자열로 각 솔루션을 테스트합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bnGKrYkiZ9" href="#c_bnGKrYkiZ9" tabindex="-1" role="presentation"></a><span class="cm-comment">// Fill in the regular expressions</span>

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;my car&quot;</span>, <span class="cm-string">&quot;bad cats&quot;</span>],
       [<span class="cm-string">&quot;camper&quot;</span>, <span class="cm-string">&quot;high art&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;pop culture&quot;</span>, <span class="cm-string">&quot;mad props&quot;</span>],
       [<span class="cm-string">&quot;plop&quot;</span>, <span class="cm-string">&quot;prrrop&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;ferret&quot;</span>, <span class="cm-string">&quot;ferry&quot;</span>, <span class="cm-string">&quot;ferrari&quot;</span>],
       [<span class="cm-string">&quot;ferrum&quot;</span>, <span class="cm-string">&quot;transfer A&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;how delicious&quot;</span>, <span class="cm-string">&quot;spacious room&quot;</span>],
       [<span class="cm-string">&quot;ruinous&quot;</span>, <span class="cm-string">&quot;consciousness&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;bad punctuation .&quot;</span>],
       [<span class="cm-string">&quot;escape the period&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;Siebentausenddreihundertzweiundzwanzig&quot;</span>],
       [<span class="cm-string">&quot;no&quot;</span>, <span class="cm-string">&quot;three small words&quot;</span>]);

<span class="cm-variable">verify</span>(<span class="cm-string-2">/.../</span>,
       [<span class="cm-string">&quot;red platypus&quot;</span>, <span class="cm-string">&quot;wobbling nest&quot;</span>],
       [<span class="cm-string">&quot;earth bed&quot;</span>, <span class="cm-string">&quot;learning ape&quot;</span>, <span class="cm-string">&quot;BEET&quot;</span>]);


<span class="cm-keyword">function</span> <span class="cm-def">verify</span>(<span class="cm-def">regexp</span>, <span class="cm-def">yes</span>, <span class="cm-def">no</span>) {
  <span class="cm-comment">// Ignore unfinished exercises</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">source</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;...&quot;</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">yes</span>) <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failure to match '${</span><span class="cm-variable-2">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">no</span>) <span class="cm-keyword">if</span> (<span class="cm-variable-2">regexp</span>.<span class="cm-property">test</span>(<span class="cm-variable-2">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Unexpected match for '${</span><span class="cm-variable-2">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}</pre>

<h3><a class="i_ident" id="i_dTiEW14oG0" href="#i_dTiEW14oG0" tabindex="-1" role="presentation"></a>인용 스타일</h3>

<p><a class="p_ident" id="p_x7xoQ6mk60" href="#p_x7xoQ6mk60" tabindex="-1" role="presentation"></a>이야기를 작성하고 대화의 일부를 표시하기 위해 작은따옴표를 사용했다고 상상해 보십시오. 이제 <em>aren't</em>와 같이 수축에 사용된 작은 따옴표를 유지하면서 모든 대화 따옴표를 큰 따옴표로 바꾸고 싶습니다.</p>

<p><a class="p_ident" id="p_k3Y0NF9w4b" href="#p_k3Y0NF9w4b" tabindex="-1" role="presentation"></a>다음 두 종류의 인용 사용을 구별하는 패턴을 생각하고 적절한 대체를 수행하는 <code>replace</code> 메서드에 대한 호출을 작성하십시오.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_sPrcOR+s/4" href="#c_sPrcOR+s/4" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;'I'm the cook,' he said, 'it's my job.'&quot;</span>;
<span class="cm-comment">// Change this call.</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">text</span>.<span class="cm-property">replace</span>(<span class="cm-string-2">/A/g</span>, <span class="cm-string">&quot;B&quot;</span>));
<span class="cm-comment">// → &quot;I'm the cook,&quot; he said, &quot;it's my job.&quot;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_rNoBQVCfFp" href="#p_rNoBQVCfFp" tabindex="-1" role="presentation"></a>가장 확실한 해결책은 따옴표를 적어도 한 쪽의 비단어 문자로 바꾸는 것입니다(<code>/\W'|'\W/</code>와 같은). 그러나 줄의 시작과 끝도 고려해야 합니다.</p>

<p><a class="p_ident" id="p_1SUsrUgWek" href="#p_1SUsrUgWek" tabindex="-1" role="presentation"></a>또한 대체에 <code>\W</code> 패턴과 일치하는 문자가 포함되어 삭제되지 않도록 해야 합니다. 이것은 괄호로 묶고 대체 문자열(<code>$1</code>, <code>$2</code>)에 그룹을 포함하여 수행할 수 있습니다. 일치하지 않는 그룹은 아무것도 대체되지 않습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_izldJoT3uv" href="#i_izldJoT3uv" tabindex="-1" role="presentation"></a>넘버</h3>

<p><a class="p_ident" id="p_0OQXsuIIcQ" href="#p_0OQXsuIIcQ" tabindex="-1" role="presentation"></a>JavaScript 스타일의 숫자만 일치하는 표현식을 작성하십시오. 그것은 수 앞에 선택적 빼기 또는 더하기 부호, 소수 점, 그리고 지수 표기를 지원해야 합니다. 또한 점 앞이나 뒤에 숫자가 있을 필요는 없지만 숫자는 점만 사용할 수 없습니다. 즉, .5및 5.는 유효한 JavaScript 수이지만, 단일 점은 그렇지 않습니다 .</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_aHAzeMYYGe" href="#c_aHAzeMYYGe" tabindex="-1" role="presentation"></a><span class="cm-comment">// Fill in this regular expression.</span>
<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^...$/</span>;

<span class="cm-comment">// Tests:</span>
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> [<span class="cm-string">&quot;1&quot;</span>, <span class="cm-string">&quot;-1&quot;</span>, <span class="cm-string">&quot;+15&quot;</span>, <span class="cm-string">&quot;1.55&quot;</span>, <span class="cm-string">&quot;.5&quot;</span>, <span class="cm-string">&quot;5.&quot;</span>,
                 <span class="cm-string">&quot;1.3e2&quot;</span>, <span class="cm-string">&quot;1E-4&quot;</span>, <span class="cm-string">&quot;1e+12&quot;</span>]) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed to match '${</span><span class="cm-variable">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}
<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">str</span> <span class="cm-keyword">of</span> [<span class="cm-string">&quot;1a&quot;</span>, <span class="cm-string">&quot;+-1&quot;</span>, <span class="cm-string">&quot;1.2.3&quot;</span>, <span class="cm-string">&quot;1+1&quot;</span>, <span class="cm-string">&quot;1e4.5&quot;</span>,
                 <span class="cm-string">&quot;.5.&quot;</span>, <span class="cm-string">&quot;1f5&quot;</span>, <span class="cm-string">&quot;.&quot;</span>]) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">number</span>.<span class="cm-property">test</span>(<span class="cm-variable">str</span>)) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Incorrectly accepted '${</span><span class="cm-variable">str</span><span class="cm-string-2">}</span><span class="cm-string-2">'`</span>);
  }
}</pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_sWIFtGBNR7" href="#p_sWIFtGBNR7" tabindex="-1" role="presentation"></a>첫째, 마침표 앞의 백슬래시를 잊지 마십시오.</p>

<p><a class="p_ident" id="p_ShOca+aF11" href="#p_ShOca+aF11" tabindex="-1" role="presentation"></a>숫자 앞과 지수 앞의 선택적 기호를 일치시키는 것은 <code>[+\-]?</code> 또는 <code>(\+|-|)</code>를 사용하여 수행할 수 있습니다.</p>

<p><a class="p_ident" id="p_z9QJjd6IxQ" href="#p_z9QJjd6IxQ" tabindex="-1" role="presentation"></a>더 복잡한 부분은 <code>&quot;.&quot;</code>이 없이 모두 <code>&quot;5.&quot;</code>과 <code>&quot;.5&quot;</code>을 부합시키는 것입니다. 이를 위해 좋은 솔루션은 <code>|</code> 연산자를 사용하여 두 가지 경우를 분리하는 것입니다. 하나 이상의 숫자 뒤에 선택적으로 점과 0개 이상의 숫자 또는 점 다음에 하나 이상의 숫자가 옵니다.</p>

<p><a class="p_ident" id="p_WHNmLsGl4C" href="#p_WHNmLsGl4C" tabindex="-1" role="presentation"></a>마지막으로 <em>e</em>의 대소문자를 구분하지 않도록 하려면 정규식에 <code>i</code> 옵션을 추가 하거나 <code>[eE]</code>를 사용하는 것입니다.</p>

</div></div><nav><a href="08_error.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="10_modules.html" title="next chapter">▶</a></nav>
</article>