<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>프로젝트: 플랫폼 게임</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 16;var sandboxLoadFiles = ["code/chapter/16_game.js","code/levels.js"];</script></head>

<article>
<nav><a href="15_event.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="17_canvas.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>16장</span>프로젝트: 플랫폼 게임</h1>

<blockquote>

<p><a class="p_ident" id="p_kUA7+lr6ay" href="#p_kUA7+lr6ay" tabindex="-1" role="presentation"></a>모든 현실은 게임입니다.</p>

<footer>Iain Banks, <cite>게임 플레이어</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_16.jpg" alt="Picture of a game character jumping over lava"></figure>

<p><a class="p_ident" id="p_OqEjiDXza0" href="#p_OqEjiDXza0" tabindex="-1" role="presentation"></a>많은 아이들처럼 컴퓨터에 대한 초기 매혹의 대부분은 컴퓨터 게임과 관련이 있습니다. 자기가 조작할 수 있고 이야기(일종의)가 펼쳐지는 조그마한 시뮬레이션된 세계에 끌리게 됩니다. 더 많은 것은 그것들이 실제로 제공한 가능성 때문이라기보다 자신이 그 세계에 자기 상상을 투영한 방식 때문인 것 같습니다.</p>

<p><a class="p_ident" id="p_hkas9mExVc" href="#p_hkas9mExVc" tabindex="-1" role="presentation"></a>게임 프로그래밍 분야의 경력이 그리 바람직하지는 않습니다. 음악 산업과 마찬가지로 음악 산업에서 일하고 싶어하는 열정적인 젊은이들의 수와 그러한 사람들에 대한 실제 수요 사이의 불일치는 다소 건강하지 못한 환경을 만듭니다. 그러나 재미를 위해 게임을 작성하는 것은 재미있습니다.</p>

<p><a class="p_ident" id="p_U1BQ0KJdvV" href="#p_U1BQ0KJdvV" tabindex="-1" role="presentation"></a>이 페이지에서는 소규모 플랫폼 게임의 구현을 안내합니다. 플랫폼 게임(또는 "점프 앤 런" 게임)은 플레이어가 물체 위로 점프하면서 일반적으로 2차원이고 측면에서 볼 수 있는 세계를 통해 인물을 움직일 것으로 기대하는 게임입니다.</p>

<h2><a class="h_ident" id="h_lMtTRzata0" href="#h_lMtTRzata0" tabindex="-1" role="presentation"></a>게임</h2>

<p><a class="p_ident" id="p_C38xTPlNF8" href="#p_C38xTPlNF8" tabindex="-1" role="presentation"></a>여기에서 소개되는 게임은 Thomas Palf의 <a href="http://www.lessmilk.com/games/10">Dark Blue</a>를 기반으로 합니다. 재미있고 미니멀하며 너무 많은 코드 없이 구축할 수 있습니다.</p><figure><img src="img/darkblue.png" alt="The game Dark Blue"></figure>

<p><a class="p_ident" id="p_mIXBfsCnQQ" href="#p_mIXBfsCnQQ" tabindex="-1" role="presentation"></a>어두운 상자는 플레이어를 나타냅니다. 플레이어의 임무는 빨간색 상자(용암)를 피하면서 노란색 상자(동전)를 모으는 것입니다. 모든 코인이 수집되면 레벨이 완료됩니다.</p>

<p><a class="p_ident" id="p_Y1K6GO/tu5" href="#p_Y1K6GO/tu5" tabindex="-1" role="presentation"></a>플레이어는 왼쪽 및 오른쪽 화살표 키로 돌아다닐 수 있으며 위쪽 화살표로 점프할 수 있습니다. 점프는 이 게임 캐릭터의 특기입니다. 자기 높이의 몇 배에 달할 수 있으며 공중에서 방향을 바꿀 수 있습니다. 이것은 완전히 현실적이지 않을 수 있지만 플레이어가 화면 아바타를 직접 제어하는 느낌을 주는 데 도움이 됩니다.</p>

<p><a class="p_ident" id="p_or+OtPnSO1" href="#p_or+OtPnSO1" tabindex="-1" role="presentation"></a>이 게임은 그리드처럼 배치된 정적 배경과 그 배경에 오버레이된 움직이는 요소로 구성됩니다. 그리드의 각 필드는 비어 있거나 단색이거나 용암입니다. 움직이는 요소는 플레이어, 동전 및 특정 용암 조각입니다. 이러한 요소의 위치는 그리드에 제한되지 않습니다. 좌표가 분수일 수 있으므로 부드러운 동작이 가능합니다.</p>

<h2><a class="h_ident" id="h_hLFu/U4fE5" href="#h_hLFu/U4fE5" tabindex="-1" role="presentation"></a>기술</h2>

<p><a class="p_ident" id="p_w6B1L26QOc" href="#p_w6B1L26QOc" tabindex="-1" role="presentation"></a>브라우저 DOM을 사용하여 게임을 표시하고 주요 이벤트를 처리하여 사용자 입력을 읽습니다.</p>

<p><a class="p_ident" id="p_wha4Kv9EnE" href="#p_wha4Kv9EnE" tabindex="-1" role="presentation"></a>화면 및 키보드 관련 코드는 이 게임을 빌드하기 위해 수행해야 하는 작업의 작은 부분일 뿐입니다. 모든 것이 컬러 상자처럼 보이기 때문에 그리기가 복잡하지 않습니다. DOM 요소를 만들고 스타일을 사용하여 배경색, 크기 및 위치를 지정합니다.</p>

<p><a class="p_ident" id="p_iXpeeK1cBS" href="#p_iXpeeK1cBS" tabindex="-1" role="presentation"></a>배경은 변하지 않는 정사각형 그리드이기 때문에 테이블로 표현할 수 있습니다. 자유 이동 요소는 절대 위치 요소를 사용하여 오버레이할 수 있습니다.</p>

<p><a class="p_ident" id="p_uCQz+7JTon" href="#p_uCQz+7JTon" tabindex="-1" role="presentation"></a>그래픽을 애니메이션하고 눈에 띄는 지연 없이 사용자 입력에 응답해야 하는 게임 및 기타 프로그램에서는 효율성이 중요합니다. DOM이 원래 고성능 그래픽용으로 설계된 것은 아니지만 실제로는 예상보다 더 좋습니다. 14장에서 몇 가지 애니메이션을 나타냈습니다. 최신 컴퓨터에서는 최적화에 대해 크게 걱정하지 않아도 이와 같은 간단한 게임이 잘 수행됩니다.</p>

<p><a class="p_ident" id="p_fFvps6KPyM" href="#p_fFvps6KPyM" tabindex="-1" role="presentation"></a>다음 장에서 또 다른 브라우저 기술의 탐구로 <code>&lt;canvas&gt;</code>를 소개합니다. 그것은 모양과 픽셀의 측면보다는 DOM 요소에서 작업, 그래픽을 그릴 수있는 전통적인 방식을 제공합니다.</p>

<h2><a class="h_ident" id="h_7UfwmBGLOk" href="#h_7UfwmBGLOk" tabindex="-1" role="presentation"></a>레벨</h2>

<p><a class="p_ident" id="p_abOzbCGnYG" href="#p_abOzbCGnYG" tabindex="-1" role="presentation"></a>레벨을 지정하기 위해 인간이 읽을 수 있고 인간이 편집할 수 있는 방법을 원할 것입니다. 모든 것이 그리드에서 시작하는 것이 좋으므로 각 문자가 요소(배경 그리드의 일부 또는 움직이는 요소)를 나타내는 큰 문자열을 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_On1HrmEvoL" href="#p_On1HrmEvoL" tabindex="-1" role="presentation"></a>작은 레벨에 대한 계획은 다음과 같을 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_txvY7tsNJp" href="#c_txvY7tsNJp" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">simpleLevelPlan</span> <span class="cm-operator">=</span> <span class="cm-string-2">`</span>
<span class="cm-string-2">......................</span>
<span class="cm-string-2">..#................#..</span>
<span class="cm-string-2">..#..............=.#..</span>
<span class="cm-string-2">..#.........o.o....#..</span>
<span class="cm-string-2">..#.@......#####...#..</span>
<span class="cm-string-2">..#####............#..</span>
<span class="cm-string-2">......#++++++++++++#..</span>
<span class="cm-string-2">......##############..</span>
<span class="cm-string-2">......................`</span>;</pre>

<p><a class="p_ident" id="p_9xefWk13KJ" href="#p_9xefWk13KJ" tabindex="-1" role="presentation"></a>마침표는 공백, 해시(<code>#</code>) 문자는 벽, 더하기 기호는 lava입니다. 플레이어의 시작 위치는 기호(<code>@</code>)입니다. 모든 O 문자는 코인이며, 상단의 등호(<code>=</code>)는 수평으로 앞뒤로 움직이는 lava 블록입니다.</p>

<p><a class="p_ident" id="p_0EQudcPkjK" href="#p_0EQudcPkjK" tabindex="-1" role="presentation"></a>두 가지 종류의 움직이는 lava를 추가로 지원할 것입니다. 파이프 문자(<code>|</code>)는 수직으로 움직이는 덩어리를 만들고 떨어지는 lava를 나타냅니다. 수직으로 움직이는 lava는 앞뒤로 튀지 않고 아래로만 움직이며 바닥을 맞춥니다.</p>

<p><a class="p_ident" id="p_JSlRu3lL/0" href="#p_JSlRu3lL/0" tabindex="-1" role="presentation"></a>전체 게임은 플레이어가 완료해야 하는 여러 레벨로 구성됩니다. 모든 코인이 수집되면 레벨이 완료됩니다. 플레이어가 lava에 닿으면 현재 레벨이 시작 위치로 복원되고 플레이어는 다시 시도할 수 있습니다.</p>

<h2 id="level"><a class="h_ident" id="h_DeVC1tufta" href="#h_DeVC1tufta" tabindex="-1" role="presentation"></a>레벨 읽기</h2>

<p><a class="p_ident" id="p_YiuShyNEuf" href="#p_YiuShyNEuf" tabindex="-1" role="presentation"></a>다음 클래스는 레벨 객체를 저장합니다. 해당 인수는 수준을 정의하는 문자열이어야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ObYKMNTKci" href="#c_ObYKMNTKci" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Level</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">plan</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">rows</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>.<span class="cm-property">trim</span>().<span class="cm-property">split</span>(<span class="cm-string">&quot;\n&quot;</span>).<span class="cm-property">map</span>(<span class="cm-def">l</span> <span class="cm-operator">=&gt;</span> [<span class="cm-meta">...</span><span class="cm-variable-2">l</span>]);
    <span class="cm-keyword">this</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">rows</span>.<span class="cm-property">length</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">rows</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">startActors</span> <span class="cm-operator">=</span> [];

    <span class="cm-keyword">this</span>.<span class="cm-property">rows</span> <span class="cm-operator">=</span> <span class="cm-variable-2">rows</span>.<span class="cm-property">map</span>((<span class="cm-def">row</span>, <span class="cm-def">y</span>) <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">row</span>.<span class="cm-property">map</span>((<span class="cm-def">ch</span>, <span class="cm-def">x</span>) <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">let</span> <span class="cm-def">type</span> <span class="cm-operator">=</span> <span class="cm-variable">levelChars</span>[<span class="cm-variable-2">ch</span>];
        <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;string&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">type</span>;
        <span class="cm-keyword">this</span>.<span class="cm-property">startActors</span>.<span class="cm-property">push</span>(
          <span class="cm-variable-2">type</span>.<span class="cm-property">create</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>), <span class="cm-variable-2">ch</span>));
        <span class="cm-keyword">return</span> <span class="cm-string">&quot;empty&quot;</span>;
      });
    });
  }
}</pre>

<p><a class="p_ident" id="p_JIksXnWVuw" href="#p_JIksXnWVuw" tabindex="-1" role="presentation"></a><code>trim</code> 메서드는 계획 문자열의 시작과 끝에서 공백을 제거하는 데 사용됩니다. 이렇게 하면 예의 계획이 줄 바꿈으로 시작하여 모든 줄이 서로 바로 아래에 있도록 할 수 있습니다. 나머지 문자열은 개행 문자로 분할되고 각 행은 배열로 퍼져 문자 배열을 생성합니다.</p>

<p><a class="p_ident" id="p_LoAi+0JNfy" href="#p_LoAi+0JNfy" tabindex="-1" role="presentation"></a>이리하여 <code>rows</code>는 계획의 행들인 문자들의 배열을 포함합니다. 이것들로부터 레벨의 너비와 높이를 도출할 수 있습니다. 그러나 여전히 배경 그리드에서 움직이는 요소를 분리해야 합니다. 움직이는 요소를 <em>actors</em>라 부를 것입니다. 그것들은 객체의 배열에 저장될 것입니다. 배경은 <code>&quot;empty&quot;</code>, <code>&quot;wall&quot;</code> 또는 <code>&quot;lava&quot;</code>와 같은 필드 타입을 포함하는 문자열 배열의 배열입니다.</p>

<p><a class="p_ident" id="p_rJcldM+jM6" href="#p_rJcldM+jM6" tabindex="-1" role="presentation"></a>이러한 배열을 생성하기 위해 행을 매핑한 다음 내용을 매핑합니다. <code>map</code>은 주어진 문자의 x 및 y 좌표를 알려주는 매핑 함수에 두 번째 인수로 배열 인덱스를 전달 한다는 것을 기억하십시오. 게임의 위치는 왼쪽 상단이 0, 0이고 각 배경 사각형이 높이와 너비가 1단위인 좌표 쌍으로 저장됩니다.</p>

<p><a class="p_ident" id="p_MMksR1/9C2" href="#p_MMksR1/9C2" tabindex="-1" role="presentation"></a>계획의 문자를 해석하기 위해 <code>Level</code> 생성자는 배경 요소를 문자열에 매핑하고 액터 문자를 클래스에 매핑하는 <code>levelChars</code> 객체를 사용합니다. <code>type</code>이 액터 클래스일 때, 그것의 정적 <code>create</code> 매서드는 <code>startActors</code>에 추가되는 객체를 생성하는 데 사용되고, 매핑 함수는 현재 배경 사각형을 위해 <code>&quot;empty&quot;</code>를 반환합니다.</p>

<p><a class="p_ident" id="p_XPViP3s8zO" href="#p_XPViP3s8zO" tabindex="-1" role="presentation"></a>액터의 위치는 <code>Vec</code> 객체로 저장됩니다. 이것은 6장의 연습에서 볼 수 있듯이 <code>x</code> 및 <code>y</code> 속성이 있는 객체인 2차원 벡터입니다.</p>

<p><a class="p_ident" id="p_nuR5OrGgSy" href="#p_nuR5OrGgSy" tabindex="-1" role="presentation"></a>게임이 실행되면 액터는 다른 위치에 나타나거나 완전히 사라질 것입니다(코인을 수집할 때 처럼). <code>State</code> 클래스를 사용하여 실행 중인 게임의 상태를 추적합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8mXPZZkFTr" href="#c_8mXPZZkFTr" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">State</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">level</span>, <span class="cm-def">actors</span>, <span class="cm-def">status</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actors</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-variable-2">status</span>;
  }

  <span class="cm-keyword">static</span> <span class="cm-property">start</span>(<span class="cm-def">level</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">State</span>(<span class="cm-variable-2">level</span>, <span class="cm-variable-2">level</span>.<span class="cm-property">startActors</span>, <span class="cm-string">&quot;playing&quot;</span>);
  }

  <span class="cm-keyword">get</span> <span class="cm-property">player</span>() {
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">find</span>(<span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;player&quot;</span>);
  }
}</pre>

<p><a class="p_ident" id="p_ykNWl1yVwU" href="#p_ykNWl1yVwU" tabindex="-1" role="presentation"></a><code>status</code> 속성은 게임 종료 시에 <code>&quot;lost&quot;</code> 또는 <code>&quot;won&quot;</code>로 전환됩니다.</p>

<p><a class="p_ident" id="p_HXx6FQb6dD" href="#p_HXx6FQb6dD" tabindex="-1" role="presentation"></a>이것은 다시 영구적인 데이터 구조입니다. 게임 상태를 업데이트하면 새 상태가 생성되고 이전 상태는 그대로 유지됩니다.</p>

<h2><a class="h_ident" id="h_pw0251T7gn" href="#h_pw0251T7gn" tabindex="-1" role="presentation"></a>Actors</h2>

<p><a class="p_ident" id="p_JlMpFXE8o0" href="#p_JlMpFXE8o0" tabindex="-1" role="presentation"></a>Actor 객체는 게임에서 주어진 움직이는 요소의 현재 위치와 상태를 나타냅니다. 모든 액터 객체는 동일한 인터페이스를 따릅니다. 그것들의 <code>pos</code> 속성은 요소의 왼쪽 상단 모서리의 좌표를 보유하고, 그것들의 <code>size</code> 속성은 크기를 보유하고 있습니다.</p>

<p><a class="p_ident" id="p_zAiZFPI5Yc" href="#p_zAiZFPI5Yc" tabindex="-1" role="presentation"></a>그런 다음 그것들은 <code>update</code> 메서드를 가지게 되는데, 그것은 주어진 시간 단계 후에 새로운 상태와 위치를 계산하는 데 사용됩니다. 액터가 하는 일을 (플레이어의 화살표 키에 반응하여 움직이고 용암에 대해 앞뒤로 튀는) 시뮬레이션하고 업데이트된 새 액터 객체를 반환합니다.</p>

<p><a class="p_ident" id="p_yHrnzwQ8R4" href="#p_yHrnzwQ8R4" tabindex="-1" role="presentation"></a><code>type</code> 속성은 actor—<code>&quot;player&quot;</code>, <code>&quot;coin&quot;</code> 또는 <code>&quot;lava&quot;</code>의 타입을 식별하는 문자열을 포함합니다. 이것은 게임을 묘사할 때 유용합니다. 액터에 대해 그려진 사각형의 모양은 해당 타입을 기반으로 합니다.</p>

<p><a class="p_ident" id="p_vyajSMujgl" href="#p_vyajSMujgl" tabindex="-1" role="presentation"></a>Actor 클래스에는 <code>Level</code> 생성자가 레벨 계획의 캐릭터에서 액터를 생성하는데 사용하는 정적 <code>create</code> 메서드가 있습니다. <code>Lava</code> 클래스가 여러 다른 문자를 처리 하기 때문에 필요한 문자 및 문자 자체의 좌표가 제공됩니다.</p>

<p id="vector"><a class="p_ident" id="p_lWgsae+2Q1" href="#p_lWgsae+2Q1" tabindex="-1" role="presentation"></a>다음은 액터의 위치와 크기와 같은 2차원 값에 사용할 <code>Vec</code> 클래스입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Hb9lakixOM" href="#c_Hb9lakixOM" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Vec</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span>; <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">y</span>;
  }
  <span class="cm-property">plus</span>(<span class="cm-def">other</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">x</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">y</span>);
  }
  <span class="cm-property">times</span>(<span class="cm-def">factor</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>);
  }
}</pre>

<p><a class="p_ident" id="p_gWWk7Ulj1q" href="#p_gWWk7Ulj1q" tabindex="-1" role="presentation"></a><code>times</code> 메서드는 주어진 숫자만큼 벡터의 크기를 조정합니다. 속도 벡터에 시간 간격을 곱하여 해당 시간 동안 이동한 거리를 구해야 할 때 유용합니다.</p>

<p><a class="p_ident" id="p_AGmjtw30RN" href="#p_AGmjtw30RN" tabindex="-1" role="presentation"></a>다른 타입의 액터는 행동이 매우 다르기 때문에 고유한 클래스를 얻습니다. 이러한 클래스를 정의합니다. 추후에 그것들의 <code>update</code> 메서드를 보게 될 것입니다.</p>

<p><a class="p_ident" id="p_qFX0r+uydc" href="#p_qFX0r+uydc" tabindex="-1" role="presentation"></a>플레이어 클래스에는 운동량과 중력을 시뮬레이션하기 위해 현재 속도를 저장하는 <code>speed</code> 속성이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+Zda+gD/W/" href="#c_+Zda+gD/W/" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Player</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">pos</span>, <span class="cm-def">speed</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-variable-2">speed</span>;
  }

  <span class="cm-keyword">get</span> <span class="cm-property">type</span>() { <span class="cm-keyword">return</span> <span class="cm-string">&quot;player&quot;</span>; }

  <span class="cm-keyword">static</span> <span class="cm-property">create</span>(<span class="cm-def">pos</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Player</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">0.5</span>)),
                      <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>));
  }
}

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0.8</span>, <span class="cm-number">1.5</span>);</pre>

<p><a class="p_ident" id="p_pJwDuA/gUR" href="#p_pJwDuA/gUR" tabindex="-1" role="presentation"></a>플레이어는 1.5 사각형 높이이기 때문에 초기 위치는 <code>@</code> 캐릭터가 나타난 위치보다 1/2 사각형으로 설정됩니다. 이런 식으로 바닥이 그것이 나타난 사각형의 바닥과 정렬됩니다.</p>

<p><a class="p_ident" id="p_X3b7n+ph7P" href="#p_X3b7n+ph7P" tabindex="-1" role="presentation"></a><code>size</code> 속성은 <code>Player</code>의 모든 인스턴스들과 같기 때문에 인스턴스 자체가 아닌 prototype에 저장합니다. <code>type</code>과 같은 getter를 사용할 수 있지만, 그것은 속성이 읽혀질 때마다 새로운 <code>Vec</code> 객체를 반환합니다. 따라서 낭비적인 것이 됩니다(문자열은 변경될 수 없기 때문에 평가할 때마다 다시 만들 필요가 없음).</p>

<p><a class="p_ident" id="p_CZIhBrKg4H" href="#p_CZIhBrKg4H" tabindex="-1" role="presentation"></a><code>Lava</code> 액터를 구성할 때 기반이 되는 캐릭터에 따라 객체를 다르게 초기화해야 합니다. 동적 lava은 장애물에 부딪힐 때까지 현재 속도로 이동합니다. 그 시점에서 <code>reset</code> 속성이 있으면 시작 위치로 다시 점프합니다(dripping). 그렇지 않으면 속도를 반전하고 다른 방향으로 계속 진행합니다(bouncing).</p>

<p><a class="p_ident" id="p_0NJ2jc8Gmf" href="#p_0NJ2jc8Gmf" tabindex="-1" role="presentation"></a><code>create</code> 메서드는 <code>Level</code> 생성자가 전달하는 문자를 보고 적절한 lava 액터를 만듭니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_OquWedN4L5" href="#c_OquWedN4L5" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Lava</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">pos</span>, <span class="cm-def">speed</span>, <span class="cm-def">reset</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-variable-2">speed</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">reset</span> <span class="cm-operator">=</span> <span class="cm-variable-2">reset</span>;
  }

  <span class="cm-keyword">get</span> <span class="cm-property">type</span>() { <span class="cm-keyword">return</span> <span class="cm-string">&quot;lava&quot;</span>; }

  <span class="cm-keyword">static</span> <span class="cm-property">create</span>(<span class="cm-def">pos</span>, <span class="cm-def">ch</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;=&quot;</span>) {
      <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">2</span>, <span class="cm-number">0</span>));
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;|&quot;</span>) {
      <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-number">2</span>));
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;v&quot;</span>) {
      <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-number">3</span>), <span class="cm-variable-2">pos</span>);
    }
  }
}

<span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">1</span>, <span class="cm-number">1</span>);</pre>

<p><a class="p_ident" id="p_fqdOUTLAz4" href="#p_fqdOUTLAz4" tabindex="-1" role="presentation"></a><code>Coin</code> 배우들은 비교적 단순합니다. 그것들은 대부분 제자리에 앉아 있습니다. 그러나 게임을 조금 더 활기차게 하기 위해 약간의 수직 전후 움직임인 wobble이 제공됩니다. 이를 추적하기 위해 코인 객체는 기본 위치와 튀는 동작의 위상을 추적하는 <code>wobble</code> 속성을 저장합니다. 이것들은 코인의 실제 위치(<code>pos</code> 속성에 저장)를 결정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_f2L1vFl5w5" href="#c_f2L1vFl5w5" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Coin</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">pos</span>, <span class="cm-def">basePos</span>, <span class="cm-def">wobble</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">basePos</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">=</span> <span class="cm-variable-2">wobble</span>;
  }

  <span class="cm-keyword">get</span> <span class="cm-property">type</span>() { <span class="cm-keyword">return</span> <span class="cm-string">&quot;coin&quot;</span>; }

  <span class="cm-keyword">static</span> <span class="cm-property">create</span>(<span class="cm-def">pos</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">basePos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0.2</span>, <span class="cm-number">0.1</span>));
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Coin</span>(<span class="cm-variable-2">basePos</span>, <span class="cm-variable-2">basePos</span>,
                    <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>);
  }
}

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0.6</span>, <span class="cm-number">0.6</span>);</pre>

<p><a class="p_ident" id="p_C16pTz7oRy" href="#p_C16pTz7oRy" tabindex="-1" role="presentation"></a><a href="14_dom.html#sin_cos">14장</a>에 소개된 <code>Math.sin</code>은 원 상의 점의 y-좌표를 제공합니다. 이 좌표는 원을 따라 이동할 때 부드러운 파형으로 앞뒤로 이동하므로 사인 수는 물결 모양의 동작을 모델링하는 데 유용합니다.</p>

<p><a class="p_ident" id="p_gQCua74XOk" href="#p_gQCua74XOk" tabindex="-1" role="presentation"></a>모든 코인이 동시에 위아래로 움직이는 상황을 피하기 위해 각 코인의 시작 단계는 무작위입니다. <code>Math.sin</code>의 파동 주기, 즉 파동이 생성하는 파동의 폭은 2π입니다. <code>Math.random</code>에 의해 반환된 값에 해당 숫자를 곱하여 동전에 웨이브의 임의 시작 위치를 제공합니다.</p>

<p><a class="p_ident" id="p_0wsl0zoIAL" href="#p_0wsl0zoIAL" tabindex="-1" role="presentation"></a>이제 계획 문자를 배경 그리드 타입 또는 액터 클래스에 매핑하는 <code>levelChars</code> 객체를 정의할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VxaicldIYi" href="#c_VxaicldIYi" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">levelChars</span> <span class="cm-operator">=</span> {
  <span class="cm-string cm-property">&quot;.&quot;</span>: <span class="cm-string">&quot;empty&quot;</span>, <span class="cm-string cm-property">&quot;#&quot;</span>: <span class="cm-string">&quot;wall&quot;</span>, <span class="cm-string cm-property">&quot;+&quot;</span>: <span class="cm-string">&quot;lava&quot;</span>,
  <span class="cm-string cm-property">&quot;@&quot;</span>: <span class="cm-variable">Player</span>, <span class="cm-string cm-property">&quot;o&quot;</span>: <span class="cm-variable">Coin</span>,
  <span class="cm-string cm-property">&quot;=&quot;</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">&quot;|&quot;</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">&quot;v&quot;</span>: <span class="cm-variable">Lava</span>
};</pre>

<p><a class="p_ident" id="p_DkV+hEDKE5" href="#p_DkV+hEDKE5" tabindex="-1" role="presentation"></a>그러면 <code>Level</code> 인스턴스를 만드는데 필요한 모든 부분이 제공됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CDJvcZL+0x" href="#c_CDJvcZL+0x" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">simpleLevel</span>.<span class="cm-property">width</span><span class="cm-string-2">}</span> <span class="cm-string-2">by ${</span><span class="cm-variable">simpleLevel</span>.<span class="cm-property">height</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
<span class="cm-comment">// → 22 by 9</span></pre>

<p><a class="p_ident" id="p_lCdOTin0mI" href="#p_lCdOTin0mI" tabindex="-1" role="presentation"></a>앞으로 해야 할 작업은 이러한 레벨을 화면에 표시하고 그 내부의 시간과 모션을 모델링하는 것입니다.</p>

<h2><a class="h_ident" id="h_uCRd57RG2L" href="#h_uCRd57RG2L" tabindex="-1" role="presentation"></a>캡슐화의 부담</h2>

<p><a class="p_ident" id="p_M65QHGE4qM" href="#p_M65QHGE4qM" tabindex="-1" role="presentation"></a>이 페이지의 대부분의 코드는 두 가지 이유로 캡슐화에 대해 크게 걱정하지 않습니다. 첫째, 캡슐화에는 추가 노력이 필요합니다. 그것은 프로그램을 더 크게 만들고 추가 개념과 인터페이스를 도입해야 합니다. 독자의 눈이 반짝거리기 전에 던질 수 있는 코드가 너무 많기 때문에 프로그램을 작게 유지하기 위해 노력했습니다.</p>

<p><a class="p_ident" id="p_21KwkzRO2L" href="#p_21KwkzRO2L" tabindex="-1" role="presentation"></a>둘째, 이 게임의 다양한 요소는 매우 밀접하게 연결되어 있어 그 중 하나의 행동이 변경되더라도 다른 요소가 그대로 유지될 가능성은 거의 없습니다. 요소 간의 인터페이스는 게임 작동 방식에 대한 많은 가정을 인코딩하게 됩니다. 이는 시스템의 한 부분을 변경할 때마다 다른 부분에 영향을 미치는 방식에 대해 여전히 걱정해야 합니다. 해당 인터페이스가 새로운 상황을 다루지 않기 때문입니다.</p>

<p><a class="p_ident" id="p_0qau17Yus5" href="#p_0qau17Yus5" tabindex="-1" role="presentation"></a>시스템의 일부 <em>cutting points</em>는 엄격한 인터페이스를 통해 분리하기에 적합하지만 다른 지점은 그렇지 않습니다. 적절한 경계가 아닌 것을 캡슐화하는 것은 많은 에너지를 낭비하는 확실한 방법입니다. 이 실수를 하면 일반적으로 인터페이스가 어색할 정도로 크고 상세해지고 있으며 프로그램이 발전함에 따라 자주 변경해야 한다는 것을 알게 될 것입니다.</p>

<p><a class="p_ident" id="p_zVT1v9P1c6" href="#p_zVT1v9P1c6" tabindex="-1" role="presentation"></a>캡슐화를 할 곳은 하위 그리기 시스템입니다. 그 이유는 동일한 게임을 다른 방식으로 표시할 수 있기 때문입니다(<a href="17_canvas.html#canvasdisplay">17장</a> 참조). 그리기 배후 인터페이스를 통해 거기에 동일한 게임 프로그램을 로드하고 새 디스플레이 모듈을 연결할 수 있습니다.</p>

<h2 id="domdisplay"><a class="h_ident" id="h_neNgUMdlHQ" href="#h_neNgUMdlHQ" tabindex="-1" role="presentation"></a>그리기</h2>

<p><a class="p_ident" id="p_bjlUPfTgQP" href="#p_bjlUPfTgQP" tabindex="-1" role="presentation"></a>그리기 코드의 캡슐화는 주어진 수준과 상태를 표시하는 <em>display</em> 객체를 정의하여 수행됩니다. 이 페이지에서 정의한 전시 타입은 DOM 요소를 사용하여 수준을 표시하기 때문에 <code>DOMDisplay</code>를 호출합니다.</p>

<p><a class="p_ident" id="p_8XJ1fe7OPg" href="#p_8XJ1fe7OPg" tabindex="-1" role="presentation"></a>스타일 시트를 사용하여 게임을 구성하는 요소의 실제 색상 및 기타 고정 속성을 설정합니다. 요소의 스타일을 생성할 때 요소의 <code>style</code> 속성에 직접 할당하는 것도 가능 하지만 더 자세한 프로그램을 생성합니다.</p>

<p><a class="p_ident" id="p_nm5ENHsGf9" href="#p_nm5ENHsGf9" tabindex="-1" role="presentation"></a>다음 도우미 함수는 요소를 만들고 일부 속성과 자식 노드를 제공하는 간결한 방법을 제공합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IslrNCPEgI" href="#c_IslrNCPEgI" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">attrs</span>, <span class="cm-meta">...</span><span class="cm-def">children</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">attr</span> <span class="cm-keyword">of</span> <span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable-2">attrs</span>)) {
    <span class="cm-variable-2">dom</span>.<span class="cm-property">setAttribute</span>(<span class="cm-variable-2">attr</span>, <span class="cm-variable-2">attrs</span>[<span class="cm-variable-2">attr</span>]);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">child</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">children</span>) {
    <span class="cm-variable-2">dom</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">dom</span>;
}</pre>

<p><a class="p_ident" id="p_Xjpq/reXQf" href="#p_Xjpq/reXQf" tabindex="-1" role="presentation"></a>디스플레이는 자신을 추가해야 하는 부모 요소와 레벨 객체를 제공하여 생성됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YPdTKEt761" href="#c_YPdTKEt761" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">DOMDisplay</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;div&quot;</span>, {<span class="cm-property">class</span>: <span class="cm-string">&quot;game&quot;</span>}, <span class="cm-variable">drawGrid</span>(<span class="cm-variable-2">level</span>));
    <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
    <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">dom</span>);
  }

  <span class="cm-property">clear</span>() { <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">remove</span>(); }
}</pre>

<p><a class="p_ident" id="p_mbvJm4+nKS" href="#p_mbvJm4+nKS" tabindex="-1" role="presentation"></a>절대 변경되지 않는 레벨의 배경 그리드는 한 번 그려집니다. 액터는 디스플레이가 주어진 상태로 업데이트될 때마다 다시 그려집니다. <code>actorLayer</code> 속성은 쉽게 제거되고 교체될 수 있도록 배우 보유 요소를 추적하는데 사용됩니다.</p>

<p><a class="p_ident" id="p_si3+n3Lijy" href="#p_si3+n3Lijy" tabindex="-1" role="presentation"></a>좌표와 크기는 격자 단위로 추적되며 크기 또는 거리가 1이면 하나의 격자 블록을 의미합니다. 픽셀 크기를 설정할 때 이러한 좌표를 확장해야 합니다. 게임의 모든 것이 정사각형당 단일 픽셀로 엄청나게 작아집니다. <code>scale</code> 상수는 하나의 단위 화면에 차지하는 화소 수를 나타냅니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_LrmszCVXMZ" href="#c_LrmszCVXMZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">scale</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;

<span class="cm-keyword">function</span> <span class="cm-def">drawGrid</span>(<span class="cm-def">level</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;table&quot;</span>, {
    <span class="cm-property">class</span>: <span class="cm-string">&quot;background&quot;</span>,
    <span class="cm-property">style</span>: <span class="cm-string-2">`width: ${</span><span class="cm-variable-2">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>
  }, <span class="cm-meta">...</span><span class="cm-variable-2">level</span>.<span class="cm-property">rows</span>.<span class="cm-property">map</span>(<span class="cm-def">row</span> <span class="cm-operator">=&gt;</span>
    <span class="cm-variable">elt</span>(<span class="cm-string">&quot;tr&quot;</span>, {<span class="cm-property">style</span>: <span class="cm-string-2">`height: ${</span><span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>},
        <span class="cm-meta">...</span><span class="cm-variable-2">row</span>.<span class="cm-property">map</span>(<span class="cm-def">type</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;td&quot;</span>, {<span class="cm-property">class</span>: <span class="cm-variable-2">type</span>})))
  ));
}</pre>

<p><a class="p_ident" id="p_cGH93DulN/" href="#p_cGH93DulN/" tabindex="-1" role="presentation"></a>배경은 <code>&lt;table&gt;</code> 요소로 그립니다. 이것은 레벨의 <code>rows</code> 속성 구조와 잘 일치합니다. 그리드의 각 행은 테이블 행(<code>&lt;tr&gt;</code> 요소)으로 바뀝니다. 그리드의 문자열은 테이블 셀(<code>&lt;td&gt;</code>) 요소의 클래스 이름으로 사용됩니다. 확산(삼중점) 연산자는 자식 노드의 배열을 별도의 인수로 <code>elt</code>에 전달하는데 사용됩니다.</p>

<p id="game_css"><a class="p_ident" id="p_rtSatvHAOz" href="#p_rtSatvHAOz" tabindex="-1" role="presentation"></a>다음 CSS는 테이블을 원하는 배경처럼 보이게 합니다.</p>

<pre class="snippet cm-s-default" data-language="text/css" ><a class="c_ident" id="c_wOP5LzF6Sp" href="#c_wOP5LzF6Sp" tabindex="-1" role="presentation"></a><span class="cm-qualifier">.background</span>    { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">52</span>, <span class="cm-number">166</span>, <span class="cm-number">251</span>);
                 <span class="cm-property">table-layout</span>: <span class="cm-atom">fixed</span>;
                 <span class="cm-property">border-spacing</span>: <span class="cm-number">0</span>;              }
<span class="cm-qualifier">.background</span> <span class="cm-tag">td</span> { <span class="cm-property">padding</span>: <span class="cm-number">0</span>;                     }
<span class="cm-qualifier">.lava</span>          { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">255</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>); }
<span class="cm-qualifier">.wall</span>          { <span class="cm-property">background</span>: <span class="cm-keyword">white</span>;              }</pre>

<p><a class="p_ident" id="p_Fm4CLmRVL5" href="#p_Fm4CLmRVL5" tabindex="-1" role="presentation"></a>이들 중 일부는 (<code>table-layout</code>, <code>border-spacing</code> 및 <code>padding</code>) 원치 않는 기본 동작을 억제하는 데 사용됩니다. 테이블의 레이아웃이 셀의 내용에 의존하는 것을 원하지 않으며 테이블 셀 사이의 공간이나 내부의 패딩을 원하지 않습니다.</p>

<p><a class="p_ident" id="p_SjTsFY8eD3" href="#p_SjTsFY8eD3" tabindex="-1" role="presentation"></a><code>background</code> 규칙은 배경 색상을 설정합니다. CSS에서는 색상을 단어(<code>white</code>)로 지정하거나 <code>rgb(R, G, B)</code>와 같은 형식으로 색상을 지정할 수 있습니다. 여기서 색상의 빨강, 녹색 및 파랑 구성 요소는 0에서 255까지의 세 숫자로 구분됩니다. 따라서 <code>rgb(52, 166, 251)</code>에서 빨간색 구성 요소는 52, 녹색은 166이고 파란색은 251입니다. 파란색 구성 요소가 가장 크기 때문에 결과 색상은 파란색이 됩니다. <code>.lava</code> 규칙에서 첫 번째 숫자(빨간색)이 가장 큽니다.</p>

<p><a class="p_ident" id="p_EGE24ax3xh" href="#p_EGE24ax3xh" tabindex="-1" role="presentation"></a>각 액터에 대한 DOM 요소를 만들고 액터의 속성에 따라 해당 요소의 위치와 크기를 설정하여 액터를 그립니다. 게임 단위에서 픽셀로 이동하려면 값을 <code>scale</code>로 곱해야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SJNWL3kOZh" href="#c_SJNWL3kOZh" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">drawActors</span>(<span class="cm-def">actors</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;div&quot;</span>, {}, <span class="cm-meta">...</span><span class="cm-variable-2">actors</span>.<span class="cm-property">map</span>(<span class="cm-def">actor</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;div&quot;</span>, {<span class="cm-property">class</span>: <span class="cm-string-2">`actor ${</span><span class="cm-variable-2">actor</span>.<span class="cm-property">type</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>});
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span><span class="cm-string-2">}</span><span class="cm-string-2">px`</span>;
    <span class="cm-keyword">return</span> <span class="cm-variable-2">rect</span>;
  }));
}</pre>

<p><a class="p_ident" id="p_mTuOphlRZ6" href="#p_mTuOphlRZ6" tabindex="-1" role="presentation"></a>요소에 하나이상의 클래스를 지정하려면 클래스 이름을 공백으로 구분합니다. 다음에 표시된 CSS 코드에서 <code>actor</code> 클래스는 액터에게 절대 위치를 제공합니다. 타입 이름은 색상을 지정하기 위한 추가 클래스로 사용됩니다. 앞서 정의한 lava 격자 사각형에 대해 클래스를 재사용하고 있기 때문에 <code>lava</code> 클래스를 다시 정의할 필요가 없습니다.</p>

<pre class="snippet cm-s-default" data-language="text/css" ><a class="c_ident" id="c_ksr13Gc65g" href="#c_ksr13Gc65g" tabindex="-1" role="presentation"></a><span class="cm-qualifier">.actor</span>  { <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;            }
<span class="cm-qualifier">.coin</span>   { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">241</span>, <span class="cm-number">229</span>, <span class="cm-number">89</span>); }
<span class="cm-qualifier">.player</span> { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">64</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);   }</pre>

<p><a class="p_ident" id="p_4qUaGsKUgq" href="#p_4qUaGsKUgq" tabindex="-1" role="presentation"></a><code>syncState</code> 메서드는 디스플레이가 주어진 상태를 표시하도록 하는 데 사용됩니다. 먼저 이전 액터 그래픽(있는 경우)을 제거한 다음 새 위치에 액터를 다시 그립니다. 액터에 대해 DOM 요소를 재사용하려고 시도하고 싶을 수도 있지만, 그렇게 하려면 액터를 DOM 요소와 연결하고 액터가 사라질 때 요소를 제거하기 위해 많은 추가 부기가 필요합니다. 일반적으로 게임에는 소수의 액터만 있으므로 모든 액터를 다시 그리는 데 시간이 많이 소요되지 않습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/bAFVECbGl" href="#c_/bAFVECbGl" tabindex="-1" role="presentation"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">syncState</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">state</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>) <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>.<span class="cm-property">remove</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-variable">drawActors</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">actors</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string-2">`game ${</span><span class="cm-variable-2">state</span>.<span class="cm-property">status</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">scrollPlayerIntoView</span>(<span class="cm-variable-2">state</span>);
};</pre>

<p><a class="p_ident" id="p_sZEoSNaFbo" href="#p_sZEoSNaFbo" tabindex="-1" role="presentation"></a>레벨의 현재 상태를 클래스 이름으로 래퍼에 추가함으로써 플레이어가 주어진 클래스의 조상 요소를 가질 때만 적용되는 CSS 규칙을 추가하여 게임이 이기거나 졌을 때 플레이어 액터의 스타일을 약간 다르게 지정할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/css" ><a class="c_ident" id="c_6QpUiIcdtL" href="#c_6QpUiIcdtL" tabindex="-1" role="presentation"></a><span class="cm-qualifier">.lost</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">160</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);
}
<span class="cm-qualifier">.won</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">box-shadow</span>: <span class="cm-number">-4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>, <span class="cm-number">4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>;
}</pre>

<p><a class="p_ident" id="p_RiEBu6FHP5" href="#p_RiEBu6FHP5" tabindex="-1" role="presentation"></a>lava를 터치한 후에 플레이어의 색이 검붉은 색으로 변하여 타오르는 듯한 느낌을 줍니다. 마지막 코인이 수집되면 두 개의 흐릿한 흰색 그림자를 추가합니다. 하나는 왼쪽 상단에, 하나는 오른쪽 상단에 추가하여 흰색 후광 효과를 만듭니다.</p>

<p id="viewport"><a class="p_ident" id="p_3Lai0THCj4" href="#p_3Lai0THCj4" tabindex="-1" role="presentation"></a>레벨이 항상 <em>viewport</em>에 적합한 것으로 가정할 수 없습니다. 그것이 <code>scrollPlayerIntoView</code> 호출이 필요한 이유입니다. 레벨이 뷰포트 외부로 튀어나온 경우 해당 뷰포트를 스크롤 하여 플레이어가 중심 근처에 있는지 확인합니다. 다음 CSS는 게임의 래핑 DOM 요소에 최대 크기를 제공하고 요소 상자에서 튀어나온 것이 보이지 않도록 합니다. 또한 내부의 액터가 레벨의 왼쪽 상단 모서리에 상대적으로 배치되도록 상대적인 위치를 지정합니다.</p>

<pre class="snippet cm-s-default" data-language="text/css" ><a class="c_ident" id="c_cxq+gtsZuW" href="#c_cxq+gtsZuW" tabindex="-1" role="presentation"></a><span class="cm-qualifier">.game</span> {
  <span class="cm-property">overflow</span>: <span class="cm-atom">hidden</span>;
  <span class="cm-property">max-width</span>: <span class="cm-number">600px</span>;
  <span class="cm-property">max-height</span>: <span class="cm-number">450px</span>;
  <span class="cm-property">position</span>: <span class="cm-atom">relative</span>;
}</pre>

<p><a class="p_ident" id="p_IgYwZuZ1Co" href="#p_IgYwZuZ1Co" tabindex="-1" role="presentation"></a><code>scrollPlayerIntoView</code> 메서드에서 플레이어 위치를 찾아 래핑 요소의 스크롤 위치를 갱신합니다. 플레이어가 에지에 근접해 있을 때 요소의 <code>scrollLeft</code> 및 <code>scrollTop</code> 속성들을 처리하여 스크롤 위치를 변경합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Of96qEfT96" href="#c_Of96qEfT96" tabindex="-1" role="presentation"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">scrollPlayerIntoView</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">state</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">clientWidth</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">clientHeight</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;

  <span class="cm-comment">// The viewport</span>
  <span class="cm-keyword">let</span> <span class="cm-def">left</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollLeft</span>, <span class="cm-def">right</span> <span class="cm-operator">=</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">top</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollTop</span>, <span class="cm-def">bottom</span> <span class="cm-operator">=</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">height</span>;

  <span class="cm-keyword">let</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>))
                         .<span class="cm-property">times</span>(<span class="cm-variable">scale</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">right</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">width</span>;
  }
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">bottom</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">height</span>;
  }
};</pre>

<p><a class="p_ident" id="p_3qHzB4KoD+" href="#p_3qHzB4KoD+" tabindex="-1" role="presentation"></a>플레이어의 중심을 찾는 방식은 <code>Vec</code> 타입의 메서드가 객체를 사용한 계산이 상대적으로 읽기 쉬운 방식으로 작성되도록 하는 것을 나타내 줍니다. 액터의 중심을 찾기 위해 위치(왼쪽 상단 모서리)와 크기의 절반을 추가합니다. 그것이 레벨 좌표의 중심이지만 픽셀 좌표가 필요하므로 결과 벡터에 디스플레이 스케일을 곱합니다.</p>

<p><a class="p_ident" id="p_nyYhuiyn32" href="#p_nyYhuiyn32" tabindex="-1" role="presentation"></a>다음으로, 일련의 검사를 통해 플레이어 위치가 허용 범위를 벗어나지 않았는지 확인합니다. 때때로 이것은 0보다 작거나 요소의 스크롤 가능 영역을 넘어서는 넌센스 스크롤 좌표를 설정합니다. 이것은 괜찮습니다. DOM은 허용 가능한 값으로 제한합니다. code>scrollLeft</code>를 -10으로 설정하면 0이 됩니다.</p>

<p><a class="p_ident" id="p_MFibm1pU7d" href="#p_MFibm1pU7d" tabindex="-1" role="presentation"></a>항상 플레이어를 뷰포트 중앙으로 스크롤하려고 하는 것이 약간 더 간단했을 것입니다. 그러나 이것은 다소 거슬리는 효과를 낳습니다. 점프하는 동안 뷰는 계속해서 위아래로 이동합니다. 스크롤을 일으키지 않고 이동할 수 있는 중립 영역이 화면 중앙에 있는 것이 더 바람직합니다.</p>

<p><a class="p_ident" id="p_LSD2j1d23Y" href="#p_LSD2j1d23Y" tabindex="-1" role="presentation"></a>이제 미세헌 레벨을 전시할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_LDPexlnWt1" href="#c_LDPexlnWt1" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">&quot;stylesheet&quot;</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;css/game.css&quot;</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable">simpleLevel</span>);
  <span class="cm-variable">display</span>.<span class="cm-property">syncState</span>(<span class="cm-variable">State</span>.<span class="cm-property">start</span>(<span class="cm-variable">simpleLevel</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_WeN+Ro9UkI" href="#p_WeN+Ro9UkI" tabindex="-1" role="presentation"></a><code>&lt;link&gt;</code> 태그는 CSS 파일을 페이지에 로드 시키는 방식입니다(<code>rel=&quot;stylesheet&quot;</code>와 함께 사용될 때). 파일 <code>game.css</code>는 게임에 필요한 스타일을 포함합니다.</p>

<h2><a class="h_ident" id="h_zX4xC7JBQU" href="#h_zX4xC7JBQU" tabindex="-1" role="presentation"></a>움직임과 충돌</h2>

<p><a class="p_ident" id="p_Ans+nACOmo" href="#p_Ans+nACOmo" tabindex="-1" role="presentation"></a>이제 게임에서 가장 흥미로운 부분인 모션을 추가할 수 있는 시점에 도달했습니다. 이와 같은 대부분의 게임에서 취하는 기본 접근 방식은 시간을 작은 단계로 나누고 각 단계에 대해 시간 단계의 크기를 곱한 속도에 해당하는 거리만큼 액터를 이동하는 것입니다. 시간을 초 단위로 측정하므로 속도는 초당 단위로 표시됩니다.</p>

<p><a class="p_ident" id="p_AMJvAGiWYs" href="#p_AMJvAGiWYs" tabindex="-1" role="presentation"></a>사물을 움직이는 것은 것은 쉽습니다. 어려운 부분은 요소 간의 상호 작용을 처리하는 것입니다. 플레이어가 벽이나 바닥에 부딪쳤을 때 단순히 벽이나 바닥을 통과해서는 안 됩니다. 게임은 주어진 동작으로 인해 물체가 다른 물체에 부딪힐 때 이를 인지하고 그에 따라 반응해야 합니다. 벽의 경우 모션을 중지해야 합니다. 동전을 칠 때 수집해야 합니다. lava를 만지면 게임에서 져야합니다.</p>

<p><a class="p_ident" id="p_0knqUiUFMu" href="#p_0knqUiUFMu" tabindex="-1" role="presentation"></a>일반적인 경우에 이를 해결하는 것은 큰 작업입니다. 2차원 또는 3차원에서 물리적 객체 간의 상호 작용을 시뮬레이션하는 일반적으로 물리 엔진이라고 하는 라이브러리를 찾을 수 있습니다. 이 페이지에서는 직사각형 객체 간의 충돌만 처리하고 다소 단순한 방식으로 처리하는 좀 더 간단한 접근 방식을 취할 것입니다.</p>

<p><a class="p_ident" id="p_siPXpdT6C4" href="#p_siPXpdT6C4" tabindex="-1" role="presentation"></a>플레이어나 용암 블록을 이동하기 전에 모션이 벽 내부로 이동하는지 테스트합니다. 그렇다면 단순히 모션을 완전히 취소합니다. 이러한 충돌에 대한 반응은 액터 유형에 따라 다릅니다. 플레이어는 멈추고 용암 블록은 다시 튕깁니다.</p>

<p><a class="p_ident" id="p_SnXtyooCGY" href="#p_SnXtyooCGY" tabindex="-1" role="presentation"></a>이 접근 방식은 물체가 실제로 닿기 전에 모션이 멈추게 하므로 시간 간격이 다소 작아야 합니다. 시간 단계(따라서 모션 단계)가 너무 크면 플레이어는 지면에서 눈에 띄는 거리를 떠 있게 됩니다. 틀림없이 더 좋지만 더 복잡한 또 다른 접근 방식은 정확한 충돌 지점을 찾아 그곳으로 이동하는 것입니다. 간단한 접근 방식을 취하고 애니메이션이 작은 단계로 진행되도록 하여 문제를 숨길 것입니다.</p>

<p id="touches"><a class="p_ident" id="p_3qnJ7o6jgV" href="#p_3qnJ7o6jgV" tabindex="-1" role="presentation"></a>다음 메서드는 직사각형(위치 및 크기로 지정됨)이 주어진 타입의 그리드 요소에 닿는지 여부를 알려줍니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_L9DHo/CdJs" href="#c_L9DHo/CdJs" tabindex="-1" role="presentation"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">touches</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">pos</span>, <span class="cm-def">size</span>, <span class="cm-def">type</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">y</span>);

  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">let</span> <span class="cm-def">isOutside</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">x</span> <span class="cm-operator">&gt;=</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">|</span><span class="cm-operator">|</span>
                      <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">y</span> <span class="cm-operator">&gt;=</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>;
      <span class="cm-keyword">let</span> <span class="cm-def">here</span> <span class="cm-operator">=</span> <span class="cm-variable-2">isOutside</span> <span class="cm-operator">?</span> <span class="cm-string">&quot;wall&quot;</span> : <span class="cm-keyword">this</span>.<span class="cm-property">rows</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">here</span> <span class="cm-operator">==</span> <span class="cm-variable-2">type</span>) <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
};</pre>

<p><a class="p_ident" id="p_4FaUFI2Ppt" href="#p_4FaUFI2Ppt" tabindex="-1" role="presentation"></a>메서드는 좌표에서 <code>Math.floor</code>와 <code>Math.ceil</code>를 사용하여 몸체가 겹치는 격자 사각형 집합을 계산합니다. 격자 사각형의 크기는 1 x 1 단위임을 기억하십시오. 상자의 측면을 위아래로 반올림하여 상자가 닿는 배경 사각형의 범위를 얻습니다.</p><figure><img src="img/game-grid.svg" alt="Finding collisions on a grid"></figure>

<p><a class="p_ident" id="p_y0L2VEuDgy" href="#p_y0L2VEuDgy" tabindex="-1" role="presentation"></a>좌표를 반올림하여 찾은 격자 사각형 블록을 반복하고 일치하는 사각형이 발견되면 <code>true</code>를 반환합니다. 레벨 외부의 사각형은 항상 플레이어가 세계를 떠날 수 없도록 <code>&quot;wall&quot;</code>로 처리하고 실수로 <code>rows</code> 배열의 경계 외부에서 읽으려고 시도하지 않도록 처리됩니다.</p>

<p><a class="p_ident" id="p_VPBaabj50T" href="#p_VPBaabj50T" tabindex="-1" role="presentation"></a>상태 <code>update</code> 메서드는 플레이어가 lava를 건드리는지 확인하기 위해 <code>touches</code>를 사용합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_af6Xo1AsIn" href="#c_af6Xo1AsIn" tabindex="-1" role="presentation"></a><span class="cm-variable">State</span>.<span class="cm-property">prototype</span>.<span class="cm-property">update</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">time</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">actors</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>
    .<span class="cm-property">map</span>(<span class="cm-def">actor</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">update</span>(<span class="cm-variable-2">time</span>, <span class="cm-keyword">this</span>, <span class="cm-variable-2">keys</span>));
  <span class="cm-keyword">let</span> <span class="cm-def">newState</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">State</span>(<span class="cm-keyword">this</span>.<span class="cm-property">level</span>, <span class="cm-variable-2">actors</span>, <span class="cm-keyword">this</span>.<span class="cm-property">status</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">newState</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;playing&quot;</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">newState</span>;

  <span class="cm-keyword">let</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newState</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">touches</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>, <span class="cm-variable-2">player</span>.<span class="cm-property">size</span>, <span class="cm-string">&quot;lava&quot;</span>)) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">State</span>(<span class="cm-keyword">this</span>.<span class="cm-property">level</span>, <span class="cm-variable-2">actors</span>, <span class="cm-string">&quot;lost&quot;</span>);
  }

  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">actor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">actors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">actor</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">player</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable">overlap</span>(<span class="cm-variable-2">actor</span>, <span class="cm-variable-2">player</span>)) {
      <span class="cm-variable-2">newState</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">collide</span>(<span class="cm-variable-2">newState</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">newState</span>;
};</pre>

<p><a class="p_ident" id="p_i/qab4417U" href="#p_i/qab4417U" tabindex="-1" role="presentation"></a>메서드는 어떤 키가 누르고 있는지 알려주는 시간 단계와 데이터 구조를 전달합니다. 가장 먼저 하는 일은 모든 액터에서 <code>update</code> 메서드를 호출하여 업데이트된 액터 배열을 생성하는 것입니다. 액터는 또한 시간 단계, 키 및 상태를 가져와 업데이트를 기반으로 할 수 있습니다. 플레이어만 실제로 키를 읽을 것입니다. 키보드로 제어되는 유일한 액터이기 때문입니다.</p>

<p><a class="p_ident" id="p_CTpNIbtVGd" href="#p_CTpNIbtVGd" tabindex="-1" role="presentation"></a>게임이 이미 종료된 경우 더 이상의 처리가 필요하지 않습니다(게임에서 지면 승리할 수 없으며 그 반대의 경우도 마찬가지입니다). 그렇지 않으면 이 메서드는 플레이어가 배경 용암을 만지고 있는지 여부를 테스트합니다. 그렇다면 게임은 지고 끝났습니다. 마지막으로, 게임이 실제로 계속 진행 중이라면 다른 액터가 플레이어와 겹치는지 여부를 확인합니다.</p>

<p><a class="p_ident" id="p_JshvA9JB7k" href="#p_JshvA9JB7k" tabindex="-1" role="presentation"></a>액터 간의 겹침은 <code>overlap</code> 함수로 감지됩니다. 두 개의 액터 객체를 사용하고 터치하면 true를 반환합니다. 이는 x축과 y축을 따라 겹치는 경우입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Z19icVgfA7" href="#c_Z19icVgfA7" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">overlap</span>(<span class="cm-def">actor1</span>, <span class="cm-def">actor2</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">actor1</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor1</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
         <span class="cm-variable-2">actor1</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
         <span class="cm-variable-2">actor1</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor1</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
         <span class="cm-variable-2">actor1</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor2</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span>;
}</pre>

<p><a class="p_ident" id="p_EMdttGHwtg" href="#p_EMdttGHwtg" tabindex="-1" role="presentation"></a>액터가 겹치는 경우 해당 <code>collide</code> 메서드는 상태를 업데이트할 기회를 얻습니다. lava 배우를 터치하면 게임 상태가 <code>&quot;lost&quot;</code>로 설정됩니다. 터치하면 코인이 사라지고 레벨의 마지막 코인일 때 상태를 <code>&quot;won&quot;</code>로 설정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_jNqQLSOJRn" href="#c_jNqQLSOJRn" tabindex="-1" role="presentation"></a><span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">collide</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">state</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">State</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">level</span>, <span class="cm-variable-2">state</span>.<span class="cm-property">actors</span>, <span class="cm-string">&quot;lost&quot;</span>);
};

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">collide</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">state</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">filtered</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">!=</span> <span class="cm-keyword">this</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">status</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">status</span>;
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">filtered</span>.<span class="cm-property">some</span>(<span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;coin&quot;</span>)) <span class="cm-variable-2">status</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;won&quot;</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">State</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">level</span>, <span class="cm-variable-2">filtered</span>, <span class="cm-variable-2">status</span>);
};</pre>

<h2 id="actors"><a class="h_ident" id="h_GaxRpVIsuF" href="#h_GaxRpVIsuF" tabindex="-1" role="presentation"></a>Actor 갱신</h2>

<p><a class="p_ident" id="p_fbEQ61HTVq" href="#p_fbEQ61HTVq" tabindex="-1" role="presentation"></a>Actor 객체의 <code>update</code> 메서드는 인수로 시간 단계, 상태 객체 및 <code>keys</code> 객체를 취합니다. <code>Lava</code> 액터 타입의 경우에 <code>keys</code> 객체는 무시합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vuIaAGYDTl" href="#c_vuIaAGYDTl" tabindex="-1" role="presentation"></a><span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">update</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">time</span>, <span class="cm-def">state</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-variable-2">time</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">state</span>.<span class="cm-property">level</span>.<span class="cm-property">touches</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>, <span class="cm-string">&quot;wall&quot;</span>)) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>, <span class="cm-keyword">this</span>.<span class="cm-property">reset</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">reset</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-keyword">this</span>.<span class="cm-property">reset</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>, <span class="cm-keyword">this</span>.<span class="cm-property">reset</span>);
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Lava</span>(<span class="cm-keyword">this</span>.<span class="cm-property">pos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
  }
};</pre>

<p><a class="p_ident" id="p_NnAl39AH58" href="#p_NnAl39AH58" tabindex="-1" role="presentation"></a><code>update</code> 메서드는 시간 단계와 현재 속도의 곱을 이전 위치에 추가하여 새 위치를 계산합니다. 장애물이 새 위치를 막지 않으면 해당 위치로 이동합니다. 장애물이 있는 경우 동작은 용암 블록의 유형에 따라 다릅니다. 떨어지는 용암은 무언가에 부딪힐 때 뒤로 점프 하는 <code>reset</code> 위치가 있습니다. 튀는 용암은 반대 방향으로 움직이기 시작하도록 -1을 곱하여 속도를 반전시킵니다.</p>

<p><a class="p_ident" id="p_AsHqJXqhZP" href="#p_AsHqJXqhZP" tabindex="-1" role="presentation"></a>코인들은 <code>update</code> 메서드를 사용하여 흔들거립니다. 그것들은 단순히 자체 사각형 내부에서 흔들리기 때문에 그리드와의 충돌을 무시합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+DC3G3xD19" href="#c_+DC3G3xD19" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">wobbleSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-def">wobbleDist</span> <span class="cm-operator">=</span> <span class="cm-number">0.07</span>;

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">update</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">time</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">wobble</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">+</span> <span class="cm-variable-2">time</span> <span class="cm-operator">*</span> <span class="cm-variable">wobbleSpeed</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">wobblePos</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable-2">wobble</span>) <span class="cm-operator">*</span> <span class="cm-variable">wobbleDist</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Coin</span>(<span class="cm-keyword">this</span>.<span class="cm-property">basePos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">wobblePos</span>)),
                  <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span>, <span class="cm-variable-2">wobble</span>);
};</pre>

<p><a class="p_ident" id="p_SYkdq1IZii" href="#p_SYkdq1IZii" tabindex="-1" role="presentation"></a>The <code>wobble</code> 속성은 시간을 추적과 관련하여 증분되고 <code>Math.sin</code>에 관한 인수로 사용되어 파의 새로운 위치를 찾을 수 있습니다. 그런 다음 코인의 현재 위치는 기본 위치와 이러한 파를 기반으로 하는 옵셋에서 계산됩니다.</p>

<p><a class="p_ident" id="p_SuUDJCzjex" href="#p_SuUDJCzjex" tabindex="-1" role="presentation"></a>플레이어의 움직임은 바닥에 닿아도 수평 움직임을 방해하지 않아야 하고, 벽에 부딪혀도 넘어지거나 점프하는 움직임이 멈추지 않아야 하기 때문에 축별로 별도로 처리됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_cBJRAPnr2+" href="#c_cBJRAPnr2+" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">playerXSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">7</span>;
<span class="cm-keyword">const</span> <span class="cm-def">gravity</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
<span class="cm-keyword">const</span> <span class="cm-def">jumpSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">17</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">update</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">time</span>, <span class="cm-def">state</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">xSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">ArrowLeft</span>) <span class="cm-variable-2">xSpeed</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXSpeed</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">ArrowRight</span>) <span class="cm-variable-2">xSpeed</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXSpeed</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">movedX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-variable-2">xSpeed</span> <span class="cm-operator">*</span> <span class="cm-variable-2">time</span>, <span class="cm-number">0</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">state</span>.<span class="cm-property">level</span>.<span class="cm-property">touches</span>(<span class="cm-variable-2">movedX</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>, <span class="cm-string">&quot;wall&quot;</span>)) {
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">movedX</span>;
  }

  <span class="cm-keyword">let</span> <span class="cm-def">ySpeed</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">time</span> <span class="cm-operator">*</span> <span class="cm-variable">gravity</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">movedY</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">ySpeed</span> <span class="cm-operator">*</span> <span class="cm-variable-2">time</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">state</span>.<span class="cm-property">level</span>.<span class="cm-property">touches</span>(<span class="cm-variable-2">movedY</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>, <span class="cm-string">&quot;wall&quot;</span>)) {
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">movedY</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">ArrowUp</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">ySpeed</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-variable-2">ySpeed</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable">jumpSpeed</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-variable-2">ySpeed</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Player</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-variable-2">xSpeed</span>, <span class="cm-variable-2">ySpeed</span>));
};</pre>

<p><a class="p_ident" id="p_rmP4WNaYTL" href="#p_rmP4WNaYTL" tabindex="-1" role="presentation"></a>수평 모션은 왼쪽 및 오른쪽 화살표 키의 상태를 기반으로 계산됩니다. 이 동작에 의해 생성된 새로운 위치를 막는 벽이 없을 때 사용됩니다. 그렇지 않으면 이전 위치가 유지됩니다.</p>

<p><a class="p_ident" id="p_BP0T8XR1kg" href="#p_BP0T8XR1kg" tabindex="-1" role="presentation"></a>수직 모션은 비슷한 방식으로 작동하지만 점프와 중력을 시뮬레이션 해야 합니다. 플레이어의 수직 속도(<code>ySpeed</code>)는 먼저 중력을 고려하여 가속됩니다.</p>

<p><a class="p_ident" id="p_3H8Calt+MC" href="#p_3H8Calt+MC" tabindex="-1" role="presentation"></a>다시 벽을 확인합니다. 아무 것도 치지 않으면 새 위치가 사용됩니다. 벽이 있는 경우 두 가지 결과가 있습니다. 위쪽 화살표를 누르면 아래로 이동하고, 속도가 상대적으로 큰 음의 값으로 설정됩니다. 이로 인해 플레이어가 점프합니다. 그렇지 않은 경우 플레이어는 단순히 무언가에 부딪히고 속도는 0으로 설정됩니다.</p>

<p><a class="p_ident" id="p_HeVD7be3z6" href="#p_HeVD7be3z6" tabindex="-1" role="presentation"></a>중력 강도, 점프 속도 및 이 게임의 다른 모든 상수는 시행착오를 거쳐 설정되었습니다. 마음에 드는 조합을 찾을 때까지 값을 테스트 합니다.</p>

<h2><a class="h_ident" id="h_zKch6Si/SS" href="#h_zKch6Si/SS" tabindex="-1" role="presentation"></a>추적 키</h2>

<p><a class="p_ident" id="p_NBxmiqrPk8" href="#p_NBxmiqrPk8" tabindex="-1" role="presentation"></a>이와 같은 게임의 경우 키를 누를 때마다 키가 한 번만 적용되는 것을 원하지 않습니다. 오히려, 그 효과가 유지되는 동안 작동 상태를 유지하기를 원합니다.</p>

<p><a class="p_ident" id="p_AHo2Emv/R2" href="#p_AHo2Emv/R2" tabindex="-1" role="presentation"></a>왼쪽, 오른쪽, 위쪽 화살표 키의 현재 상태를 저장하는 키 처리기를 설정해야 합니다. 또한 페이지 스크롤을 끝내지 않도록 해당 키 관련 <code>preventDefault</code>를 호출해야 합니다.</p>

<p><a class="p_ident" id="p_oH4kiTyM1E" href="#p_oH4kiTyM1E" tabindex="-1" role="presentation"></a>다음 함수는 키 이름 배열이 주어지면 해당 키의 현재 위치를 추적하는 객체를 반환합니다. <code>&quot;keydown&quot;</code> 및 <code>&quot;keyup&quot;</code> 이벤트에 대한 이벤트 처리기를 등록하고 이벤트의 키 코드가 추적 중인 코드 집합에 있는 경우 객체를 업데이트합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HHYPd26+il" href="#c_HHYPd26+il" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">trackKeys</span>(<span class="cm-def">keys</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">down</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">track</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">key</span>)) {
      <span class="cm-variable-2">down</span>[<span class="cm-variable-2">event</span>.<span class="cm-property">key</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;keydown&quot;</span>;
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  }
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;keydown&quot;</span>, <span class="cm-variable-2">track</span>);
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;keyup&quot;</span>, <span class="cm-variable-2">track</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">down</span>;
}

<span class="cm-keyword">const</span> <span class="cm-def">arrowKeys</span> <span class="cm-operator">=</span>
  <span class="cm-variable">trackKeys</span>([<span class="cm-string">&quot;ArrowLeft&quot;</span>, <span class="cm-string">&quot;ArrowRight&quot;</span>, <span class="cm-string">&quot;ArrowUp&quot;</span>]);</pre>

<p><a class="p_ident" id="p_/Gh0/QdYTL" href="#p_/Gh0/QdYTL" tabindex="-1" role="presentation"></a>두 이벤트 타입 모두에 동일한 처리기 함수가 사용됩니다. 이벤트 객체의 <code>type</code> 속성을 보고 키 상태를 true(<code>&quot;keydown&quot;</code>)로 업데이트할지 아니면 false(<code>&quot;keyup&quot;</code>)로 업데이트할지 결정합니다.</p>

<h2 id="runAnimation"><a class="h_ident" id="h_/jwYTlYjAy" href="#h_/jwYTlYjAy" tabindex="-1" role="presentation"></a>게임 실행</h2>

<p><a class="p_ident" id="p_h0hF0+vYTt" href="#p_h0hF0+vYTt" tabindex="-1" role="presentation"></a><code>requestAnimationFrame</code> 함수는 게임을 애니메이션으로 만드는 좋은 방법을 제공합니다. 그러나 인터페이스는 매우 원시적입니다. 이를 사용하려면 함수가 마지막으로 호출된 시간을 추적하고 매 프레임마다 다시 <code>requestAnimationFrame</code>를 호출해야 합니다.</p>

<p><a class="p_ident" id="p_YcIf88ICqS" href="#p_YcIf88ICqS" tabindex="-1" role="presentation"></a>지루한 부분을 편리한 인터페이스로 감싸고 단순히 호출할 수 있는 도우미 함수를 정의하여 시차를 인수로 하고 단일 프레임을 그리는 함수 <code>runAnimation</code>를 제공합니다. 프레임 함수가 <code>false</code> 값을 반환하면 애니메이션이 중지됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AVT0noPnDW" href="#c_AVT0noPnDW" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">runAnimation</span>(<span class="cm-def">frameFunc</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) {
      <span class="cm-keyword">let</span> <span class="cm-def">timeStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable-2">lastTime</span>, <span class="cm-number">100</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>;
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">frameFunc</span>(<span class="cm-variable-2">timeStep</span>) <span class="cm-operator">===</span> <span class="cm-atom">false</span>) <span class="cm-keyword">return</span>;
    }
    <span class="cm-variable-2">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
}</pre>

<p><a class="p_ident" id="p_2lfHQQNum5" href="#p_2lfHQQNum5" tabindex="-1" role="presentation"></a>여기서는 최대 프레임 단계를 100밀리초(1/10초)로 설정했습니다. 페이지가 있는 브라우저 탭 또는 창이 숨겨지면 해당 탭 또는 창이 다시 표시될 때까지 <code>requestAnimationFrame</code> 호출이 일시 중단됩니다. 이 경우의 <code>lastTime</code>과 <code>time</code> 간에 차이는 페이지가 숨겨져있는 전체 시간이 될 것입니다. 한 번에 게임을 그렇게 많이 진행하는 것은 바람직하지 않으며 플레이어가 바닥에 떨어지는 것과 같은 이상한 부작용을 일으킬 수 있습니다.</p>

<p><a class="p_ident" id="p_jKakPLUmwL" href="#p_jKakPLUmwL" tabindex="-1" role="presentation"></a>또한 함수는 시구간을 밀리초보다 고려하기 쉬운 초로 변환합니다.</p>

<p><a class="p_ident" id="p_kwKnkc4FM+" href="#p_kwKnkc4FM+" tabindex="-1" role="presentation"></a><code>runLevel</code> 함수는 <code>Level</code> 객체와 display 생성자를 취하고 promise를 반환합니다. 그것은 레벨을 전시하고(<code>document.body</code>에서) 사용자가 그것을 통해 게임을 진행하도록 합니다. 레벨이 종료될 때(lost 또는 won), <code>runLevel</code>은 1초 이상 대기한 다음에(사용자가 무슨 일이 일어났는지 볼 수 있도록) 디스플레이를 비우고 애니메이션을 중단하고 게임 상태 관련 promise를 해결합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HTrHnVaIWA" href="#c_HTrHnVaIWA" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">state</span> <span class="cm-operator">=</span> <span class="cm-variable">State</span>.<span class="cm-property">start</span>(<span class="cm-variable-2">level</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">ending</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">runAnimation</span>(<span class="cm-def">time</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-variable-2">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">update</span>(<span class="cm-variable-2">time</span>, <span class="cm-variable">arrowKeys</span>);
      <span class="cm-variable-2">display</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">state</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;playing&quot;</span>) {
        <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
      } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ending</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
        <span class="cm-variable-2">ending</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">time</span>;
        <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
      } <span class="cm-keyword">else</span> {
        <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
        <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">status</span>);
        <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
      }
    });
  });
}</pre>

<p><a class="p_ident" id="p_eyKzVe0sIB" href="#p_eyKzVe0sIB" tabindex="-1" role="presentation"></a>게임은 레벨의 연속입니다. 플레이어가 죽을 때마다 현재 레벨이 다시 시작됩니다. 레벨이 완료되면 다음 레벨로 이동합니다. 이것은 레벨 계획(문자열)의 배열과 표시 생성자를 취하는 다음 함수로 표현할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SyT3weqmk4" href="#c_SyT3weqmk4" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">level</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">level</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span>;) {
    <span class="cm-keyword">let</span> <span class="cm-def">status</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">level</span>]),
                                <span class="cm-variable-2">Display</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;won&quot;</span>) <span class="cm-variable-2">level</span><span class="cm-operator">++</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You've won!&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_ibGanBtTKe" href="#p_ibGanBtTKe" tabindex="-1" role="presentation"></a><code>runLevel</code>은 promise를 반환하기 때문에, <code>runGame</code>은 <code>async</code> 함수로 작성합니다. 그것은 또 다른 promise를 반환하는데 그것은 게임 종료 시에 해결됩니다.</p>

<p><a class="p_ident" id="p_/6dLhjN2fB" href="#p_/6dLhjN2fB" tabindex="-1" role="presentation"></a><code>GAME_LEVELS</code> 바인딩에서 이용 가능한 레벨 플랜 집합이 있습니다(이 페이지의 <a href="https://eloquentjavascript.net/code#16">sandbox</a>). 실제 게임을 시작하는 <code>runGame</code>에 그것들이 제공됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true" data-sandbox="null"><a class="c_ident" id="c_ftVm34P6My" href="#c_ftVm34P6My" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">&quot;stylesheet&quot;</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;css/game.css&quot;</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_MkrZ67rFcA" href="#p_MkrZ67rFcA" tabindex="-1" role="presentation"></a>이러한 것들을 만드는 것은 아주 재미있습니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_tFsh86eaJC" href="#i_tFsh86eaJC" tabindex="-1" role="presentation"></a>게임 끝</h3>

<p><a class="p_ident" id="p_Qg9LKDI5Td" href="#p_Qg9LKDI5Td" tabindex="-1" role="presentation"></a>플랫폼 게임에서는 플레이어가 제한된 수의 <em>생존</em>으로 시작하여 죽을 때마다 하나의 생존을 제거하도록 하는 것이 일반적입니다. 플레이어가 수명을 다하면 게임이 처음부터 다시 시작됩니다.</p>

<p><a class="p_ident" id="p_cg64RJFkZh" href="#p_cg64RJFkZh" tabindex="-1" role="presentation"></a><code>runGame</code>을 수정하여 생존이 구현되도록 합니다. 게임자는 3으로 시작합니다. 레벨이 시작될 때마다 현재 생존 수를 출력합니다(<code>console.log</code> 사용).</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_/XVg6hHOl5" href="#c_/XVg6hHOl5" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">&quot;stylesheet&quot;</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;css/game.css&quot;</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runGame function. Modify it...</span>
  <span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">level</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">level</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span>;) {
      <span class="cm-keyword">let</span> <span class="cm-def">status</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">level</span>]),
                                  <span class="cm-variable-2">Display</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;won&quot;</span>) <span class="cm-variable-2">level</span><span class="cm-operator">++</span>;
    }
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You've won!&quot;</span>);
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h3><a class="i_ident" id="i_cNfzuXtVqI" href="#i_cNfzuXtVqI" tabindex="-1" role="presentation"></a>게임 중지</h3>

<p><a class="p_ident" id="p_a/Q1DcuFrC" href="#p_a/Q1DcuFrC" tabindex="-1" role="presentation"></a>Esc 키를 눌러 게임을 일시 중지하고 해제할 수 있습니다.</p>

<p><a class="p_ident" id="p_FpramcVlTZ" href="#p_FpramcVlTZ" tabindex="-1" role="presentation"></a>이것은 또 다른 키보드 이벤트 처리기를 사용하기 위해 <code>runLevel</code> 함수를 변경하는 방식으로 행해질 수 있습니다(Esc 키가 작동될 때마다 애니메이션을 중지 또는 재개되는 방식으로).</p>

<p><a class="p_ident" id="p_QBqhApUa2T" href="#p_QBqhApUa2T" tabindex="-1" role="presentation"></a><code>runAnimation</code> 인터페이스는 처음에 적절하지 않는 것처럼 보이지만 <code>runLevel</code>의 호출 방식으로 재배열시키면 됩니다.</p>

<p><a class="p_ident" id="p_WJUxvtDgig" href="#p_WJUxvtDgig" tabindex="-1" role="presentation"></a>그러한 작업을 할 때, 시도할 수 있는 다른 것이 있습니다. 키보드 이벤트 처리기를 등록하는 방식은 다소 문제가 있습니다. <code>arrowKeys</code> 객체는 현재 전역적인 바인딩이며, 그 이벤트 처리기는 어떤 게임이 실행되지 않는 경우에도 주변에 보관됩니다. 시스템에서 유출되었다고 말할 수 있습니다. 처리기의 등록 취소하는 방식을 제공하도록 <code>trackKeys</code>를 확장한 다음 시작할 때 처리기를 등록하고 완료되면 다시 등록 취소하도록 <code>runLevel</code>을 변경합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_ybbf+T2p9b" href="#c_ybbf+T2p9b" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">&quot;stylesheet&quot;</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;css/game.css&quot;</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runLevel function. Modify this...</span>
  <span class="cm-keyword">function</span> <span class="cm-def">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">state</span> <span class="cm-operator">=</span> <span class="cm-variable">State</span>.<span class="cm-property">start</span>(<span class="cm-variable-2">level</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">ending</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-variable">runAnimation</span>(<span class="cm-def">time</span> <span class="cm-operator">=&gt;</span> {
        <span class="cm-variable-2">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">update</span>(<span class="cm-variable-2">time</span>, <span class="cm-variable">arrowKeys</span>);
        <span class="cm-variable-2">display</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>);
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">state</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;playing&quot;</span>) {
          <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
        } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ending</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
          <span class="cm-variable-2">ending</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">time</span>;
          <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
        } <span class="cm-keyword">else</span> {
          <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
          <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">status</span>);
          <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
        }
      });
    });
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_dyqugB1j6F" href="#p_dyqugB1j6F" tabindex="-1" role="presentation"></a><code>runAnimation</code>로 주어진 함수로부터 <code>false</code>를 반환하는 방식으로 애니메이션을 중단할 수 있습니다. <code>runAnimation</code>을 다시 호출하여 계속할 수 있습니다.</p>

<p><a class="p_ident" id="p_ymajy5Ud0Z" href="#p_ymajy5Ud0Z" tabindex="-1" role="presentation"></a>따라서 <code>runAnimation</code>로 주어진 함수에 게임을 일시 중지하고 있다는 사실을 전달해야 합니다. 이를 위해 이벤트 처리기와 해당 함수가 모두 액세스할 수 있는 바인딩을 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_adK1uPfN73" href="#p_adK1uPfN73" tabindex="-1" role="presentation"></a><code>trackKeys</code>에 의해 등록된 처리기가 등록을 취소할 수 있는 방법을 찾을 때 <code>addEventListener</code>에 전달된 <em>exact</em>와 같은 함수는 처리기를 성공적으로 제거하기 위해 <code>removeEventListener</code>에 전달되어야 합니다. 이리하여 <code>trackKeys</code>에서 생성된 <code>handler</code> 함수 값은 처리기를 등록 해제하는 코드에서 사용할 수 있어야 합니다.</p>

<p><a class="p_ident" id="p_n0zT7gRNWv" href="#p_n0zT7gRNWv" tabindex="-1" role="presentation"></a>해당 함수 값 또는 등록 취소를 직접 처리하는 메서드를 포함하는 <code>trackKeys</code>에서 반환된 객체에 속성을 추가할 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_tKK8cGG5os" href="#i_tKK8cGG5os" tabindex="-1" role="presentation"></a>monster</h3>

<p><a class="p_ident" id="p_RtEFEXlrkS" href="#p_RtEFEXlrkS" tabindex="-1" role="presentation"></a>플랫폼 게임의 경우에 위에서 점프하여 적을 격퇴시키는 방식이 사용됩니다. 이러한 액터 타입을 추가합니다.</p>

<p><a class="p_ident" id="p_Mhy2ENHlzV" href="#p_Mhy2ENHlzV" tabindex="-1" role="presentation"></a>이것을 몬스터라 하고, 몬스터는 수평으로만 움직입니다. 플레이어의 방향으로 움직이게 하거나 수평의 용암처럼 앞뒤로 튀게 하거나 원하는 움직임 패턴을 갖도록 할 수 있습니다. 클래스는 떨어지는 것을 처리할 필요가 없지만 몬스터가 벽을 통과하지 않도록 해야 합니다.</p>

<p><a class="p_ident" id="p_kN0Yd5LQRq" href="#p_kN0Yd5LQRq" tabindex="-1" role="presentation"></a>몬스터가 플레이어에 닿았을 때 플레이어가 몬스터 위로 점프하는지 여부에 따라 효과가 달라집니다. 플레이어의 바닥이 몬스터의 상단 근처에 있는지 확인하여 이를 근사화할 수 있습니다. 이 경우 몬스터는 사라집니다. 그렇지 않으면 게임에서 지게 됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_rthUoERAau" href="#c_rthUoERAau" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">&quot;stylesheet&quot;</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;css/game.css&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-qualifier">.monster</span> { <span class="cm-property">background</span>: <span class="cm-keyword">purple</span> }<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-comment">// Complete the constructor, update, and collide methods</span>
    <span class="cm-keyword">class</span> <span class="cm-def">Monster</span> {
      <span class="cm-property">constructor</span>(<span class="cm-def">pos</span>, <span class="cm-comment">/* ... */</span>) {}

      <span class="cm-keyword">get</span> <span class="cm-property">type</span>() { <span class="cm-keyword">return</span> <span class="cm-string">&quot;monster&quot;</span>; }

      <span class="cm-keyword">static</span> <span class="cm-property">create</span>(<span class="cm-def">pos</span>) {
        <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Monster</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>)));
      }

      <span class="cm-property">update</span>(<span class="cm-def">time</span>, <span class="cm-def">state</span>) {}

      <span class="cm-property">collide</span>(<span class="cm-def">state</span>) {}
    }

    <span class="cm-variable">Monster</span>.<span class="cm-property">prototype</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vec</span>(<span class="cm-number">1.2</span>, <span class="cm-number">2</span>);

    <span class="cm-variable">levelChars</span>[<span class="cm-string">&quot;M&quot;</span>] <span class="cm-operator">=</span> <span class="cm-variable">Monster</span>;

    <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-string-2">`</span>
<span class="cm-string-2">..................................</span>
<span class="cm-string-2">.################################.</span>
<span class="cm-string-2">.#..............................#.</span>
<span class="cm-string-2">.#..............................#.</span>
<span class="cm-string-2">.#..............................#.</span>
<span class="cm-string-2">.#...........................o..#.</span>
<span class="cm-string-2">.#..@...........................#.</span>
<span class="cm-string-2">.##########..............########.</span>
<span class="cm-string-2">..........#..o..o..o..o..#........</span>
<span class="cm-string-2">..........#...........M..#........</span>
<span class="cm-string-2">..........################........</span>
<span class="cm-string-2">..................................</span>
<span class="cm-string-2">`</span>), <span class="cm-variable">DOMDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_aiYWebohij" href="#p_aiYWebohij" tabindex="-1" role="presentation"></a>bouncing과 같은 상태 저장 모션 유형을 구현하려면 액터 객체에 필요한 상태를 저장해야 합니다. 이를 생성자 인수로 포함하고 속성으로 추가합니다.</p>

<p><a class="p_ident" id="p_bCqQqL9ccE" href="#p_bCqQqL9ccE" tabindex="-1" role="presentation"></a><code>update</code>는 과거의 것을 변경하는 것이 아니라 새로운 객체를 생성한다는 것을 기억합니다.</p>

<p><a class="p_ident" id="p_tKPg/OUkNV" href="#p_tKPg/OUkNV" tabindex="-1" role="presentation"></a>충돌을 처리할 때 <code>state.actors</code>에서 플레이어를 찾아 몬스터의 위치와 비교합니다. 플레이어의 <em>bottom</em>을 취하기 위해서는 수직 위치에 수직 크기를 추가해야 합니다. 업데이트된 상태의 생성은 플레이어 위치에 따라 <code>Coin</code>의 <code>collide</code> 메서드(액터 제거) 또는 <code>Lava</code>의 메서드(상태를 <code>&quot;lost&quot;</code>와 유사합니다.</p>

</div></div><nav><a href="15_event.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="17_canvas.html" title="next chapter">▶</a></nav>
</article>
