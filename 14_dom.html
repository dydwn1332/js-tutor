<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>문서 객체 모델</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 14;</script></head>

<article>
<nav><a href="13_browser.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="15_event.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>14장</span>문서 객체 모델</h1>

<blockquote>

<p><a class="p_ident" id="p_yqipqPLrLS" href="#p_yqipqPLrLS" tabindex="-1" role="presentation"></a>집을 짓고 나면 시작하기 전에 정말 알아야 할 것을 우연히 배웠다는 것을 알게 됩니다.</p>

<footer>Friedrich Nietzsche, <cite>선과 악을 넘어서</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_14.jpg" alt="Picture of a tree with letters and scripts hanging from its branches"></figure>

<p><a class="p_ident" id="p_O255K9+8+X" href="#p_O255K9+8+X" tabindex="-1" role="presentation"></a>브라우저에서 웹 페이지를 열면 브라우저는 12장의 파서가 프로그램을 구문 분석 하는 방식과 마찬가지로 페이지의 HTML 텍스트를 검색하여 구문 분석합니다. 브라우저는 문서 구조의 모델을 만들고 이 모델을 사용하여 화면에 페이지를 그립니다.</p>

<p><a class="p_ident" id="p_zrkOdq43yM" href="#p_zrkOdq43yM" tabindex="-1" role="presentation"></a>이 문서 표현은 JavaScript 프로그램이 샌드박스에서 사용할 수 있는 장난감 중 하나입니다. 읽거나 수정할 수 있는 데이터 구조입니다. 이것은 라이브 데이터 구조로 작동합니다. 수정되면 화면의 페이지가 변경 사항을 반영하도록 업데이트됩니다.</p>

<h2><a class="h_ident" id="h_XJzHjmX32m" href="#h_XJzHjmX32m" tabindex="-1" role="presentation"></a>문서 구조</h2>

<p><a class="p_ident" id="p_j22zv7gLgp" href="#p_j22zv7gLgp" tabindex="-1" role="presentation"></a>HTML 문서를 중첩된 상자 집합으로 상상할 수 있습니다. <code>&lt;body&gt;</code>와 <code>&lt;/body&gt;</code>와 같은 태그는 다른 태그들을 묶읍니다. 다음은 앞 장의 예입니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-sandbox="homepage"><a class="c_ident" id="c_4wSSl86LKl" href="#c_4wSSl86LKl" tabindex="-1" role="presentation"></a><span class="cm-meta">&lt;!doctype html&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">html</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">head</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">title</span><span class="cm-tag cm-bracket">&gt;</span>My home page<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">title</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">head</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>My home page<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Hello, I am Marijn and this is my home page.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>I also wrote a book! Read it
      <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;http://eloquentjavascript.net&quot;</span><span class="cm-tag cm-bracket">&gt;</span>here<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">html</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_rRaTGW2wtE" href="#p_rRaTGW2wtE" tabindex="-1" role="presentation"></a>페이지의 구조는 다음과 같습니다.</p><figure><img src="img/html-boxes.svg" alt="HTML document as nested boxes"></figure>

<p><a class="p_ident" id="p_1mgE45KfoF" href="#p_1mgE45KfoF" tabindex="-1" role="presentation"></a>브라우저가 문서를 나타내는 데 사용하는 데이터 구조는 위 모양을 따릅니다. 각 상자에는 어떤 HTML 태그를 나타내고 어떤 상자와 텍스트가 포함되어 있는지 찾기 위해 상호 작용할 수 있는 객체가 있습니다. 이 표현을 <em>Document Object Model</em> 또는 줄여서 DOM이라 합니다.</p>

<p><a class="p_ident" id="p_ltiXfOMPcl" href="#p_ltiXfOMPcl" tabindex="-1" role="presentation"></a>전역적인 바인딩 <code>document</code>이러한 개체에 대한 액세스를 제공합니다. <code>documentElement</code> 속성은 <code>&lt;html&gt;</code> 태그를 나타내는 객체를 참조합니다. 모든 HTML 문서에는 헤드와 본문을 갖기 때문에 이러한 요소를 가리키는 <code>head</code>와 <code>body</code> 속성이 있습니다.</p>

<h2><a class="h_ident" id="h_HnCB1zb0Ot" href="#h_HnCB1zb0Ot" tabindex="-1" role="presentation"></a>Trees</h2>

<p><a class="p_ident" id="p_63ES4U9bHr" href="#p_63ES4U9bHr" tabindex="-1" role="presentation"></a><a href="12_language.html#parsing">12장</a>의 구문 트리를 고려합니다. 그것의 구조는 브라우저 문서의 구조와 유사합니다. 각 노드는 다른 노드인 <em>children</em>을 참조할 수 있으며, 이 노드는 차례로 자신의 자식을 가질 수 있습니다. 이 모양은 요소가 자신과 유사한 하위 요소를 포함할 수 있는 중첩 구조의 전형입니다.</p>

<p><a class="p_ident" id="p_QVBp4KpREl" href="#p_QVBp4KpREl" tabindex="-1" role="presentation"></a>데이터 구조가 분기 구조를 가지고 있고 순환이 없고(노드가 직접 또는 간접적으로 자체를 포함하지 않는), 잘 정의된 단일 루트를 가질 때 <em>tree</em>라 합니다. DOM의 경우 <code>document.<wbr>documentElement</code>는 루트 역할을 합니다.</p>

<p><a class="p_ident" id="p_bH4un2TNOK" href="#p_bH4un2TNOK" tabindex="-1" role="presentation"></a>일반적인 트리에는 다양한 종류의 노드가 있습니다. <a href="12_language.html">Egg 언어</a>의 구문 트리에는 식별자, 값 및 응용 프로그램 노드가 있습니다. 응용 프로그램 노드에는 자식이 있을 수 있지만 식별자와 값은 잎 또는 자식이 없는 노드입니다.</p>

<p><a class="p_ident" id="p_boZnTfEJs0" href="#p_boZnTfEJs0" tabindex="-1" role="presentation"></a>DOM도 마찬가지입니다. HTML 태그를 나타내는 요소의 노드는 문서의 구조를 결정합니다. 여기에는 자식 노드가 있을 수 있습니다. 그러한 노드의 예는 <code>document.body</code>입니다. 이러한 자식 중 일부는 텍스트 또는 주석 노드와 같은 잎 노드가 될 수 있습니다.</p>

<p><a class="p_ident" id="p_f2BdWNSlpJ" href="#p_f2BdWNSlpJ" tabindex="-1" role="presentation"></a>각 DOM 노드 객체는 <code>nodeType</code> 속성을 갖는데, 그것은 노드 타입을 식별하는 코드(number)를 가집니다. 요소들이 code 1을 가지면 그것은 상수 속성 <code>Node.<wbr>ELEMENT_NODE</code>로 정의됩니다. 문서에서 텍스트 섹션을 나타내는 텍스트 노드들은 code 3 (<code>Node.TEXT_NODE</code>)를 취합니다. 주석은 code 8 (<code>Node.<wbr>COMMENT_NODE</code>)을 갖습니다.</p>

<p><a class="p_ident" id="p_RcdzGUMYUH" href="#p_RcdzGUMYUH" tabindex="-1" role="presentation"></a>문서 트리를 가시화 시키기 위한 또 다른 방식은 다음과 같습니다.</p><figure><img src="img/html-tree.svg" alt="HTML document as a tree"></figure>

<p><a class="p_ident" id="p_KheiUePsYH" href="#p_KheiUePsYH" tabindex="-1" role="presentation"></a>잎은 텍스트 노드이고 화살표는 노드 간의 부모-자식 관계를 나타냅니다.</p>

<h2 id="standard"><a class="h_ident" id="h_XgjABY6Ugx" href="#h_XgjABY6Ugx" tabindex="-1" role="presentation"></a>표준</h2>

<p><a class="p_ident" id="p_mGhmcMpW9e" href="#p_mGhmcMpW9e" tabindex="-1" role="presentation"></a>노드 타입을 나타내기 위해 암호화된 숫자 코드를 사용하는 것은 JavaScript와 매우 유사한 작업이 아닙니다. 이 페이지의 뒷부분에서 DOM 인터페이스의 다른 부분도 번거롭고 생소하게 느껴진다는 것을 알게 될 것입니다. 그 이유는 DOM이 JavaScript만을 위해 설계되지 않았기 때문입니다. 그보다는 다른 시스템에서도 사용할 수 있는 언어 중립적인 인터페이스가 되도록 노력합니다. HTML뿐만 아니라 HTML과 유사한 구문을 사용하는 일반 데이터 형식인 XML에도 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_IT2jWsK6qu" href="#p_IT2jWsK6qu" tabindex="-1" role="presentation"></a>이것은 불행한 일이지만, 표준은 종종 유용합니다. 이 경우 이점(언어 간 일관성)이 그다지 매력적이지 않습니다. 사용 중인 언어와 적절하게 통합된 인터페이스를 사용하면 여러 언어에 걸쳐 친숙한 인터페이스를 사용하는 것보다 더 많은 시간을 절약할 수 있습니다.</p>

<p><a class="p_ident" id="p_feaMhbBocX" href="#p_feaMhbBocX" tabindex="-1" role="presentation"></a>빈약한 통합의 예로 DOM에서 element 노드들이 갖는 <code>childNodes</code> 속성을 고려하십시오. 이 속성은 자식 노드에 액세스하기 위해 숫자로 라벨화 된 속성들과 <code>length</code> 속성이 있는 배열과 유사한 객체를 보유합니다. 그러나 그것은 실제 배열이 아닌 <code>NodeList</code> 타입의 인스턴스이므로 <code>slice</code>와 <code>map</code>과 같은 메서드가 없습니다.</p>

<p><a class="p_ident" id="p_XrOZAaBu2c" href="#p_XrOZAaBu2c" tabindex="-1" role="presentation"></a>단순히 디자인이 좋지 않은 문제가 있습니다. 예를 들어 새 노드를 만들고 즉시 자식이나 속성을 추가할 수 있는 방법이 없습니다. 대신 먼저 생성한 다음 측면 효과를 사용하여 자식과 속성을 하나씩 추가해야 합니다. DOM과 많이 상호 작용하는 코드는 길고 반복적이며 보기 흉해지는 경향이 있습니다.</p>

<p><a class="p_ident" id="p_1dwhmrGwQQ" href="#p_1dwhmrGwQQ" tabindex="-1" role="presentation"></a>그러나 이러한 결함이 치명적이지는 않습니다. JavaScript를 사용하면 자체 추상화를 만들 수 있으므로 수행 중인 작업을 표현하는 개선된 방법을 설계할 수 있습니다. 브라우저 프로그래밍을 위한 많은 라이브러리에는 이러한 도구가 함께 제공됩니다.</p>

<h2><a class="h_ident" id="h_ShZPVipWw/" href="#h_ShZPVipWw/" tabindex="-1" role="presentation"></a>트리를 통한 이동</h2>

<p><a class="p_ident" id="p_KU+aLLXhA0" href="#p_KU+aLLXhA0" tabindex="-1" role="presentation"></a>DOM 노드에는 다른 인접 노드에 대한 풍부한 링크가 포함되어 있습니다. 다음 다이어그램은 이를 보여줍니다.</p><figure><img src="img/html-links.svg" alt="Links between DOM nodes"></figure>

<p><a class="p_ident" id="p_oWR8F5E2Yw" href="#p_oWR8F5E2Yw" tabindex="-1" role="presentation"></a>다이어그램은 각 타입의 링크를 하나만 보여주지만 모든 노드에는 자신이 속한 노드를 가리키는 <code>parentNode</code> 속성이 있습니다. 마찬가지로 모든 요소 노드(노드 타입 1)에는 자식을 보유하는 배열과 같은 객체를 가리키는 <code>childNodes</code> 속성이 있습니다.</p>

<p><a class="p_ident" id="p_zpX7kgIV1h" href="#p_zpX7kgIV1h" tabindex="-1" role="presentation"></a>이론적으로 이러한 상위 및 하위 링크만 사용하여 트리의 아무 곳이나 이동할 수 있습니다. 그러나 JavaScript는 또한 많은 추가 편의 링크에 대한 액세스를 제공합니다. <code>firstChild</code>와 <code>lastChild</code> 속성은 첫 번째와 마지막 자식 요소를 가리키거나 또는 자식이 없는 노드에 관해 <code>null</code>을 가집니다. 유사하게, <code>previousSibling</code>과 <code>nextSibling</code>은 인접 노드들을 가리킵니다. 그것들은 해당 노드 전 또는 직후에 나타나는 동일한 부모 노드에 있는 인접 노드를 가리킵니다. 첫 번째 자식의 경우에 <code>previousSibling</code>은 null이 되고 마지막 자식의 <code>nextSibling</code>은 null이 됩니다.</p>

<p><a class="p_ident" id="p_EXYoCGtRP4" href="#p_EXYoCGtRP4" tabindex="-1" role="presentation"></a><code>children</code> 속성도 있는데, 그것은 <code>childNodes</code>와 같지만, 요소 (type 1) 자식만 포함합니다. 이것은 텍스트 노드에 관심이 없을 때 유용할 수 있습니다.</p>

<p><a class="p_ident" id="p_wSmPJ/d3c4" href="#p_wSmPJ/d3c4" tabindex="-1" role="presentation"></a>이와 같은 중첩 데이터 구조를 다룰 때 재귀 함수가 종종 유용합니다. 다음 함수는 주어진 문자열을 포함하는 텍스트 노드에 대한 문서를 스캔하고 하나를 찾으면 <code>true</code>를 반환합니다.</p>

<pre id="talksAbout" class="snippet cm-s-default" data-language="javascript"  data-sandbox="homepage"><a class="c_ident" id="c_6/D7aNG9Y+" href="#c_6/D7aNG9Y+" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">talksAbout</span>(<span class="cm-def">node</span>, <span class="cm-def">string</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeType</span> <span class="cm-operator">==</span> <span class="cm-variable">Node</span>.<span class="cm-property">ELEMENT_NODE</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">child</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">node</span>.<span class="cm-property">childNodes</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable">talksAbout</span>(<span class="cm-variable-2">child</span>, <span class="cm-variable-2">string</span>)) {
        <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
      }
    }
    <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">node</span>.<span class="cm-property">nodeType</span> <span class="cm-operator">==</span> <span class="cm-variable">Node</span>.<span class="cm-property">TEXT_NODE</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>.<span class="cm-property">nodeValue</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">string</span>) <span class="cm-operator">&gt;</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">talksAbout</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">&quot;book&quot;</span>));
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_z6XhjipK31" href="#p_z6XhjipK31" tabindex="-1" role="presentation"></a>텍스트 노드의 <code>nodeValue</code> 속성은 그것이 나타내는 텍스트 문자열을 포함합니다.</p>

<h2><a class="h_ident" id="h_jS5BEpmLY0" href="#h_jS5BEpmLY0" tabindex="-1" role="presentation"></a>요소 찾기</h2>

<p><a class="p_ident" id="p_saBiuECTgW" href="#p_saBiuECTgW" tabindex="-1" role="presentation"></a>부모, 자녀 및 형제자매 간의 이러한 링크를 탐색하는 것은 종종 유용합니다. 그러나 문서에서 특정 노드를 찾으려면 <code>document.body</code>에서 시작해서 고정된 속성 경로 에 도달하는 것은 나쁜 생각입니다. 그렇게 하면 문서의 정확한 구조(나중에 변경할 수 있는 구조)에 대한 가정이 프로그램에 포함됩니다. 또 다른 복잡한 요소는 노드 사이의 공백에 대해서도 텍스트 노드가 생성된다는 것입니다. 예 문서의 <code>&lt;body&gt;</code> 태그에는 3개의 자식(<code>&lt;h1&gt;</code>과 두 개의 <code>&lt;p&gt;</code> 요소)만 있는 것이 아니라 실제로는 7개(이 3개와 앞, 뒤, 사이에 공백)가 있습니다.</p>

<p><a class="p_ident" id="p_St5y6wbhGX" href="#p_St5y6wbhGX" tabindex="-1" role="presentation"></a>따라서 해당 문서에 있는 링크의 <code>href</code> 속성을 얻는데 "문서 본문의 여섯 번째 자식 중 두 번째 자식 가져오기"와 같은 방식을 사용하지 않습니다. "문서의 첫 번째 링크 가져오기"라고 하면 더 좋을 것입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript"  data-sandbox="homepage"><a class="c_ident" id="c_X6zFdF/80F" href="#c_X6zFdF/80F" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">&quot;a&quot;</span>)[<span class="cm-number">0</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">link</span>.<span class="cm-property">href</span>);</pre>

<p><a class="p_ident" id="p_VGWClqmGZz" href="#p_VGWClqmGZz" tabindex="-1" role="presentation"></a>모든 요소 노드는 <code>getElementsByTagName</code> 메서드를 갖는데, 이것은 해당 노드의 직접 또는 간접 자식인 후손에 해당하는 지정된 태그 이름을 가진 모든 요소를 수집하고 배열과 유사한 객체로 반환합니다.</p>

<p><a class="p_ident" id="p_xDCAIt1lT6" href="#p_xDCAIt1lT6" tabindex="-1" role="presentation"></a>특정 노드를 찾기 위해 <code>id</code> 속성을 지정하고 <code>document.<wbr>getElementById</code>를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_CpFVpKYjsr" href="#c_CpFVpKYjsr" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>My ostrich Gertrude:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;gertrude&quot;</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/ostrich.png&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">ostrich</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">&quot;gertrude&quot;</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ostrich</span>.<span class="cm-property">src</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_Ur1I1Lx8SY" href="#p_Ur1I1Lx8SY" tabindex="-1" role="presentation"></a>세 번째 유사한 방식은 <code>getElementsByClassName</code>로 그것은 <code>getElementsByTagName</code>과 유사하게 요소 노드의 콘텐츠를 통해 찾고 <code>class</code> 속성에서 지정된 문자열을 갖는 모든 요소를 검색합니다.</p>

<h2><a class="h_ident" id="h_npiFAJENvT" href="#h_npiFAJENvT" tabindex="-1" role="presentation"></a>문서 변경</h2>

<p><a class="p_ident" id="p_PqYkGnE2Ps" href="#p_PqYkGnE2Ps" tabindex="-1" role="presentation"></a>DOM 데이터 구조에 대한 거의 모든 것이 변경될 수 있습니다. 문서 트리의 모양은 부모-자식 관계를 변경하여 수정할 수 있습니다. 노드에는 현재 상위 노드에서 노드를 제거하는 <code>remove</code> 메서드가 있습니다. 요소 노드에 자식 노드를 추가하려면 자식 리스트 끝에 <code>appendChild</code>을 사용하거나 또는 두 번째 인수로 지정된 노드 앞에 첫 번째 인수로 지정된 노드를 삽입하는 <code>insertBefore</code>를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_xdAyPFCEJ5" href="#c_xdAyPFCEJ5" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>One<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Three<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">paragraphs</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">&quot;p&quot;</span>);
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">insertBefore</span>(<span class="cm-variable">paragraphs</span>[<span class="cm-number">2</span>], <span class="cm-variable">paragraphs</span>[<span class="cm-number">0</span>]);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_izAyoVA99z" href="#p_izAyoVA99z" tabindex="-1" role="presentation"></a>노드는 문서의 한 위치에만 존재할 수 있습니다. 따라서, 단락 <em>One</em>의 앞에 단락 <em>Three</em>의 삽입은 먼저 문서의 말미에서 그것을 제거한 다음에 앞에 그것을 삽입하여 <em>Three</em>/<em>One</em>/<em>Two</em>의 결과가 됩니다. 노드를 어딘가에 삽입하는 모든 작업은 측면 효과로 현재 위치(있는 경우)에서 노드를 제거합니다.</p>

<p><a class="p_ident" id="p_PHkpqBpgHX" href="#p_PHkpqBpgHX" tabindex="-1" role="presentation"></a><code>replaceChild</code> 메서드는 자식 노드를 다른 노드로 교체하는데 사용됩니다. 새 노드와 교체할 노드라는 두 개의 노드를 인수로 취합니다. 교체된 노드는 메서드가 호출된 요소의 자식이어야 합니다. <code>replaceChild</code> 및 <code>insertBefore</code> 모두 첫 번째 인수로 <em>new</em>를 기대합니다.</p>

<h2><a class="h_ident" id="h_AlX6HES+2D" href="#h_AlX6HES+2D" tabindex="-1" role="presentation"></a>노드 생성</h2>

<p><a class="p_ident" id="p_Z0UBaFpahv" href="#p_Z0UBaFpahv" tabindex="-1" role="presentation"></a><code>alt</code> 속성이 포함된 텍스트를 갖는 문서에서 모든 이미지들을 (<code>&lt;img&gt;</code> 태그) 대체하는 스크립트를 작성한다고 하자. 그것은 이미지의 또 다른 텍스트 표현을 나타낸다.</p>

<p><a class="p_ident" id="p_zMqlQBb7H1" href="#p_zMqlQBb7H1" tabindex="-1" role="presentation"></a>여기에는 이미지를 제거하는 것뿐만 아니라 이미지를 대체할 새 텍스트 노드를 추가하는 작업도 포함됩니다. 텍스트 노드는 <code>document.<wbr>createTextNode</code> 메서드로 생성됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_x13nsyh4X4" href="#c_x13nsyh4X4" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>The <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/cat.png&quot;</span> <span class="cm-attribute">alt</span>=<span class="cm-string">&quot;Cat&quot;</span><span class="cm-tag cm-bracket">&gt;</span> in the
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/hat.png&quot;</span> <span class="cm-attribute">alt</span>=<span class="cm-string">&quot;Hat&quot;</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">onclick</span>=<span class="cm-string">&quot;replaceImages()&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Replace<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">replaceImages</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">images</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">&quot;img&quot;</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-variable-2">images</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&gt;=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span><span class="cm-operator">--</span>) {
      <span class="cm-keyword">let</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable-2">images</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">image</span>.<span class="cm-property">alt</span>) {
        <span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">image</span>.<span class="cm-property">alt</span>);
        <span class="cm-variable-2">image</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">replaceChild</span>(<span class="cm-variable-2">text</span>, <span class="cm-variable-2">image</span>);
      }
    }
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_SZGvV3YwdR" href="#p_SZGvV3YwdR" tabindex="-1" role="presentation"></a>문자열이 주어지면 <code>createTextNode</code>는 문서에 삽입하여 화면에 표시할 수 있는 텍스트 노드를 제공합니다.</p>

<p><a class="p_ident" id="p_6KP6Yw4ww7" href="#p_6KP6Yw4ww7" tabindex="-1" role="presentation"></a>이미지를 가로지르는 루프는 리스트 끝에서 시작됩니다. 이것은 <code>getElementsByTagName</code>와 같은 메서드가 (또는 <code>childNodes</code>와 같은 속성) childNodes) <em>live</em>이기 때문에 필요합니다. 즉, 문서가 변경되면 업데이트됩니다. 앞에서 시작했다면 첫 번째 이미지를 제거하면 목록의 첫 번째 요소가 손실되어 루프가 두 번째 반복될 때(여기서 <code>i</code>는 1) 컬렉션의 길이도 이제 1이기 때문에 중지됩니다.</p>

<p><a class="p_ident" id="p_H+4G9MqWPh" href="#p_H+4G9MqWPh" tabindex="-1" role="presentation"></a>라이브 노드가 아닌 <em>solid</em> 노드 컬렉션을 원한다면, <code>Array.from</code>을 호출하여 컬렉션을 실제 배열로 변환할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YYMkVyoN/K" href="#c_YYMkVyoN/K" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">arrayish</span> <span class="cm-operator">=</span> {<span class="cm-number cm-property">0</span>: <span class="cm-string">&quot;one&quot;</span>, <span class="cm-number cm-property">1</span>: <span class="cm-string">&quot;two&quot;</span>, <span class="cm-property">length</span>: <span class="cm-number">2</span>};
<span class="cm-keyword">let</span> <span class="cm-def">array</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable">arrayish</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">array</span>.<span class="cm-property">map</span>(<span class="cm-def">s</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">s</span>.<span class="cm-property">toUpperCase</span>()));
<span class="cm-comment">// → [&quot;ONE&quot;, &quot;TWO&quot;]</span></pre>

<p><a class="p_ident" id="p_2LO1OJVEk3" href="#p_2LO1OJVEk3" tabindex="-1" role="presentation"></a>요소 노드를 생성하려면 <code>document.<wbr>createElement</code> 메서드를 사용할 수 있습니다. 이 메서드는 태그 이름을 사용하여 지정된 타입의 새 빈 노드를 반환합니다.</p>

<p id="elt"><a class="p_ident" id="p_bvldRsjLfM" href="#p_bvldRsjLfM" tabindex="-1" role="presentation"></a>다음 예는 유틸리티 <code>elt</code>를 정의하는데 이것은 요소 노드를 만들고 나머지 인수를 해당 노드의 자식으로 처리합니다. 이 함수는 quote에 속성을 추가하는데 사용됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_yKu7txUDrU" href="#c_yKu7txUDrU" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">blockquote</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;quote&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
  No book can ever be finished. While working on it we learn
  just enough to find it immature the moment we turn away
  from it.
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">blockquote</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">elt</span>(<span class="cm-def">type</span>, <span class="cm-meta">...</span><span class="cm-def">children</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">type</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">child</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">children</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;string&quot;</span>) <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
      <span class="cm-keyword">else</span> <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>));
    }
    <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>;
  }

  <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">&quot;quote&quot;</span>).<span class="cm-property">appendChild</span>(
    <span class="cm-variable">elt</span>(<span class="cm-string">&quot;footer&quot;</span>, <span class="cm-string">&quot;—&quot;</span>,
        <span class="cm-variable">elt</span>(<span class="cm-string">&quot;strong&quot;</span>, <span class="cm-string">&quot;Karl Popper&quot;</span>),
        <span class="cm-string">&quot;, preface to the second edition of &quot;</span>,
        <span class="cm-variable">elt</span>(<span class="cm-string">&quot;em&quot;</span>, <span class="cm-string">&quot;The Open Society and Its Enemies&quot;</span>),
        <span class="cm-string">&quot;, 1950&quot;</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_pmUmF/LHme" href="#h_pmUmF/LHme" tabindex="-1" role="presentation"></a>속성</h2>

<p><a class="p_ident" id="p_HSPdyuAruy" href="#p_HSPdyuAruy" tabindex="-1" role="presentation"></a>링크를 위한 <code>href</code>와 같은 일부 요소 속성은 요소의 DOM 객체 상에서 같은 이름의 속성을 통해 접근될 수 있습니다. 이것은 가장 일반적으로 사용되는 표준 속성의 경우입니다.</p>

<p><a class="p_ident" id="p_vK0AfBjXCM" href="#p_vK0AfBjXCM" tabindex="-1" role="presentation"></a>그러나 HTML을 사용하면 노드에 원하는 속성을 설정할 수 있습니다. 문서에 추가 정보를 저장할 수 있기 때문에 유용할 수 있습니다. 그러나 고유한 속성 이름을 만드는 경우 이러한 속성은 요소 노드의 속성으로 표시되지 않습니다. 대신 <code>getAttribute</code> 및 <code>setAttribute</code> 메서드를 사용하여 작업해야 합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_S977zg3XyT" href="#c_S977zg3XyT" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">data-classified</span>=<span class="cm-string">&quot;secret&quot;</span><span class="cm-tag cm-bracket">&gt;</span>The launch code is 00000000.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">data-classified</span>=<span class="cm-string">&quot;unclassified&quot;</span><span class="cm-tag cm-bracket">&gt;</span>I have two feet.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">paras</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">&quot;p&quot;</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">para</span> <span class="cm-keyword">of</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable">paras</span>)) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">para</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">&quot;data-classified&quot;</span>) <span class="cm-operator">==</span> <span class="cm-string">&quot;secret&quot;</span>) {
      <span class="cm-variable">para</span>.<span class="cm-property">remove</span>();
    }
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_BrjnN/bGC0" href="#p_BrjnN/bGC0" tabindex="-1" role="presentation"></a>다른 속성과 충돌하지 않도록 이러한 구성된 속성의 이름에 <code>data-</code> 접두사를 붙이는 것이 좋습니다.</p>

<p><a class="p_ident" id="p_Hi6IWNjXxP" href="#p_Hi6IWNjXxP" tabindex="-1" role="presentation"></a>JavaScript 언어에서 키워드에 해당하는 <code>class</code>는 주로 사용되는 속성입니다. 일부 이전 JavaScript 구현은 키워드와 일치하는 속성 이름을 처리할 수 없었습니다. 이 속성에 접근하는데 사용되는 속성을 <code>className</code>이라고 합니다. <code>getAttribute</code> 및 <code>setAttribute</code> 메서드를 사용하여 실제 이름 <code>&quot;class&quot;</code>으로 액세스할 수도 있습니다.</p>

<h2><a class="h_ident" id="h_lyrY2KUDl7" href="#h_lyrY2KUDl7" tabindex="-1" role="presentation"></a>레이아웃</h2>

<p><a class="p_ident" id="p_Qvk9MMKpjV" href="#p_Qvk9MMKpjV" tabindex="-1" role="presentation"></a>다른 타입의 요소들은 다르게 배치됩니다. 단락(<code>&lt;p&gt;</code>) 또는 제목(<code>&lt;h1&gt;</code>)과 같은 일부는 문서의 전체 너비를 차지하며 별도의 줄에 표시됩니다. 이를 <em>block</em> 요소라 합니다. 링크(<code>&lt;a&gt;</code>) 또는 <code>&lt;strong&gt;</code> 요소와 같은 기타 요소는 주변 텍스트와 같은 줄에 렌더링됩니다. 이러한 요소를 <em>inline</em> 요소라 합니다.</p>

<p><a class="p_ident" id="p_uyQ6hsLw6d" href="#p_uyQ6hsLw6d" tabindex="-1" role="presentation"></a>주어진 문서에 대해 브라우저는 레이아웃을 계산할 수 있으며, 이는 각 요소의 유형과 내용에 따라 크기와 위치를 지정합니다. 이 레이아웃은 문서를 실제로 그리는 데 사용됩니다.</p>

<p><a class="p_ident" id="p_2zXIgr70Do" href="#p_2zXIgr70Do" tabindex="-1" role="presentation"></a>요소의 크기와 위치는 JavaScript에서 액세스할 수 있습니다. <code>offsetWidth</code> 및 <code>offsetHeight</code> 속성은 요소가 <em>pixels</em>로 차지하는 공간을 제공합니다. 픽셀은 브라우저의 기본 측정 단위입니다. 전통적으로 화면이 그릴 수 있는 가장 작은 점에 해당하지만 매우 작은 점을 그릴 수 있는 최신 디스플레이에서는 더 이상 그렇지 않을 수 있으며 브라우저 픽셀이 여러 디스플레이 점에 걸쳐 있을 수 있습니다.</p>

<p><a class="p_ident" id="p_CL3JagaUiP" href="#p_CL3JagaUiP" tabindex="-1" role="presentation"></a>유사하게 <code>clientWidth</code>와 <code>clientHeight</code>는 요소 내부에 공간 크기를 제공합니다(경계 폭은 무시).</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_E5M9cwi2qC" href="#c_E5M9cwi2qC" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;border: 3px solid red&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
  I'm boxed in
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">getElementsByTagName</span>(<span class="cm-string">&quot;p&quot;</span>)[<span class="cm-number">0</span>];
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;clientHeight:&quot;</span>, <span class="cm-variable">para</span>.<span class="cm-property">clientHeight</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;offsetHeight:&quot;</span>, <span class="cm-variable">para</span>.<span class="cm-property">offsetHeight</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p id="boundingRect"><a class="p_ident" id="p_LG8xrkr071" href="#p_LG8xrkr071" tabindex="-1" role="presentation"></a>화면에서 요소의 정확한 위치를 찾는 가장 효과적인 방법은 <code>getBoundingClientRect</code> 메서드입니다. 이것은 <code>top</code>, <code>bottom</code>, <code>left</code> 및 <code>right</code> 속성을 갖는 객체를 반환합니다(화면 상단 죄측 대비 요소 측면들의 화소 위치를 나타냄). 전체 문서를 기준으로 하려면 <code>pageXOffset</code> 및 <code>pageYOffset</code> 바인딩에서 찾을 수 있는 현재 스크롤 위치를 추가해야 합니다.</p>

<p><a class="p_ident" id="p_LcMNzqCMUS" href="#p_LcMNzqCMUS" tabindex="-1" role="presentation"></a>문서를 배치하는 것은 꽤 많은 작업이 될 수 있습니다. 속도를 위해 브라우저 엔진은 문서를 변경할 때마다 즉시 다시 레이아웃하지 않고 가능한 한 오래 기다립니다. 문서를 변경한 JavaScript 프로그램 실행이 완료되면 브라우저는 변경된 문서를 화면에 그리기 위해 새 레이아웃을 계산해야 합니다. 프로그램이 <code>offsetHeight</code> 또는 <code>getBoundingClientRect</code> 호출과 같은 속성을 읽는 방식으로 무엇인가의 위치 또는 크기를 요청할 때 올바른 정보를 제공하고, 또한 레이아웃을 계산해야 합니다.</p>

<p><a class="p_ident" id="p_TzaMQEZthV" href="#p_TzaMQEZthV" tabindex="-1" role="presentation"></a>DOM 레이아웃 정보 읽기와 DOM 변경 사이를 반복적으로 번갈아 가며 수행하는 프로그램은 많은 레이아웃 계산을 강제로 수행하고 결과적으로 매우 느리게 실행됩니다. 다음 코드는 이에 대한 예입니다. 여기에는 2,000 픽셀 너비의 <em>X</em> 문자 행을 구성하고 각 문자에 걸리는 시간을 측정하는 두 개의 서로 다른 프로그램이 포함되어 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_Mmn5ZrRT52" href="#c_Mmn5ZrRT52" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;one&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;two&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">time</span>(<span class="cm-def">name</span>, <span class="cm-def">action</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">start</span> <span class="cm-operator">=</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>(); <span class="cm-comment">// Current time in milliseconds</span>
    <span class="cm-variable-2">action</span>();
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">name</span>, <span class="cm-string">&quot;took&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable-2">start</span>, <span class="cm-string">&quot;ms&quot;</span>);
  }

  <span class="cm-variable">time</span>(<span class="cm-string">&quot;naive&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">&quot;one&quot;</span>);
    <span class="cm-keyword">while</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">&lt;</span> <span class="cm-number">2000</span>) {
      <span class="cm-variable-2">target</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-string">&quot;X&quot;</span>));
    }
  });
  <span class="cm-comment">// → naive took 32 ms</span>

  <span class="cm-variable">time</span>(<span class="cm-string">&quot;clever&quot;</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">target</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">&quot;two&quot;</span>);
    <span class="cm-variable-2">target</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-string">&quot;XXXXX&quot;</span>));
    <span class="cm-keyword">let</span> <span class="cm-def">total</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-number">2000</span> <span class="cm-operator">/</span> (<span class="cm-variable-2">target</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">/</span> <span class="cm-number">5</span>));
    <span class="cm-variable-2">target</span>.<span class="cm-property">firstChild</span>.<span class="cm-property">nodeValue</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;X&quot;</span>.<span class="cm-property">repeat</span>(<span class="cm-variable-2">total</span>);
  });
  <span class="cm-comment">// → clever took 1 ms</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_VfKBbtOqcL" href="#h_VfKBbtOqcL" tabindex="-1" role="presentation"></a>스타일링</h2>

<p><a class="p_ident" id="p_G9Se5o/P9V" href="#p_G9Se5o/P9V" tabindex="-1" role="presentation"></a>다른 HTML 요소가 다르게 그려지는 것을 보았습니다. 일부는 블록으로 표시되고 다른 일부는 인라인으로 표시됩니다. 일부 추가 스타일링 <code>&lt;strong&gt;</code>은 콘텐츠를 굵게 만들고 파란색으로 만들고 밑줄을 긋습니다.</p>

<p><a class="p_ident" id="p_0uDaEVu+We" href="#p_0uDaEVu+We" tabindex="-1" role="presentation"></a><code>&lt;img&gt;</code> 태그가 이미지 또는 <code>&lt;a&gt;</code> 태그를 사용하는 방식은 클릭 시에 링크 또는 요소 타입에 강하게 연결되도록 하지만 텍스트 색상 또는 밑줄과 같은 요소 스타일링을 변경시킬 수 있습니다. 다음은 <code>style</code> 속성 사용 예를 나타냅니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_Qie8s1kOFZ" href="#c_Qie8s1kOFZ" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;.&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Normal link<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;.&quot;</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;color: green&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Green link<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_UDiIHFxHaH" href="#p_UDiIHFxHaH" tabindex="-1" role="presentation"></a>style 속성은 하나 이상의 선언을 포함할 수 있습니다(콜론이 수반된 <code>color</code>와 <code>green</code>과 같은 값을 갖는). 둘 이상의 선언이 있는 경우 <code>&quot;color: red; border: none&quot;</code>에서와 같이 세미콜론으로 구분해야 합니다.</p>

<p><a class="p_ident" id="p_IFsPqr8z6J" href="#p_IFsPqr8z6J" tabindex="-1" role="presentation"></a>문서의 많은 부분이 스타일의 영향을 받을 수 있습니다. 예를 들어 <code>display</code> 속성은 요소가 블록으로 표시되는지 인라인 요소로 표시되는지 제어합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_NN8SrlwTXB" href="#c_NN8SrlwTXB" tabindex="-1" role="presentation"></a>This text is displayed <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>inline<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>,
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;display: block&quot;</span><span class="cm-tag cm-bracket">&gt;</span>as a block<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>, and
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;display: none&quot;</span><span class="cm-tag cm-bracket">&gt;</span>not at all<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>.</pre>

<p><a class="p_ident" id="p_1al7UxHqSY" href="#p_1al7UxHqSY" tabindex="-1" role="presentation"></a><code>block</code> 태그는 블록 요소가 주변 텍스트와 인라인으로 표시되지 않기 때문에 태그는 한 줄에 종료됩니다. 마지막 태그가 전혀 표시되지 않는데, <code>display: none</code>는 요소가 화면에 표시되지 않도록 합니다. 이것은 요소를 숨기는 방법입니다. 나중에 다시 공개하기 쉽기 때문에 문서에서 완전히 제거하는 것이 더 나은 경우가 많습니다.</p>

<p><a class="p_ident" id="p_HcAoKCgOCF" href="#p_HcAoKCgOCF" tabindex="-1" role="presentation"></a>JavaScript 코드는 요소의 <code>style</code> 속성을 통해 요소의 스타일을 직접 조작할 수 있습니다. 이 속성은 가능한 모든 스타일 속성에 대한 속성이 있는 객체를 보유합니다. 이러한 속성의 값은 요소 스타일의 특정 측면을 변경하기 위해 쓸 수 있는 문자열입니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_WtWpdICuOL" href="#c_WtWpdICuOL" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;para&quot;</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;color: purple&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
  Nice text
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">getElementById</span>(<span class="cm-string">&quot;para&quot;</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span>);
  <span class="cm-variable">para</span>.<span class="cm-property">style</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;magenta&quot;</span>;
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_yEGT1UyTDI" href="#p_yEGT1UyTDI" tabindex="-1" role="presentation"></a>일부 스타일 속성 이름에는 <code>font-family</code>와 같은 하이픈이 포함됩니다. 이러한 속성 이름은 JavaScript에서 작업하기 어렵기 때문에(<code>style[&quot;font-family&quot;]</code>로 표현), <code>style</code> 객체에서 속성 이름은 하이픈이 제거되고 뒤에 오는 문자가 대문자로 표시됩니다(<code>style.fontFamily</code>).</p>

<h2><a class="h_ident" id="h_7kGsaGnBbD" href="#h_7kGsaGnBbD" tabindex="-1" role="presentation"></a>계단식 스타일</h2>

<p><a class="p_ident" id="p_i2Y6OhznV/" href="#p_i2Y6OhznV/" tabindex="-1" role="presentation"></a>HTML의 스타일링 시스템은 CSS(<em>Cascading Style Sheets</em>)로 불립니다. <em>style sheet</em>는 문서에서 요소 스타일링을 위한 규칙들의 집합입니다. <code>&lt;style&gt;</code> 태그 내에 주어집니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_WnNZqmUMzQ" href="#c_WnNZqmUMzQ" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">strong</span> {
    <span class="cm-property">font-style</span>: <span class="cm-atom">italic</span>;
    <span class="cm-property">color</span>: <span class="cm-keyword">gray</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Now <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span>strong text<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">strong</span><span class="cm-tag cm-bracket">&gt;</span> is italic and gray.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_QiKgncw4nF" href="#p_QiKgncw4nF" tabindex="-1" role="presentation"></a><em>cascading</em>이라는 이름은 이러한 여러 규칙이 결합되어 요소의 최종 스타일을 생성한다는 사실을 나타냅니다. 이 예에서 <code>&lt;strong&gt;</code> 태그에 관한 기본 스타일링은(<code>font-weight: bold</code>와 같은) <code>&lt;style&gt;</code> 태그에서 오버레이 됩니다(<code>font-style</code> 및 <code>color</code> 추가).</p>

<p><a class="p_ident" id="p_TpdOmgyGAl" href="#p_TpdOmgyGAl" tabindex="-1" role="presentation"></a>여러 규칙이 동일한 속성에 대한 값을 정의하는 경우 가장 최근에 읽은 규칙이 더 높은 우선 순위를 가지며 우선합니다. 따라서 <code>&lt;style&gt;</code> 태그의 규칙에 <code>font-weight: normal</code>가 포함되어 있으면(기본 <code>font-weight</code> 규칙과 상반되는) 텍스트가 굵게 표시되지 않고 일반 텍스트가 됩니다. <code>style</code> 속성에서 스타일은 가장 높은 우선 순위를 갖는 노드에 직접 적용되며 항상 우선합니다.</p>

<p><a class="p_ident" id="p_BgSVZ5fpx+" href="#p_BgSVZ5fpx+" tabindex="-1" role="presentation"></a>CSS 규칙에서 태그 이름 이외의 항목을 대상으로 지정할 수 있습니다. <code>.abc</code>에 관한 규칙은 그것들의 <code>class</code> 속성에서 <code>&quot;abc&quot;</code>를 가진 모든 요소에 적용됩니다. <code>#xyz</code>에 관한 규칙은 applies to the element with an  attribute of <code>&quot;xyz&quot;</code>의 <code>id</code> 속성을 가진 요소에 적용됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/css" ><a class="c_ident" id="c_0kqCdknBKh" href="#c_0kqCdknBKh" tabindex="-1" role="presentation"></a><span class="cm-qualifier">.subtle</span> {
  <span class="cm-property">color</span>: <span class="cm-keyword">gray</span>;
  <span class="cm-property">font-size</span>: <span class="cm-number">80%</span>;
}
<span class="cm-builtin">#header</span> {
  <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
  <span class="cm-property">color</span>: <span class="cm-keyword">white</span>;
}
<span class="cm-comment">/* p elements with id main and with classes a and b */</span>
<span class="cm-tag">p</span><span class="cm-builtin">#main</span><span class="cm-qualifier">.a</span><span class="cm-qualifier">.b</span> {
  <span class="cm-property">margin-bottom</span>: <span class="cm-number">20px</span>;
}</pre>

<p><a class="p_ident" id="p_7kmWmOHAMA" href="#p_7kmWmOHAMA" tabindex="-1" role="presentation"></a>가장 최근에 정의된 규칙을 선호하는 우선 순위 규칙은 규칙의 특정성이 동일한 경우에만 적용됩니다. 규칙의 특이성은 필요한 요소 측면의 수와 종류(태그, 클래스 또는 ID)에 따라 결정되는 일치하는 요소를 얼마나 정확하게 설명하는지 측정합니다. 예를 들어, <code>p.a</code> 규칙은 <code>p</code> 또는 단순히 <code>.a</code>로 하는 규칙보다 더 구체적이고 우선합니다.</p>

<p><a class="p_ident" id="p_sM9qHFmGsZ" href="#p_sM9qHFmGsZ" tabindex="-1" role="presentation"></a><code>p &gt; a {…}</code>의 표기는 <code>&lt;p&gt;</code> 태그의 직접적인 자식인 모든 <code>&lt;a&gt;</code>에 주어진 스타일을 적용합니다. 유사하게 <code>p a {…}</code>는 <code>&lt;p&gt;</code> 태그 내부에 모든 <code>&lt;a&gt;</code> 태그에 적용됩니다(그것들이 직접적이건 간접적이건 간에).</p>

<h2><a class="h_ident" id="h_5ooQzToxht" href="#h_5ooQzToxht" tabindex="-1" role="presentation"></a>쿼리 선택기</h2>

<p><a class="p_ident" id="p_1wj652tYzq" href="#p_1wj652tYzq" tabindex="-1" role="presentation"></a>여기에서는 스타일 시트를 많이 사용하지 않을 것입니다. 그것들을 이해하면 브라우저에서 프로그래밍할 때 도움이 되지만 별도의 책이 필요할 정도로 복잡합니다.</p>

<p><a class="p_ident" id="p_8GQ7mCW+rh" href="#p_8GQ7mCW+rh" tabindex="-1" role="presentation"></a><em>selector</em> 구문(스타일 세트가 적용되는 요소를 결정하기 위해 스타일 시트에서 사용되는 표기법)을 도입한 주된 이유는 DOM 요소를 찾는 효과적인 방법으로 이 동일한 미니 언어를 사용할 수 있기 때문입니다.</p>

<p><a class="p_ident" id="p_HBvo4vBdkM" href="#p_HBvo4vBdkM" tabindex="-1" role="presentation"></a><code>querySelectorAll</code> 메서드는 <code>document</code> 객체와 요소 노드 상에서 정의되는데, 선택 문자열을 사용하고, 일치하는 모든 요소를 모두 포함하는 <code>NodeList</code>를 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_yJ0zujW+YH" href="#c_yJ0zujW+YH" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>And if you go chasing
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">&quot;animal&quot;</span><span class="cm-tag cm-bracket">&gt;</span>rabbits<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>And you know you're going to fall<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Tell 'em a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">&quot;character&quot;</span><span class="cm-tag cm-bracket">&gt;</span>hookah smoking
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span> <span class="cm-attribute">class</span>=<span class="cm-string">&quot;animal&quot;</span><span class="cm-tag cm-bracket">&gt;</span>caterpillar<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Has given you the call<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">count</span>(<span class="cm-def">selector</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-variable-2">selector</span>).<span class="cm-property">length</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">&quot;p&quot;</span>));           <span class="cm-comment">// All &lt;p&gt; elements</span>
  <span class="cm-comment">// → 4</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">&quot;.animal&quot;</span>));     <span class="cm-comment">// Class animal</span>
  <span class="cm-comment">// → 2</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">&quot;p .animal&quot;</span>));   <span class="cm-comment">// Animal inside of &lt;p&gt;</span>
  <span class="cm-comment">// → 2</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">count</span>(<span class="cm-string">&quot;p &gt; .animal&quot;</span>)); <span class="cm-comment">// Direct child of &lt;p&gt;</span>
  <span class="cm-comment">// → 1</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_VqdoUrLVMq" href="#p_VqdoUrLVMq" tabindex="-1" role="presentation"></a><code>getElementsByTagName</code>과 같은 메서드와는 다르게 <code>querySelectorAll</code>에 의해 반환되는 객체는 live가 아닙니다. 문서 변경 시에 변경할 수 없습니다. 실질적인 배열이 아니기 때문에 그것을 배열로 취급하고자 하면 <code>Array.from</code>을 호출해야 합니다.</p>

<p><a class="p_ident" id="p_SlkO7PnZLM" href="#p_SlkO7PnZLM" tabindex="-1" role="presentation"></a><code>querySelector</code> 메서드와 유사한 방식으로 작동합니다. 이것은 특정 단일 요소를 원하는 경우에 유용합니다. 일치하는 첫 번째 요소만 반환하거나 일치하는 요소가 없으면 null을 반환합니다.</p>

<h2 id="animation"><a class="h_ident" id="h_MAsyozbjjZ" href="#h_MAsyozbjjZ" tabindex="-1" role="presentation"></a>위치 지정 및 애니메이션</h2>

<p><a class="p_ident" id="p_6Fd+Oq3MzE" href="#p_6Fd+Oq3MzE" tabindex="-1" role="presentation"></a><code>position</code> 스타일 속성은 레이아웃에 영향을 미칩니다. 기본적으로 <code>static</code>의 값을 갖는데 그것은 문서의 정규 위치에 요소가 있음을 의미합니다. <code>relative</code>로 설정되는 경우에 요소는 문서에서 공간을 차지하지만, <code>top</code>과 <code>left</code> 스타일 속성을 사용하여 상대적인 이동을 할 수 있습니다. <code>position</code>이 <code>absolute</code>로 설정되면, 요소는 정규 문서에서 제거됩니다. 즉, 더 이상 공간을 차지하지 않고 다른 요소와 중첩될 수 있습니다. 또한 그것의 <code>top</code>과 <code>left</code> 속성은 <code>position</code> 속성이 <code>static</code>이 아니거나 또는 이러한 닫힌 요소가 존재하지 않은 경우에 문서에서 상대적으로 최근접 닫힌 요소의 상단 좌측 코너로 이동시키는데 사용될 수 있습니다.</p>

<p><a class="p_ident" id="p_TEJWNXCk6K" href="#p_TEJWNXCk6K" tabindex="-1" role="presentation"></a>이를 통해 애니메이션을 만들 수 있습니다. 다음 문서는 타원에서 움직이는 고양이 사진을 표시합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_SCZYa8azNm" href="#c_SCZYa8azNm" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;text-align: center&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/cat.png&quot;</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;position: relative&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">cat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;img&quot;</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">animate</span>(<span class="cm-def">time</span>, <span class="cm-def">lastTime</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) {
      <span class="cm-variable">angle</span> <span class="cm-operator">+=</span> (<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable-2">lastTime</span>) <span class="cm-operator">*</span> <span class="cm-number">0.001</span>;
    }
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">20</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">200</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-def">newTime</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">animate</span>(<span class="cm-variable-2">newTime</span>, <span class="cm-variable-2">time</span>));
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">animate</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_1j1D9J1YQt" href="#p_1j1D9J1YQt" tabindex="-1" role="presentation"></a>그림은 페이지 중앙에서 상대적인 위치로 주어집니다. 그러한 이동을 위해 사진의 <code>top</code>과 <code>left</code> 스타일을 반복적으로 갱신합니다.</p>

<p id="animationFrame"><a class="p_ident" id="p_YWJ84IIJ5r" href="#p_YWJ84IIJ5r" tabindex="-1" role="presentation"></a>스크립트는 브라우저가 화면을 다시 그릴 준비가 될 때마다 <code>animate</code> 함수가 실행되도록 <code>requestAnimationFrame</code>을 사용합니다. <code>animate</code> 함수는 다시 다음 업데이트를 예약하기 위해 <code>requestAnimationFrame</code>을 호출합니다. 브라우저 창(또는 탭)이 활성화되면 초당 약 60개의 속도로 업데이트가 발생하여 보기 좋은 애니메이션을 생성하는 경향이 있습니다.</p>

<p><a class="p_ident" id="p_V1ZyP92HDo" href="#p_V1ZyP92HDo" tabindex="-1" role="presentation"></a>루프에서 DOM을 업데이트하면 페이지가 정지되고 화면에 아무 것도 표시되지 않습니다. 브라우저는 JavaScript 프로그램이 실행되는 동안 디스플레이를 업데이트하지 않으며 페이지와의 상호 작용을 허용하지 않습니다. 이것이 <code>requestAnimationFrame</code>가 필요한 이유입니다. 브라우저가 이제 작업이 완료되었음을 알리고 화면 업데이트 및 사용자 작업에 응답하는 것과 같이 브라우저가 수행하는 작업을 계속 진행할 수 있습니다.</p>

<p><a class="p_ident" id="p_T1Drg7jSr7" href="#p_T1Drg7jSr7" tabindex="-1" role="presentation"></a>애니메이션 함수는 현재 시간을 인수로 전달합니다. 밀리초당 고양이의 움직임이 안정적인지 확인하기 위해 현재 시간과 함수가 마지막으로 실행된 시간 간의 차이에 따라 각도가 변경되는 속도를 기반으로 합니다. 단계당 고정된 양만큼 각도를 이동한 경우, 예를 들어 동일한 컴퓨터에서 실행되는 또 다른 무거운 작업이 기능이 1초 미만 동안 실행되는 것을 방지하는 경우 모션이 더듬거릴 것입니다.</p>

<p id="sin_cos"><a class="p_ident" id="p_C8QAvF7kWm" href="#p_C8QAvF7kWm" tabindex="-1" role="presentation"></a>원의 이동은 삼각법 함수 <code>Math.cos</code>와 <code>Math.sin</code>을 사용하여 수행됩니다.</p>

<p><a class="p_ident" id="p_fz9+cW0plg" href="#p_fz9+cW0plg" tabindex="-1" role="presentation"></a><code>Math.cos</code>와 <code>Math.sin</code>은 원점을 중심으로 하나의 반경을 갖는 원에 위치한 점을 찾는데 유용합니다. 두 함수 모두 해당 인수를 이 원의 위치로 해석하며, 0은 원의 맨 오른쪽에 있는 점을 나타내며 시계 방향으로 2π(대략 6.28)가 전체 원 주위를 돌도록 합니다. <code>Math.cos</code>은 주어진 위치에 해당하는 점의 x 좌표를 알려주고 <code>Math.sin</code>은 y 좌표를 산출합니다. 0보다 작거나 2π보다 큰 위치(또는 각) 또한 유효합니다.</p>

<p><a class="p_ident" id="p_0LZN4Lli69" href="#p_0LZN4Lli69" tabindex="-1" role="presentation"></a>각도를 측정하는 이 단위를 라디안이라고 합니다. 전체 원은 2π 라디안이며 도 단위로 측정할 때 360도인 것과 유사합니다. 상수 π는 JavaScript에서 <code>Math.PI</code>와 같이 사용할 수 있습니다.</p><figure><img src="img/cos_sin.svg" alt="Using cosine and sine to compute coordinates"></figure>

<p><a class="p_ident" id="p_9ovGFCxRhX" href="#p_9ovGFCxRhX" tabindex="-1" role="presentation"></a>고양이 애니메이션 코드는 애니메이션의 현재 각 및 증가와 관련하여 카운터와 각을 유지하여 <code>animate</code> 함수가 호출될 때마다 증가시킵니다. 이 각도를 사용하여 이미지 요소의 현재 위치를 계산할 수 있습니다. <code>top</code> 스타일은 <code>Math.sin</code>로 계산되고 20을 곱하는데, 그것은 타원의 수직 반경입니다. <code>left</code> 스타일은 <code>Math.cos</code>을 바탕으로 하고 200을 곱해 타원이 높이보다 더 넓어지도록 합니다.</p>

<p><a class="p_ident" id="p_/Yly9Ir9QF" href="#p_/Yly9Ir9QF" tabindex="-1" role="presentation"></a>스타일은 일반적으로 단위를 필요로 합니다. 이 경우에 <code>&quot;px&quot;</code>를 사용해서 브라우저에게 이 단위를 사용하고 있음을 알립니다(centimeters를 나타내는 "ems" 또는 다른 단위도 가능). 단위 없이 숫자를 사용하면 스타일이 무시됩니다.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_kLcHWntN1r" href="#p_kLcHWntN1r" tabindex="-1" role="presentation"></a>JavaScript 프로그램은 DOM이라는 데이터 구조를 통해 브라우저가 표시하는 문서를 검사하고 방해할 수 있습니다. 이 데이터 구조는 문서의 브라우저 모델을 나타내며 JavaScript 프로그램은 이를 수정하여 보이는 문서를 변경할 수 있습니다.</p>

<p><a class="p_ident" id="p_7Ce58FA9bp" href="#p_7Ce58FA9bp" tabindex="-1" role="presentation"></a>DOM은 문서의 구조에 따라 요소가 계층적으로 배열된 트리처럼 구성됩니다. 요소를 나타내는 객체에는 이 트리를 탐색하는데 사용할 수 있는 <code>parentNode</code> 및 <code>childNodes</code>와 같은 속성이 있습니다.</p>

<p><a class="p_ident" id="p_KUJGKqAvJC" href="#p_KUJGKqAvJC" tabindex="-1" role="presentation"></a>문서가 표시되는 방식은 <em>styling</em>에 의해 영향을 받을 수 있습니다. 모두 직접 노드 스타일을 부착하여 특정 노드와 일치하는 규칙을 정의합니다. <code>color</code> 또는 <code>display</code>과 같은 다양한 스타일 속성이 있습니다. JavaScript 코드는 <code>style</code> 속성을 통해 직접 요소의 스타일을 조작할 수 있습니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3 id="exercise_table"><a class="i_ident" id="i_g/5UC3zznV" href="#i_g/5UC3zznV" tabindex="-1" role="presentation"></a>표 만들기</h3>

<p><a class="p_ident" id="p_LuZsMlc8YJ" href="#p_LuZsMlc8YJ" tabindex="-1" role="presentation"></a>HTML 테이블은 다음 태그 구조로 작성됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_MudCG4cYiG" href="#c_MudCG4cYiG" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">table</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>name<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>height<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>place<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">th</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>Kilimanjaro<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>5895<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>Tanzania<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">td</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">tr</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">table</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_xvnLvuqcz5" href="#p_xvnLvuqcz5" tabindex="-1" role="presentation"></a>각 행에 관해 <code>&lt;table&gt;</code> 태그는 <code>&lt;tr&gt;</code> 태그를 가집니다. 이러한 <code>&lt;tr&gt;</code> 태그 내부에 제목 셀 (<code>&lt;th&gt;</code>) 또는 일반 셀 (<code>&lt;td&gt;</code>)와 같은 셀 요소들을 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_Kz26QB0sIU" href="#p_Kz26QB0sIU" tabindex="-1" role="presentation"></a>산에 관한 데이터 집합이 주어졌을 때, <code>name</code>, <code>height</code> 및 <code>place</code> 속성들을 갖는 객체들의 배열은 객체들을 헤아리는 표에 관한 DOM 구조를 생성합니다. 키당 하나의 열과 객체당 하나의 행이외 열 이름들의 열거 관련 상단에 <code>&lt;th&gt;</code>를 갖는 제목 행이 필요합니다.</p>

<p><a class="p_ident" id="p_mmjekKHDOX" href="#p_mmjekKHDOX" tabindex="-1" role="presentation"></a>데이터에서 첫 번째 객체의 속성 이름을 사용하여 열이 객체에서 자동으로 파생되도록 이것을 작성합니다.</p>

<p><a class="p_ident" id="p_EvtDcsiT4c" href="#p_EvtDcsiT4c" tabindex="-1" role="presentation"></a>결과 표에 <code>&quot;mountains&quot;</code>의 <code>id</code> 속성을 갖는 요소를 추가하여 문서에서 표가 가시적이도록 합니다.</p>

<p><a class="p_ident" id="p_Ve9FRgVfit" href="#p_Ve9FRgVfit" tabindex="-1" role="presentation"></a>이 작업이 완료되면 <code>style.textAlign</code> 속성을 <code>&quot;right&quot;</code>로 설정하여 숫자 값이 포함된 셀을 오른쪽 정렬합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_SaASguUQJh" href="#c_SaASguUQJh" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>Mountains<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;mountains&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">const</span> <span class="cm-def">MOUNTAINS</span> <span class="cm-operator">=</span> [
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Kilimanjaro&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">5895</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Tanzania&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Everest&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">8848</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Nepal&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Mount Fuji&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">3776</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Japan&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Vaalserberg&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">323</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Netherlands&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Denali&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">6168</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;United States&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Popocatepetl&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">5465</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Mexico&quot;</span>},
    {<span class="cm-property">name</span>: <span class="cm-string">&quot;Mont Blanc&quot;</span>, <span class="cm-property">height</span>: <span class="cm-number">4808</span>, <span class="cm-property">place</span>: <span class="cm-string">&quot;Italy/France&quot;</span>}
  ];

  <span class="cm-comment">// 여기에 코드 작성</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_2Q6e2rAy5t" href="#p_2Q6e2rAy5t" tabindex="-1" role="presentation"></a><code>document.<wbr>createElement</code>를 사용하여 텍스트 노드 생성을 위해 새 요소 노드 <code>document.<wbr>createTextNode</code>를 생성하고, 노드를 다른 노드에 배치하는 <code>appendChild</code> 메서드를 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_BD8axR6MPn" href="#p_BD8axR6MPn" tabindex="-1" role="presentation"></a>키 이름을 한 번 반복하여 맨 위 행을 채우고 배열의 각 객체에 대해 다시 반복하여 데이터 행을 구성할 수 있습니다. 첫 번째 객체에서 키 이름의 배열을 얻으려면 <code>Object.keys</code>가 유용할 것입니다.</p>

<p><a class="p_ident" id="p_f4AX6Lsiww" href="#p_f4AX6Lsiww" tabindex="-1" role="presentation"></a>올바른 부모 노드에 테이블을 추가하려면 <code>document.<wbr>getElementById</code> 또는 <code>document.<wbr>querySelector</code>를 사용하여 적절한 <code>id</code> 속성이 있는 노드를 찾을 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_VSftnyRTsV" href="#i_VSftnyRTsV" tabindex="-1" role="presentation"></a>태그 이름별 요소</h3>

<p><a class="p_ident" id="p_QviMLCSPLN" href="#p_QviMLCSPLN" tabindex="-1" role="presentation"></a><code>document.<wbr>getElementsByTagName</code> 메서드는 지정된 태그 이름을 가진 모든 자식 요소를 반환합니다. 노드와 문자열(태그 이름)을 인수로 사용하고 주어진 태그 이름을 가진 모든 하위 요소 노드를 포함하는 배열을 반환하는 함수로 이것의 고유한 버전을 구현하십시오.</p>

<p><a class="p_ident" id="p_F3uW/zaQpy" href="#p_F3uW/zaQpy" tabindex="-1" role="presentation"></a>요소의 태그 이름을 찾으려면 해당 <code>nodeName</code> 속성을 사용하십시오. 그러나 이렇게 하면 태그 이름이 모두 대문자로 반환됩니다. 이를 보완하려면 <code>toLowerCase</code> 또는 <code>toUpperCase</code> 메서드를 사용하십시오.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_SHm9FthIXO" href="#c_SHm9FthIXO" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>Heading with a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>span<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span> element.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">h1</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>A paragraph with <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>one<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>, <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">span</span><span class="cm-tag cm-bracket">&gt;</span>
  spans.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">byTagName</span>(<span class="cm-def">node</span>, <span class="cm-def">tagName</span>) {
    <span class="cm-comment">// Your code here.</span>
  }

  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">&quot;h1&quot;</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 1</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-string">&quot;span&quot;</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 3</span>
  <span class="cm-keyword">let</span> <span class="cm-def">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;p&quot;</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byTagName</span>(<span class="cm-variable">para</span>, <span class="cm-string">&quot;span&quot;</span>).<span class="cm-property">length</span>);
  <span class="cm-comment">// → 2</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_M6sxoq7K9N" href="#p_M6sxoq7K9N" tabindex="-1" role="presentation"></a>해는 순환 함수로 아주 쉽게 표현됩니다(<a href="14_dom.html#talksAbout"><code>talksAbout</code> 함수</a>와 유사하게).</p>

<p><a class="p_ident" id="p_g/fG/I+qTc" href="#p_g/fG/I+qTc" tabindex="-1" role="presentation"></a><code>byTagname</code>을 재귀적으로 호출하여 결과 배열을 연결하여 출력을 생성할 수 있습니다. 또는 자신을 재귀적으로 호출하고 찾은 일치 요소를 추가할 수 있는 외부 함수에 정의된 배열 바인딩에 액세스할 수 있는 내부 함수를 만들 수 있습니다. 프로세스를 시작하기 위해 외부 함수에서 내부 함수를 한 번 호출하는 것을 잊지 마십시오.</p>

<p><a class="p_ident" id="p_Zi3ayOqWyD" href="#p_Zi3ayOqWyD" tabindex="-1" role="presentation"></a>재귀 함수는 노드 타입을 확인해야 합니다. 여기서는 노드 타입 1(<code>Node.<wbr>ELEMENT_NODE</code>)에만 관심이 있습니다. 그러한 노드의 경우, 그것들의 자식을 반복해야 하고, 각 자식에 대해 자식이 쿼리와 일치하는지 확인하는 동시에 자신의 자식을 검사하기 위해 재귀 호출을 수행해야 합니다.</p>

</div></div>

<h3><a class="i_ident" id="i_b/LAqZUqyo" href="#i_b/LAqZUqyo" tabindex="-1" role="presentation"></a>고양이 모자</h3>

<p><a class="p_ident" id="p_6r1baDVOSE" href="#p_6r1baDVOSE" tabindex="-1" role="presentation"></a>앞서 정의한 고양이 애니메이션을 확장하여 고양이와 그것의 모자(<code>&lt;img src=&quot;img/<wbr>hat.<wbr>png&quot;&gt;</code>)가 모두 타원의 반대쪽에서 회전하도록 합니다.</p>

<p><a class="p_ident" id="p_VqdQKV2uH0" href="#p_VqdQKV2uH0" tabindex="-1" role="presentation"></a>또는 모자가 고양이 주위를 도도록 만드십시오. 또는 다른 흥미로운 방식으로 애니메이션을 변경합니다.</p>

<p><a class="p_ident" id="p_3jJ377egS/" href="#p_3jJ377egS/" tabindex="-1" role="presentation"></a>여러 객체의 위치를 쉽게 지정하려면 절대 위치로 전환하는 것이 좋습니다. 이는 문서의 왼쪽 상단을 기준으로 <code>top</code> 및d <code>left</code>가 계산됨을 의미합니다. 이미지가 보이는 페이지 외부로 이동하게 하는 음수 좌표를 사용하지 않으려면 고정된 수의 픽셀을 위치 값에 추가할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_h3Gqsempqw" href="#c_h3Gqsempqw" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag">body</span> { <span class="cm-property">min-height</span>: <span class="cm-number">200px</span> }<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/cat.png&quot;</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;cat&quot;</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;position: absolute&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">img</span> <span class="cm-attribute">src</span>=<span class="cm-string">&quot;img/hat.png&quot;</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;hat&quot;</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;position: absolute&quot;</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">cat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;#cat&quot;</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">hat</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;#hat&quot;</span>);

  <span class="cm-keyword">let</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">animate</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-variable">angle</span> <span class="cm-operator">+=</span> (<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable">lastTime</span>) <span class="cm-operator">*</span> <span class="cm-number">0.001</span>;
    <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">40</span> <span class="cm-operator">+</span> <span class="cm-number">40</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
    <span class="cm-variable">cat</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">angle</span>) <span class="cm-operator">*</span> <span class="cm-number">200</span> <span class="cm-operator">+</span> <span class="cm-number">230</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;

    <span class="cm-comment">// 여기에 확장 코드 작성</span>

    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">animate</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">animate</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_g8VVOKD2zX" href="#p_g8VVOKD2zX" tabindex="-1" role="presentation"></a><code>Math.cos</code>과 <code>Math.sin</code>은 라디안으로 각을 측정합니다. 여기서 완전 원은 2π입니다. 주어진 원에 관해 이것의 절반을 추가하여 반대 각을 얻을 수 있습니다(그것은 <code>Math.PI</code>). 이것은 궤도의 반대쪽에 모자를 놓을 때 유용할 수 있습니다.</p>

</div></div><nav><a href="13_browser.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="15_event.html" title="next chapter">▶</a></nav>
</article>
