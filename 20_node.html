<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Node.js</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 20;</script></head>

<article>
<nav><a href="19_paint.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="21_skillsharing.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>20</span>Node.js</h1>

<blockquote>

<p><a class="p_ident" id="p_dL3PxXkk30" href="#p_dL3PxXkk30" tabindex="-1" role="presentation"></a>한 학생이 다음과 같이 질문합니다. '옛날 프로그래머는 프로그래밍 언어를 사용하지 않고 단순한 기계만 사용했지만 아름다운 프로그램을 만들었습니다. 왜 복잡한 기계와 프로그래밍 언어를 사용합니까?'. Fu-Tzu가 대답했습니다. '고대 건축자들은 막대기와 진흙만 사용했지만 아름다운 오두막을 만들었습니다.'</p>

<footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_20.jpg" alt="Picture of a telephone pole"></figure>

<p><a class="p_ident" id="p_4oqrrNIihE" href="#p_4oqrrNIihE" tabindex="-1" role="presentation"></a>지금까지 브라우저라는 단일 환경에서 JavaScript 언어를 사용했습니다. 이 페이지와 다음 페이지에서는 브라우저 외부에서 JavaScript 기술을 적용할 수 있는 프로그램인 Node.js를 간략하게 소개합니다. 이를 통해 명령 라인 도구에서 동적 웹 사이트를 지원하는 HTTP 서버에 이르기까지 무엇이든 구축할 수 있습니다.</p>

<p><a class="p_ident" id="p_dkSo8b0Hlh" href="#p_dkSo8b0Hlh" tabindex="-1" role="presentation"></a>이들 페이지들은 Node.js가 사용하는 주요 개념을 가르치고 유용한 프로그램을 작성하기에 충분한 정보를 제공하는 것을 목표로 합니다. 그것들은 플랫폼을 완전하거나 철저하게 다루려고 하지 않습니다.</p>

<p><a class="p_ident" id="p_NM5XbgzOCu" href="#p_NM5XbgzOCu" tabindex="-1" role="presentation"></a>앞 페이지들의 코드들은 페이지에서 직접 실행할 수 있었던 반면에 이 페이지의 코드 샘플은 원시 JavaScript이거나 브라우저용으로 작성되었기 때문에 종종 브라우저에서 실행되지 않습니다.</p>

<p><a class="p_ident" id="p_yDXmkj8agX" href="#p_yDXmkj8agX" tabindex="-1" role="presentation"></a>이 페이지의 코드를 따라 실행하려면 Node.js 버전 10.1 이상을 설치해야 합니다. 그렇게 하려면 <a href="https://nodejs.org"><em>https://nodejs.org</em></a>로 이동하여 운영 체제에 대한 설치 지침을 따르십시오. 거기에서 Node.js에 대한 추가 문서를 찾을 수 있습니다.</p>

<h2><a class="h_ident" id="h_ZN1g/hoEn+" href="#h_ZN1g/hoEn+" tabindex="-1" role="presentation"></a>배경</h2>

<p><a class="p_ident" id="p_I4yhs5+yBu" href="#p_I4yhs5+yBu" tabindex="-1" role="presentation"></a>네트워크를 통해 통신하는 writing 시스템의 보다 어려운 문제 중 하나는 입력과 출력을 관리하는 것입니다. 즉, 네트워크와 하드 드라이브에서 데이터를 읽고 쓰는 것입니다. 데이터를 이리저리 옮기는 데는 시간이 걸리며 현명하게 스케줄링 하면 시스템이 사용자나 네트워크 요청에 응답하는 속도가 크게 달라질 수 있습니다.</p>

<p><a class="p_ident" id="p_MBm9R7gzIJ" href="#p_MBm9R7gzIJ" tabindex="-1" role="presentation"></a>이러한 프로그램에서 비동기 프로그래밍은 종종 도움이 됩니다. 이를 통해 프로그램은 복잡한 스레드 관리 및 동기화 없이 동시에 여러 장치와 데이터를 주고받을 수 있습니다.</p>

<p><a class="p_ident" id="p_RCasOwXmol" href="#p_RCasOwXmol" tabindex="-1" role="presentation"></a>Node는 처음에 비동기 프로그래밍을 쉽고 편리하게 만들기 위해 고안되었습니다. JavaScript는 Node.js와 같은 시스템에 적합합니다. 입력 및 출력을 수행하는 내장된 메서드가 없는 몇 안 되는 프로그래밍 언어 중 하나입니다. 따라서 JavaScript는 두 개의 일관되지 않은 인터페이스로 끝나지 않고 입출력에 대한 Node의 다소 편심한 접근 방식에 적합할 수 있습니다. 2009년 Node를 설계할 당시 사람들은 이미 브라우저에서 콜백 기반 프로그래밍을 하고 있었기 때문에 해당 언어를 둘러싼 커뮤니티는 비동기 프로그래밍 스타일에 익숙해졌습니다.</p>

<h2><a class="h_ident" id="h_TUzbi7lU/0" href="#h_TUzbi7lU/0" tabindex="-1" role="presentation"></a>node 명령</h2>

<p><a class="p_ident" id="p_rE0vPeaAdk" href="#p_rE0vPeaAdk" tabindex="-1" role="presentation"></a>Node.js가 시스템에 설치되면 JavaScript 파일을 실행하는데 사용되는 <code>node</code>라는 프로그램을 제공됩니다. 다음 코드가 포함된 <code>hello.js</code>라는 파일을 가정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Ys/5/PYPJK" href="#c_Ys/5/PYPJK" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">message</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Hello world&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">message</span>);</pre>

<p><a class="p_ident" id="p_4LYXmSusTq" href="#p_4LYXmSusTq" tabindex="-1" role="presentation"></a>프로그램 실행을 위해 다음과 같은 <code>node</code>를 명령 라인에서 실행합니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_+NijqTTZNf" href="#c_+NijqTTZNf" tabindex="-1" role="presentation"></a>$ node hello.js
Hello world</pre>

<p><a class="p_ident" id="p_eFRb1edk0V" href="#p_eFRb1edk0V" tabindex="-1" role="presentation"></a>Node에서 <code>console.log</code> 메서드는 브라우저에서와 유사합니다. 텍스트 부분을 출력하지만, Node에서 텍스트는브라우저의 JS 콘솔이 아닌 프로세스의 표준 출력 스트림으로 이동합니다. 명령 라인에서 <code>node</code> 실행은 터미널에서 로깅 값을 볼 수 있도록 합니다.</p>

<p><a class="p_ident" id="p_TwZ26izezw" href="#p_TwZ26izezw" tabindex="-1" role="presentation"></a>파일 제공이 없이 <code>node</code>를 수행하면, JavaScript 코드를 입력해서 결과를 즉시 볼 수 있는 신호가 제공됩니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_d/9k6S5oD+" href="#c_d/9k6S5oD+" tabindex="-1" role="presentation"></a>$ node
&gt; 1 + 1
2
&gt; [-1, -2, -3].map(Math.abs)
[1, 2, 3]
&gt; process.exit(0)
$</pre>

<p><a class="p_ident" id="p_gu0HNk/tPj" href="#p_gu0HNk/tPj" tabindex="-1" role="presentation"></a><code>console</code> 결합처럼 <code>process</code> 결합은 Node에서 전역적으로 이용 가능합니다. 현재 프로그램을 검사하고 처리하는 여러 방식을 제공합니다. <code>exit</code> 메서드는 프로세스를 종료하고 빠져 나가기 상태 코드를 제공합니다. 그것은 <code>node</code>를 시작했던 프로그램이 성공적으로 수행되었는지(코드 0) 또는 에러를 가졌는지(어떠한 다른 코드)를 나타냅니다.</p>

<p><a class="p_ident" id="p_r76dNN6hR1" href="#p_r76dNN6hR1" tabindex="-1" role="presentation"></a>스크립트에 지정된 명령 라인 인수를 찾으려면 문자열 배열인 <code>process.argv</code>를 읽을 수 있습니다. 여기에는 <code>node</code> 명령 이름과 스크립트 이름도 포함되어 있습니다. 실제 인수는 인덱스 2에서 시작합니다. <code>showargv.js</code>에 명령문 <code>console.<wbr>log(process.<wbr>argv)</code>이 포함되어 있으면 다음과 같이 실행할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_WCisDZr57g" href="#c_WCisDZr57g" tabindex="-1" role="presentation"></a>$ node showargv.js one --and two
[&quot;node&quot;, &quot;/tmp/showargv.js&quot;, &quot;one&quot;, &quot;--and&quot;, &quot;two&quot;]</pre>

<p><a class="p_ident" id="p_ols5jgMHp4" href="#p_ols5jgMHp4" tabindex="-1" role="presentation"></a><code>Array</code>, <code>Math</code> 및 <code>JSON</code>과 같은 모든 표준 JavaScript 전역 결합 또한 Node의 환경에 있습니다. <code>document</code> 또는 <code>prompt</code>와 같은 브라우저 관련 기능은 그렇지 않습니다.</p>

<h2><a class="h_ident" id="h_BOlGLA/wK7" href="#h_BOlGLA/wK7" tabindex="-1" role="presentation"></a>모듈</h2>

<p><a class="p_ident" id="p_7uiDKmOxBC" href="#p_7uiDKmOxBC" tabindex="-1" role="presentation"></a><code>console</code> 및 <code>process</code>와 같은 결합 이외에 Node는 전역 범위에 추가 바인딩을 거의 넣지 않습니다. 내장 기능에 액세스하려면 모듈 시스템에 요청해야 합니다.</p>

<p><a class="p_ident" id="p_KyUqoANKU6" href="#p_KyUqoANKU6" tabindex="-1" role="presentation"></a><code>require</code> 함수를 기반으로 하는 CommonJS 모듈 시스템은 10장에서 설명했다. 이 시스템은 Node에 내장되어 있으며 내장 모듈에서 다운로드 한 패키지, 자체 프로그램의 일부인 파일에 이르기까지 모든 것을 로드하는 데 사용됩니다.</p>

<p><a class="p_ident" id="p_/PFjIKtmrf" href="#p_/PFjIKtmrf" tabindex="-1" role="presentation"></a><code>require</code>가 호출되는 경우 Node는 로드 할 수 있는 실제 파일로 지정된 문자열을 처리해야 합니다. <code>/</code>, <code>./</code> 또는 <code>../</code>로 시작하는 경로는 현재 모듈의 상대적 경로를 나타냅니다. 여기서 <code>.</code>는 현재 디렉토리를 의미하고, <code>/</code>는 파일 시스템의 루트를 나타냅니다. 따라서 파일 <code>/<wbr>tmp/<wbr>robot/<wbr>robot.<wbr>js</code>로부터 <code>&quot;./<wbr>graph&quot;</code>를 요청하면, Node는 <code>/<wbr>tmp/<wbr>robot/<wbr>graph.<wbr>js</code> 파일을 로드하려고 합니다.</p>

<p><a class="p_ident" id="p_5Uhl44wvon" href="#p_5Uhl44wvon" tabindex="-1" role="presentation"></a><code>.js</code> 확장은 생략될 수 있으며, 이러한 파일이 존재하는 경우 Node는 그것을 추가합니다. 필요한 경로가 디렉토리를 참조하는 경우 Node는 해당 디렉토리에서 이름이 <code>index.js</code>로 지정된 파일을 로드하려고 시도합니다.</p>

<p><a class="p_ident" id="p_Jbv0K2DaVF" href="#p_Jbv0K2DaVF" tabindex="-1" role="presentation"></a>상대 또는 절대 경로처럼 보이지 않는 문자열이 <code>require</code>에 주어졌을때 내장 모듈 또는 <code>node_modules</code> 디렉토리에 설치된 모듈을 참조하는 것으로 가정합니다. 예를 들어, <code>require(&quot;fs&quot;)</code>는 Node의 내장 파일 시스템 모듈을 제공합니다. 그리고, <code>require(&quot;robot&quot;)</code>는 <code>node_modules/<wbr>robot/<wbr></code>에 있는 라이브러리를 로드하려고 할 수도 있습니다. 이러한 라이브러리를 설치하는 일반적인 방법은 NPM을 사용하는 것입니다. NPM은 나중에 다시 설명하겠습니다.</p>

<p><a class="p_ident" id="p_nVdHCtPw94" href="#p_nVdHCtPw94" tabindex="-1" role="presentation"></a>두 개의 파일로 구성된 작은 프로젝트를 설정해 보겠습니다. <code>main.js</code>라는 첫 번째 스크립트는 문자열을 뒤집기 위해 명령줄에서 호출할 수 있는 스크립트를 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P0yKauuaN8" href="#c_P0yKauuaN8" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">reverse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;./reverse&quot;</span>);

<span class="cm-comment">// Index 2 holds the first actual command line argument</span>
<span class="cm-keyword">let</span> <span class="cm-def">argument</span> <span class="cm-operator">=</span> <span class="cm-variable">process</span>.<span class="cm-property">argv</span>[<span class="cm-number">2</span>];

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverse</span>(<span class="cm-variable">argument</span>));</pre>

<p><a class="p_ident" id="p_4ZPnC8Ok8r" href="#p_4ZPnC8Ok8r" tabindex="-1" role="presentation"></a>파일 <code>reverse.js</code>는 명령 라인 도구와 문자열 반전 기능에 직접 접근해야 하는 다른 스크립트 모두에서 사용할 수 있는 문자열 반전을 위한 라이브러리를 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xPNlH3e9Ye" href="#c_xPNlH3e9Ye" tabindex="-1" role="presentation"></a><span class="cm-variable">exports</span>.<span class="cm-property">reverse</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable-2">string</span>).<span class="cm-property">reverse</span>().<span class="cm-property">join</span>(<span class="cm-string">&quot;&quot;</span>);
};</pre>

<p><a class="p_ident" id="p_cz8b+bxuQd" href="#p_cz8b+bxuQd" tabindex="-1" role="presentation"></a><code>exports</code> 속성을 추가하면 모듈의 인터페이스에 그것들이 추가된다는 점을 기억하십시오. Node.js는 파일을 CommonJS 모듈로 취급하므로 <code>main.js</code>는 내보내진 <code>reverse</code> 함수를 <code>reverse.js</code>로부터 취합니다.</p>

<p><a class="p_ident" id="p_S/nc4v84fJ" href="#p_S/nc4v84fJ" tabindex="-1" role="presentation"></a>이제 다음과 같이 도구를 호출할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_k81NC+cAsi" href="#c_k81NC+cAsi" tabindex="-1" role="presentation"></a>$ node main.js JavaScript
tpircSavaJ</pre>

<h2><a class="h_ident" id="h_J6hW/SmL/a" href="#h_J6hW/SmL/a" tabindex="-1" role="presentation"></a>NPM을 사용한 설치</h2>

<p><a class="p_ident" id="p_vdquK0d/vZ" href="#p_vdquK0d/vZ" tabindex="-1" role="presentation"></a>10장에서 소개된 NPM은 JavaScript 모듈의 온라인 저장소이며, 그 중 많은 부분이 Node.js용으로 특별히 작성되었습니다. 컴퓨터에 Node를 설치하면 이 리포지토리와 상호 작용하는데 사용할 수 있는 <code>npm</code> 명령도 제공됩니다.</p>

<p><a class="p_ident" id="p_S050oa0uFn" href="#p_S050oa0uFn" tabindex="-1" role="presentation"></a>NPM의 주요 용도는 패키지를 다운로드 하는 것입니다. 10장에서 <code>ini</code> 패키지를 소개했습니다. NPM을 사용하여 해당 패키지를 컴퓨터에 가져와 설치할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_BggMWensXe" href="#c_BggMWensXe" tabindex="-1" role="presentation"></a>$ npm install ini
npm WARN enoent ENOENT: no such file or directory,
         open '/tmp/package.json'
+ ini@1.3.5
added 1 package in 0.552s

$ node
&gt; const {parse} = require(&quot;ini&quot;);
&gt; parse(&quot;x = 1\ny = 2&quot;);
{ x: '1', y: '2' }</pre>

<p><a class="p_ident" id="p_NBQHpDdZuw" href="#p_NBQHpDdZuw" tabindex="-1" role="presentation"></a><code>npm install</code> 수행 후에 NPM은 <code>node_modules</code>라는 디렉토리를 생성할 것입니다. 그 디렉토리 안에는 라이브러리를 포함하는 <code>ini</code> 디렉토리가 있을 것입니다. 열어서 코드를 볼 수 있습니다. <code>require(&quot;ini&quot;)</code>를 호출하면 이 라이브러리가 로드되고 해당 <code>parse</code> 속성을 호출하여 구성 파일을 구문 분석할 수 있습니다.</p>

<p><a class="p_ident" id="p_sKeXO3qL6G" href="#p_sKeXO3qL6G" tabindex="-1" role="presentation"></a>기본적으로 NPM은 중앙 위치가 아닌 현재 디렉토리 아래에 패키지를 설치합니다. 다른 패키지 관리자에 익숙하다면 이 방법이 이상하게 보일 수 있지만 장점이 있습니다. 각 응용 프로그램이 설치하는 패키지를 완전히 제어할 수 있고 응용 프로그램을 제거할 때 버전을 관리하고 정리하기가 더 쉬워집니다.</p>

<h3><a class="i_ident" id="i_IMZP7FN0pF" href="#i_IMZP7FN0pF" tabindex="-1" role="presentation"></a>Package 파일들</h3>

<p><a class="p_ident" id="p_efbbWPPNXQ" href="#p_efbbWPPNXQ" tabindex="-1" role="presentation"></a><code>npm install</code> 예에서 you could see a warning about the fact that the <code>package.json</code> 파일이 존재하지 않는다는 사실에 대한 경고를 볼 수 있습니다. 그것은 각 프로젝트에 관해 이러한 파일을 생성하는 것이 권고됩니다. 수동 또는 <code>npm init</code>를 사용할 수 있습니다. 이름, 버전 및 그것이 갖는 종속성에 관한 일부 정보들이 포함됩니다.</p>

<p><a class="p_ident" id="p_NT9giTr6Q2" href="#p_NT9giTr6Q2" tabindex="-1" role="presentation"></a>10장 연습 문제에서 모듈화된 7장의 로봇 시뮬레이션은 다음과 같은 <code>package.json</code> 파일을 가집니다.</p>

<pre class="snippet cm-s-default" data-language="application/json" ><a class="c_ident" id="c_K51zuXso4A" href="#c_K51zuXso4A" tabindex="-1" role="presentation"></a>{
  <span class="cm-string cm-property">&quot;author&quot;</span>: <span class="cm-string">&quot;Marijn Haverbeke&quot;</span>,
  <span class="cm-string cm-property">&quot;name&quot;</span>: <span class="cm-string">&quot;eloquent-javascript-robot&quot;</span>,
  <span class="cm-string cm-property">&quot;description&quot;</span>: <span class="cm-string">&quot;Simulation of a package-delivery robot&quot;</span>,
  <span class="cm-string cm-property">&quot;version&quot;</span>: <span class="cm-string">&quot;1.0.0&quot;</span>,
  <span class="cm-string cm-property">&quot;main&quot;</span>: <span class="cm-string">&quot;run.js&quot;</span>,
  <span class="cm-string cm-property">&quot;dependencies&quot;</span>: {
    <span class="cm-string cm-property">&quot;dijkstrajs&quot;</span>: <span class="cm-string">&quot;^1.0.1&quot;</span>,
    <span class="cm-string cm-property">&quot;random-item&quot;</span>: <span class="cm-string">&quot;^1.0.0&quot;</span>
  },
  <span class="cm-string cm-property">&quot;license&quot;</span>: <span class="cm-string">&quot;ISC&quot;</span>
}</pre>

<p><a class="p_ident" id="p_LA2QNdOUqm" href="#p_LA2QNdOUqm" tabindex="-1" role="presentation"></a>설치할 패키지 이름을 지정하지 않고 <code>npm install</code>을 수행하면, NPM은 <code>package.json</code>에 열거된 종속성들을 설치합니다. 종속성으로 열거되지 않은 특정 패키지를 설치하면, NPM은 그것을 <code>package.json</code>에 추가합니다.</p>

<h3><a class="i_ident" id="i_ojkQfvKPbv" href="#i_ojkQfvKPbv" tabindex="-1" role="presentation"></a>버전</h3>

<p><a class="p_ident" id="p_UrPIybyUA4" href="#p_UrPIybyUA4" tabindex="-1" role="presentation"></a><code>package.json</code> 파일은 프로그램 자체 버전과 그것이 갖는 종속성 관련 버전들을 열거합니다. 버전은 패키지가 개별적으로 발전한다는 사실을 처리하는 방법이며, 한 지점에서 존재하는 패키지와 함께 작동하도록 작성된 코드는 나중에 수정된 패키지 버전에서는 작동하지 않을 수 있습니다.</p>

<p><a class="p_ident" id="p_CvfHe7sDbQ" href="#p_CvfHe7sDbQ" tabindex="-1" role="presentation"></a>NPM은 패키지가 버전 번호에서 호환되는 (이전 인터페이스를 손상시키지 않음) 버전에 대한 일부 정보를 인코딩하는 <em>semantic versioning</em>이라는 스키마를 따르도록 요구합니다. 시맨틱 버전은 <code>2.3.0</code>와 같이 마침표로 구분된 세 개의 숫자로 구성됩니다. 새로운 기능이 추가될 때마다 중간 숫자가 증가해야 합니다. 호환성이 깨질 때마다 패키지를 사용하는 기존 코드가 새 버전에서 작동하지 않을 수 있으므로 첫 번째 숫자를 증가시켜야 합니다.</p>

<p><a class="p_ident" id="p_gTL1n2TLHm" href="#p_gTL1n2TLHm" tabindex="-1" role="presentation"></a><code>package.json</code>의 종속성 관련 버전 번호 앞에 caret 문자(<code>^</code>)는 지정된 번호와 호환되는 모든 버전이 설치될 수 있음을 나타냅니다. 따라서 예를 들어 <code>&quot;^2.<wbr>3.<wbr>0&quot;</code>은 2.3.0 이상 3.0.0 미만의 모든 버전이 허용된다는 의미입니다.</p>

<p><a class="p_ident" id="p_HcGcWqTR8/" href="#p_HcGcWqTR8/" tabindex="-1" role="presentation"></a><code>npm</code> 명령은 또한 새 패키지 또는 패키지의 새 버전을 게시하는 데 사용됩니다. <code>package.json</code>을 갖는 디렉터리에서 <code>npm publish</code>를 수행하면, JSON 파일에 나열된 이름과 버전이 있는 패키지를 레지스트리에 게시합니다. 누구든지 NPM에 패키지를 게시할 수 있습니다. 하지만 임의의 사람들이 기존 패키지를 업데이트할 수 있다면 다소 무섭기 때문에 아직 사용되지 않는 패키지 이름으로만 게시할 수 있습니다.</p>

<p><a class="p_ident" id="p_3Z1I+gjqS6" href="#p_3Z1I+gjqS6" tabindex="-1" role="presentation"></a><code>npm</code> 프로그램은 개방형 시스템(패키지 레지스트리)과 통신하는 소프트웨어이기 때문에 고유한 기능이 없습니다. NPM 레지스트리에서 설치할 수 있는 또 다른 프로그램인 <code>yarn</code>은 약간 다른 인터페이스 및 설치 전략을 사용하지만 <code>npm</code>과 동일한 역할을 수행합니다.</p>

<h2><a class="h_ident" id="h_o2abiQU0TD" href="#h_o2abiQU0TD" tabindex="-1" role="presentation"></a>파일 시스템 모듈</h2>

<p><a class="p_ident" id="p_HumHNRQKJx" href="#p_HumHNRQKJx" tabindex="-1" role="presentation"></a>Node에서 가장 일반적으로 사용되는 내장 모듈 중 하나는 파일 시스템을 나타내는 <code>fs</code>모듈입니다. 파일 및 디렉토리 작업을 위한 함수들을 내보냅니다.</p>

<p><a class="p_ident" id="p_75RFSIQwdU" href="#p_75RFSIQwdU" tabindex="-1" role="presentation"></a>예를 들어, 호출된 <code>readFile</code> 함수는 파일을 읽은 다음 파일 내용으로 콜백을 호출합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JolDdwagNc" href="#c_JolDdwagNc" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>, (<span class="cm-def">error</span>, <span class="cm-def">text</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>, <span class="cm-variable-2">text</span>);
});</pre>

<p><a class="p_ident" id="p_kiSsXyNElK" href="#p_kiSsXyNElK" tabindex="-1" role="presentation"></a><code>readFile</code>에서 두 번째 인수는 파일을 문자열로 디코딩하는데 사용되는 문자 인코딩을 나타냅니다. 텍스트를 이진 데이터로 인코딩하는 방법에는 여러 가지가 있지만 대부분의 최신 시스템은 <code>&quot;utf8&quot;</code>을 사용합니다. 따라서 다른 인코딩이 사용되었다고 믿을 만한 이유가 없는 한 텍스트 파일을 읽을 때 전달하십시오. 인코딩을 전달하지 않으면 Node는 이진 데이터에 관심이 있다고 가정하고 문자열 대신 <code>Buffer</code> 객체를 제공합니다. 이것은 파일의 바이트(8비트 데이터 청크)를 나타내는 숫자를 포함하는 배열과 유사한 객체입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_D3dLtJ/8n6" href="#c_D3dLtJ/8n6" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, (<span class="cm-def">error</span>, <span class="cm-def">buffer</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contained&quot;</span>, <span class="cm-variable-2">buffer</span>.<span class="cm-property">length</span>, <span class="cm-string">&quot;bytes.&quot;</span>,
              <span class="cm-string">&quot;The first byte is:&quot;</span>, <span class="cm-variable-2">buffer</span>[<span class="cm-number">0</span>]);
});</pre>

<p><a class="p_ident" id="p_2eNWgxdLGx" href="#p_2eNWgxdLGx" tabindex="-1" role="presentation"></a>유사 함수인 <code>writeFile</code>은 파일을 디스크에 쓰는데 사용됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_lbylD3zyw8" href="#c_lbylD3zyw8" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">writeFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">writeFile</span>(<span class="cm-string">&quot;graffiti.txt&quot;</span>, <span class="cm-string">&quot;Node was here&quot;</span>, <span class="cm-def">err</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">err</span>) <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Failed to write file: ${</span><span class="cm-variable-2">err</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-keyword">else</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;File written.&quot;</span>);
});</pre>

<p><a class="p_ident" id="p_rDd4gjDwV6" href="#p_rDd4gjDwV6" tabindex="-1" role="presentation"></a>여기서는 인코딩을 지정할 필요가 없었습니다. <code>writeFile</code>은 쓸 문자열이 주어지면 <code>Buffer</code> 객체가 아닌 기본 문자 인코딩(UTF-8)을 사용하여 텍스트로 작성해야 한다고 가정합니다.</p>

<p><a class="p_ident" id="p_SJ/BKOfrhB" href="#p_SJ/BKOfrhB" tabindex="-1" role="presentation"></a><code>fs</code> 모듈에는 유용한 함수들이 많이 포함되어 있습니다. <code>readdir</code>는 디렉토리에 있는 파일을 문자열 배열로 반환하고, <code>stat</code>는 파일에 대한 정보를 검색하고, <code>rename</code>은 파일 이름을 바꾸고, <code>unlink</code>는 파일을 제거합니다. 자세한 내용은 <a href="https://nodejs.org"><em>https://nodejs.org</em></a>를 참조합니다.</p>

<p><a class="p_ident" id="p_e3QJHgZtmU" href="#p_e3QJHgZtmU" tabindex="-1" role="presentation"></a>이들 대부분은 콜백 함수를 마지막 매개변수로 사용하며 오류(첫 번째 인수) 또는 성공적인 결과(두 번째 인수)와 함께 호출합니다. 11장에서 보았듯이 이러한 프로그래밍 스타일에는 단점이 있습니다. 가장 큰 단점은 오류 처리가 장황하고 오류가 발생하기 쉽다는 것입니다.</p>

<p><a class="p_ident" id="p_mXF/pVhyVJ" href="#p_mXF/pVhyVJ" tabindex="-1" role="presentation"></a>Promise는 한동안 JavaScript의 일부였지만 Node.js에 대한 통합을 작성하는 시점에서 여전히 진행 중인 작업입니다. <code>fs</code>와 같은 함수 대부분을 포함하지만 콜백 함수 대신에 promises를 사용하는 버전 10.1 이후부터 <code>fs</code> 패키지에서 내보낸 객체 <code>promises</code>가 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wosbb7EfU3" href="#c_wosbb7EfU3" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFile</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;
<span class="cm-variable">readFile</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-def">text</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>, <span class="cm-variable-2">text</span>));</pre>

<p><a class="p_ident" id="p_RKcdbQa/Ot" href="#p_RKcdbQa/Ot" tabindex="-1" role="presentation"></a>때때로 비동기성은 필요하지 않으며 방해가 됩니다. <code>fs</code>의 많은 함수에는 끝에 <code>Sync</code>가 추가된 동일한 이름을 가진 동기 변형도 있습니다. 예를 들어 <code>readFile</code>의 동기 버전은 <code>readFileSync</code>입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_odA0N1psD0" href="#c_odA0N1psD0" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">readFileSync</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The file contains:&quot;</span>,
            <span class="cm-variable">readFileSync</span>(<span class="cm-string">&quot;file.txt&quot;</span>, <span class="cm-string">&quot;utf8&quot;</span>));</pre>

<p><a class="p_ident" id="p_C0yp9W48Cn" href="#p_C0yp9W48Cn" tabindex="-1" role="presentation"></a>이러한 동기 작업이 수행되는 동안 프로그램이 완전히 중지됩니다. 사용자 또는 네트워크의 다른 시스템에 응답해야 하는 경우 동기 작업에 갇히면 성가신 지연이 발생할 수 있습니다.</p>

<h2><a class="h_ident" id="h_3O5dGIJE9F" href="#h_3O5dGIJE9F" tabindex="-1" role="presentation"></a>HTTP 모듈</h2>

<p><a class="p_ident" id="p_jzBrRTKIgP" href="#p_jzBrRTKIgP" tabindex="-1" role="presentation"></a>또 다른 중앙 모듈은 <code>http</code>로 그것은 HTTP 서버를 실행하고 HTTP 요청을 하기 위한 기능을 제공합니다.</p>

<p><a class="p_ident" id="p_5AqaLQsq5V" href="#p_5AqaLQsq5V" tabindex="-1" role="presentation"></a>다음은 HTTP 서버를 시작하는 데 필요한 전부입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_87+jSJqVtw" href="#c_87+jSJqVtw" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">server</span> <span class="cm-operator">=</span> <span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-number">200</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-string">&quot;text/html&quot;</span>});
  <span class="cm-variable-2">response</span>.<span class="cm-property">write</span>(<span class="cm-string-2">`</span>
    <span class="cm-string-2">&lt;h1&gt;Hello!&lt;/h1&gt;</span>
    <span class="cm-string-2">&lt;p&gt;You asked for &lt;code&gt;${</span><span class="cm-variable-2">request</span>.<span class="cm-property">url</span><span class="cm-string-2">}</span><span class="cm-string-2">&lt;/code&gt;&lt;/p&gt;`</span>);
  <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>();
});
<span class="cm-variable">server</span>.<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Listening! (port 8000)&quot;</span>);</pre>

<p><a class="p_ident" id="p_aWcDaGah2b" href="#p_aWcDaGah2b" tabindex="-1" role="presentation"></a>자신의 시스템에서 이 스크립트를 실행하는 경우 웹 브라우저에서 <a href="http://localhost:8000/hello"><em>http://localhost:8000/hello</em></a>를 지정하여 서버에 요청할 수 있습니다. 작은 HTML 페이지로 응답합니다.</p>

<p><a class="p_ident" id="p_ZiHH2p8YG0" href="#p_ZiHH2p8YG0" tabindex="-1" role="presentation"></a><code>createServer</code>에 인수로 전달된 함수는 클라이언트가 서버에 연결할 때마다 호출됩니다. <code>request</code>와 <code>response</code> 바인딩은 들어오고 나가는 데이터를 나타내는 객체입니다. 첫 번째는 <code>url</code>처럼 요청에 대한 정보를 포함합니다.</p>

<p><a class="p_ident" id="p_ufJ1Rx8+U9" href="#p_ufJ1Rx8+U9" tabindex="-1" role="presentation"></a>따라서 브라우저에서 해당 페이지를 열면 요청이 사용자의 컴퓨터로 전송됩니다. 이렇게 하면 서버 기능이 실행되고 응답을 다시 보내게 되며, 이는 브라우저에서 볼 수 있습니다.</p>

<p><a class="p_ident" id="p_eHNvwd3lFU" href="#p_eHNvwd3lFU" tabindex="-1" role="presentation"></a>무언가를 다시 보내려면 <code>response</code> 객체에서 메서드를 호출합니다. 첫 번째 <code>writeHead</code>는 응답 헤더를 작성합니다. 상태 코드(이 경우 "OK"를 나타내는 200)와 헤더 값이 포함된 객체를 제공합니다. 예에서는 HTML 문서를 다시 보낼 것임을 클라이언트에 알리도록 <code>Content-Type</code> 헤더를 설정합니다.</p>

<p><a class="p_ident" id="p_AVzTSVzXSM" href="#p_AVzTSVzXSM" tabindex="-1" role="presentation"></a>다음으로 실제 응답 본문(문서 자체)이 <code>response.write</code>와 함께 전송됩니다. 예를 들어 데이터를 사용할 수 있게 되면 클라이언트에 스트리밍하기 위해 응답을 하나씩 보내려는 경우 이 메서드를 여러 번 호출할 수 있습니다. 마지막으로 <code>response.end</code>는 응답의 끝을 알립니다.</p>

<p><a class="p_ident" id="p_evKrjFovQf" href="#p_evKrjFovQf" tabindex="-1" role="presentation"></a><code>server.listen</code>에 대한 호출은 서버가 포트 8000에서 연결을 기다리기 시작하도록 합니다. 이것이 이 서버와 통신하기 위해 기본 포트 80을 사용하는 <em>localhost</em>가 아니라 <em>localhost:8000</em>에 연결해야 하는 이유입니다.</p>

<p><a class="p_ident" id="p_fc62/ayv5k" href="#p_fc62/ayv5k" tabindex="-1" role="presentation"></a>이 스크립트를 실행하면 프로세스가 그 자리에 앉아서 기다립니다. 스크립트가 이벤트를 수신할 때(이 경우 네트워크 연결) <code>node</code>는 스크립트 끝에 도달하면 자동으로 종료되지 않습니다. 닫으려면 <span class="keyname">control</span>-C를 누르십시오.</p>

<p><a class="p_ident" id="p_7qMlOUUlqm" href="#p_7qMlOUUlqm" tabindex="-1" role="presentation"></a>실제 웹 서버는 일반적으로 예제에 있는 것보다 더 많은 method작업을 수행 합니다. 요청의 메서드(<code>method</code> 속성)를 확인하여 클라이언트가 수행하려는 작업을 확인하고 요청의 URL을 확인하여 이 작업이 수행되는 리소스를 찾습니다.</p>

<p><a class="p_ident" id="p_sg2xBFD57S" href="#p_sg2xBFD57S" tabindex="-1" role="presentation"></a>HTTP <em>client</em> 역할을 위해 <code>http</code> 모듈에서 <code>request</code> 함수를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qPo2Gq+u4e" href="#c_qPo2Gq+u4e" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">request</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-keyword">let</span> <span class="cm-def">requestStream</span> <span class="cm-operator">=</span> <span class="cm-variable">request</span>({
  <span class="cm-property">hostname</span>: <span class="cm-string">&quot;eloquentjavascript.net&quot;</span>,
  <span class="cm-property">path</span>: <span class="cm-string">&quot;/20_node.html&quot;</span>,
  <span class="cm-property">method</span>: <span class="cm-string">&quot;GET&quot;</span>,
  <span class="cm-property">headers</span>: {<span class="cm-property">Accept</span>: <span class="cm-string">&quot;text/html&quot;</span>}
}, <span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Server responded with status code&quot;</span>,
              <span class="cm-variable-2">response</span>.<span class="cm-property">statusCode</span>);
});
<span class="cm-variable">requestStream</span>.<span class="cm-property">end</span>();</pre>

<p><a class="p_ident" id="p_Br0rH14iSh" href="#p_Br0rH14iSh" tabindex="-1" role="presentation"></a><code>request</code>에 대한 첫 번째 인수는 요청을 구성하여 Node에게 통신할 서버, 해당 서버에서 요청할 경로, 사용할 방법 등을 알려줍니다. 두 번째 인수는 응답이 들어올 때 호출되어야 하는 함수입니다. 예를 들어 상태 코드를 찾기 위해 응답을 검사할 수 있도록 하는 객체가 제공됩니다.</p>

<p><a class="p_ident" id="p_9OfV0SuhAH" href="#p_9OfV0SuhAH" tabindex="-1" role="presentation"></a>서버에서 나타낸 <code>response</code> 객체와 마찬가지로 <code>request</code>에서 반환된 객체를 사용하면 <code>write</code> 메서드를 사용하여 요청에 데이터를 스트리밍하고 메서드로 요청을 완료할 수 있습니다. <code>GET</code> 요청은 요청 본문에 데이터를 포함해서는 안되므로 이 예에서는 <code>write</code>를 사용하지 않습니다.</p>

<p><a class="p_ident" id="p_0v59qVWIFa" href="#p_0v59qVWIFa" tabindex="-1" role="presentation"></a><code>https:</code> URL에 대한 요청을 만드는 데 사용할 수 있는 유사한 <code>request</code> 함수가 <code>https</code> 모듈에 있습니다.</p>

<p><a class="p_ident" id="p_HRVzkvyPNc" href="#p_HRVzkvyPNc" tabindex="-1" role="presentation"></a>Node의 원시 기능으로 요청하는 것은 다소 장황합니다. NPM에는 훨씬 더 편리한 래퍼 패키지가 있습니다. 예를 들어, <code>node-fetch</code>는 브라우저에서 소개된 약속 기반 <code>fetch</code> 인터페이스를 제공합니다.</p>

<h2><a class="h_ident" id="h_dJhdomfGgD" href="#h_dJhdomfGgD" tabindex="-1" role="presentation"></a>Streams</h2>

<p><a class="p_ident" id="p_2nMXkmd3DS" href="#p_2nMXkmd3DS" tabindex="-1" role="presentation"></a>HTTP 예에서 쓰기 가능한 스트림의 두 가지 인스턴스, 즉 서버가 쓸 수 있는 응답 객체와 <code>request</code>에서 반환된 요청 객체를 나타냈습니다.</p>

<p><a class="p_ident" id="p_hqra1oS3e2" href="#p_hqra1oS3e2" tabindex="-1" role="presentation"></a><em>Writable streams</em>은 Node에서 널리 사용되는 개념입니다. 이러한 객체에는 문자열 또는 <code>Buffer</code> 객체를 전달하여 스트림에 무언가를 쓸 수 있는 <code>write</code> 메서드가 있습니다. 그것들의 <code>end</code> 메서드는 스트림을 닫고 선택적으로 닫기 전에 스트림에 쓸 값을 취합니다. 이 두 메서드 모두 쓰기 또는 닫기가 완료될 때 호출할 추가 인수로 콜백을 제공할 수도 있습니다.</p>

<p><a class="p_ident" id="p_L3YcfbxZV7" href="#p_L3YcfbxZV7" tabindex="-1" role="presentation"></a><code>fs</code> 모듈의 <code>createWriteStream</code> 함수를 사용하여 파일을 가리키는 쓰기 가능한 스트림을 만들 수 있습니다. 그런 다음 결과 객체에 <code>write</code> 메서드를 사용하여 <code>writeFile</code>에서처럼 한 번에 파일을 기록하는 대신 한 번에 한 조각씩 파일을 쓸 수 있습니다.</p>

<p><a class="p_ident" id="p_93VQIHGgFt" href="#p_93VQIHGgFt" tabindex="-1" role="presentation"></a>읽기 가능 스트림은 좀 더 복잡합니다. HTTP 서버의 콜백에 전달되는 <code>request</code> 바인딩과 HTTP 클라이언트의 콜백에 전달된 <code>response</code> 바인딩은 읽기 가능 스트림입니다. 서버는 요청을 읽은 다음 응답을 작성합니다. 이에 반해 클라이언트는 먼저 요청을 작성한 다음에 응답을 읽습니다. 스트림에서 읽기는 메서드가 아닌 이벤트 처리기를 사용하여 수행됩니다.</p>

<p><a class="p_ident" id="p_CaPkx6i5f+" href="#p_CaPkx6i5f+" tabindex="-1" role="presentation"></a>Node에서 이벤트를 내보내는 객체에는 브라우저의 <code>addEventListener</code> 메서드와 유사한 <code>on</code> 메서드가 호출됩니다. 이벤트 이름을 지정한 다음 함수를 지정하면 해당 이벤트가 발생할 때마다 호출되도록 해당 함수를 등록합니다.</p>

<p><a class="p_ident" id="p_3yAsJAs/Gl" href="#p_3yAsJAs/Gl" tabindex="-1" role="presentation"></a>읽기 가능 스트림에는 <code>&quot;data&quot;</code> 및 <code>&quot;end&quot;</code> 이벤트가 있습니다. 첫 번째는 데이터가 들어올 때마다 실행되고 두 번째는 스트림이 끝날 때마다 호출됩니다. 이 모델은 전체 문서를 아직 사용할 수 없는 경우에도 즉시 처리할 수 있는 스트리밍 데이터에 가장 적합합니다. <code>fs</code>의 <code>createReadStream</code> 함수를 사용하여 파일을 읽기 가능 스트림으로 읽을 수 있습니다.</p>

<p><a class="p_ident" id="p_DQmM9KjDIA" href="#p_DQmM9KjDIA" tabindex="-1" role="presentation"></a>다음 코드는 요청 본문을 읽고 전체 대문자 텍스트로 클라이언트에 다시 스트리밍하는 서버를 만듭니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vUewhc4MbF" href="#c_vUewhc4MbF" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-number">200</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-string">&quot;text/plain&quot;</span>});
  <span class="cm-variable-2">request</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;data&quot;</span>, <span class="cm-def">chunk</span> <span class="cm-operator">=&gt;</span>
    <span class="cm-variable-2">response</span>.<span class="cm-property">write</span>(<span class="cm-variable-2">chunk</span>.<span class="cm-property">toString</span>().<span class="cm-property">toUpperCase</span>()));
  <span class="cm-variable-2">request</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;end&quot;</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>());
}).<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);</pre>

<p><a class="p_ident" id="p_cE/QJiL9Ih" href="#p_cE/QJiL9Ih" tabindex="-1" role="presentation"></a>데이터 처리기에 전달된 <code>chunk</code> 값은 이진 <code>Buffer</code>입니다. <code>toString</code> 메서드를 사용하여 UTF-8로 인코딩된 문자로 디코딩하여 이것을 문자열로 변환할 수 있습니다.</p>

<p><a class="p_ident" id="p_w5A5V67s63" href="#p_w5A5V67s63" tabindex="-1" role="presentation"></a>uppercasing 서버가 활성화된 상태에서 다음 코드를 실행하면 해당 서버에 요청을 보내고 받은 응답을 작성합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_tqlbzAFLXQ" href="#c_tqlbzAFLXQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">request</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);
<span class="cm-variable">request</span>({
  <span class="cm-property">hostname</span>: <span class="cm-string">&quot;localhost&quot;</span>,
  <span class="cm-property">port</span>: <span class="cm-number">8000</span>,
  <span class="cm-property">method</span>: <span class="cm-string">&quot;POST&quot;</span>
}, <span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">response</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;data&quot;</span>, <span class="cm-def">chunk</span> <span class="cm-operator">=&gt;</span>
    <span class="cm-variable">process</span>.<span class="cm-property">stdout</span>.<span class="cm-property">write</span>(<span class="cm-variable-2">chunk</span>.<span class="cm-property">toString</span>()));
}).<span class="cm-property">end</span>(<span class="cm-string">&quot;Hello server&quot;</span>);
<span class="cm-comment">// → HELLO SERVER</span></pre>

<p><a class="p_ident" id="p_BjmSS8sm41" href="#p_BjmSS8sm41" tabindex="-1" role="presentation"></a>위 예에서는 <code>console.log</code>을 사용하는 대신 (쓰기 가능한 스트림인 프로세스의 표준 출력) <code>process.stdout</code>에 작성합니다. 작성되는 텍스트의 각 부분 뒤에 추가 개행 문자를 추가하기 때문에 <code>console.log</code>를 사용할 수 없습니다. 응답이 여러 청크로 들어올 수 있기 때문에 여기에 적합하지 않습니다.</p>

<h2 id="file_server"><a class="h_ident" id="h_yAdw1Y7bgN" href="#h_yAdw1Y7bgN" tabindex="-1" role="presentation"></a>파일 서버</h2>

<p><a class="p_ident" id="p_XFsmNNR4P8" href="#p_XFsmNNR4P8" tabindex="-1" role="presentation"></a>HTTP 서버에 대한 새로운 지식과 파일 시스템 작업을 결합하여 파일 시스템에 대한 원격 액세스를 허용하는 HTTP 서버 사이에 다리를 만들어 보겠습니다. 이러한 서버는 모든 종류의 용도가 있습니다. 웹 응용 프로그램이 데이터를 저장 및 공유할 수 있도록 하거나 여러 사용자에게 여러 파일에 대한 공유 액세스 권한을 부여할 수 있습니다.</p>

<p><a class="p_ident" id="p_Pu9mO8Vutb" href="#p_Pu9mO8Vutb" tabindex="-1" role="presentation"></a>파일을 HTTP 리소스로 취급할 때 HTTP 메서드 <code>GET</code>, <code>PUT</code> 및 <code>DELETE</code>는 각각 파일을 읽고, 쓰고, 삭제할 수 있습니다. 요청의 경로를 요청이 참조하는 파일의 경로로 해석합니다.</p>

<p><a class="p_ident" id="p_ISZx6yrjrK" href="#p_ISZx6yrjrK" tabindex="-1" role="presentation"></a>전체 파일 시스템을 공유하고 싶지 않을 것이므로 이들 경로를 서버의 작업 디렉토리, 즉 시작된 디렉토리에서 시작하는 것으로 해석합니다. 만일 <code>/tmp/public/</code> (또는 윈도우 상에서 <code>C:\tmp\public\</code>)에서 서버를 실행한 경우 <code>/file.txt</code>에 대한 요청은 <code>/<wbr>tmp/<wbr>public/<wbr>file.<wbr>txt</code>(또는 <code>C:\tmp\public\file.<wbr>txt</code>)를 참조해야 합니다.</p>

<p><a class="p_ident" id="p_2ZKgpWkGup" href="#p_2ZKgpWkGup" tabindex="-1" role="presentation"></a>다양한 HTTP 메서드를 처리하는 함수를 저장하기 위해 <code>methods</code>라는 객체를 사용하여 프로그램을 하나씩 빌드합니다. 메서드 처리기는 요청 객체를 인수로 가져오고 응답을 설명하는 객체로 확인되는 약속을 반환하는 <code>async</code> 함수입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_W/1zaB21gr" href="#c_W/1zaB21gr" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createServer</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;http&quot;</span>);

<span class="cm-keyword">const</span> <span class="cm-def">methods</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">createServer</span>((<span class="cm-def">request</span>, <span class="cm-def">response</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">handler</span> <span class="cm-operator">=</span> <span class="cm-variable">methods</span>[<span class="cm-variable-2">request</span>.<span class="cm-property">method</span>] <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable">notAllowed</span>;
  <span class="cm-variable-2">handler</span>(<span class="cm-variable-2">request</span>)
    .<span class="cm-property">catch</span>(<span class="cm-def">error</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">error</span>;
      <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: <span class="cm-variable">String</span>(<span class="cm-variable-2">error</span>), <span class="cm-property">status</span>: <span class="cm-number">500</span>};
    })
    .<span class="cm-property">then</span>(({<span class="cm-property">body</span>, <span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-number">200</span>, <span class="cm-variable">type</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;text/plain&quot;</span>}) <span class="cm-operator">=&gt;</span> {
       <span class="cm-variable-2">response</span>.<span class="cm-property">writeHead</span>(<span class="cm-variable">status</span>, {<span class="cm-string cm-property">&quot;Content-Type&quot;</span>: <span class="cm-variable">type</span>});
       <span class="cm-keyword">if</span> (<span class="cm-variable">body</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable">body</span>.<span class="cm-property">pipe</span>) <span class="cm-variable">body</span>.<span class="cm-property">pipe</span>(<span class="cm-variable-2">response</span>);
       <span class="cm-keyword">else</span> <span class="cm-variable-2">response</span>.<span class="cm-property">end</span>(<span class="cm-variable">body</span>);
    });
}).<span class="cm-property">listen</span>(<span class="cm-number">8000</span>);

<span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">notAllowed</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">return</span> {
    <span class="cm-property">status</span>: <span class="cm-number">405</span>,
    <span class="cm-property">body</span>: <span class="cm-string-2">`Method ${</span><span class="cm-variable-2">request</span>.<span class="cm-property">method</span><span class="cm-string-2">}</span> <span class="cm-string-2">not allowed.`</span>
  };
}</pre>

<p><a class="p_ident" id="p_yWKuFrWjV3" href="#p_yWKuFrWjV3" tabindex="-1" role="presentation"></a>이것은 405 오류 응답을 반환하는 서버를 시작합니다. 이는 서버가 주어진 메서드 처리를 거부함을 나타내는 데 사용되는 코드입니다.</p>

<p><a class="p_ident" id="p_JXw1kc0aXP" href="#p_JXw1kc0aXP" tabindex="-1" role="presentation"></a>요청 핸들러의 약속이 거부되면 <code>catch</code> 호출은 오류를 응답 객체로 변환합니다(아직 없는 경우). 따라서 서버는 클라이언트에게 요청 처리에 실패했음을 알리기 위해 오류 응답을 다시 보낼 수 있습니다.</p>

<p><a class="p_ident" id="p_hqnRLFr4tm" href="#p_hqnRLFr4tm" tabindex="-1" role="presentation"></a>응답의 설명의 <code>status</code> 정보 필드는 생략될 수 있는 경우에 200 (OK)의 기본 값을 가집니다. type속성 의 콘텐츠 유형 도 생략할 수 있으며 이 경우 응답은 일반 텍스트로 간주됩니다.</p>

<p><a class="p_ident" id="p_qzp2F6cgBS" href="#p_qzp2F6cgBS" tabindex="-1" role="presentation"></a><code>body</code> 값이 읽을 수 있는 스트림이면 읽기 가능 스트림에서 쓰기 가능한 스트림으로 모든 콘텐츠를 전달하는데 사용되는 메서드 <code>pipe</code>가 있습니다. 그렇지 않은 경우 <code>null</code>(본문 없음), 문자열 또는 버퍼로 간주되며 응답의 <code>end</code> 메서드에 직접 전달됩니다.</p>

<p><a class="p_ident" id="p_pL6vfBBk4E" href="#p_pL6vfBBk4E" tabindex="-1" role="presentation"></a>요청 URL에 해당하는 파일 경로를 파악하기 위해 <code>urlPath</code> 함수는 Node의 내장<code>url</code> 모듈을 사용하여 URL을 구문 분석합니다. <code>&quot;/<wbr>file.<wbr>txt&quot;</code>와 같은 경로 이름을 사용하여 <code>%20</code>-style 이스케이프 코드를 제거하기 위해 디코딩하고 프로그램의 작업 디렉토리와 관련하여 해결합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vgzzr4jj34" href="#c_vgzzr4jj34" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">parse</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;url&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">resolve</span>, <span class="cm-def">sep</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;path&quot;</span>);

<span class="cm-keyword">const</span> <span class="cm-def">baseDirectory</span> <span class="cm-operator">=</span> <span class="cm-variable">process</span>.<span class="cm-property">cwd</span>();

<span class="cm-keyword">function</span> <span class="cm-def">urlPath</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">let</span> {<span class="cm-def">pathname</span>} <span class="cm-operator">=</span> <span class="cm-variable">parse</span>(<span class="cm-variable-2">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">resolve</span>(<span class="cm-variable">decodeURIComponent</span>(<span class="cm-variable-2">pathname</span>).<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">path</span> <span class="cm-operator">!=</span> <span class="cm-variable">baseDirectory</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
      <span class="cm-operator">!</span><span class="cm-variable-2">path</span>.<span class="cm-property">startsWith</span>(<span class="cm-variable">baseDirectory</span> <span class="cm-operator">+</span> <span class="cm-variable">sep</span>)) {
    <span class="cm-keyword">throw</span> {<span class="cm-property">status</span>: <span class="cm-number">403</span>, <span class="cm-property">body</span>: <span class="cm-string">&quot;Forbidden&quot;</span>};
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">path</span>;
}</pre>

<p><a class="p_ident" id="p_1NWx24yrl9" href="#p_1NWx24yrl9" tabindex="-1" role="presentation"></a>네트워크 요청을 수락하도록 프로그램을 설정하자마자 보안에 대해 걱정해야 합니다. 이 경우 주의하지 않으면 실수로 전체 파일 시스템을 네트워크에 노출시킬 수 있습니다.</p>

<p><a class="p_ident" id="p_m0GNABM8RH" href="#p_m0GNABM8RH" tabindex="-1" role="presentation"></a>파일 경로는 Node.js의 문자열입니다. 이러한 문자열을 실제 파일에 매핑하기 위해 엄청난 양의 해석이 진행됩니다. 경로는 예를 들어 상위 디렉토리를 참조하기 위해 <code>../</code>을 포함할 수 있습니다. 따라서 문제의 명백한 하나의 소스는 <code>/../secret_file</code>와 같은 경로 요청일 수 있습니다.</p>

<p><a class="p_ident" id="p_5zn0AvJXaW" href="#p_5zn0AvJXaW" tabindex="-1" role="presentation"></a>이러한 문제를 방지하기 위해 <code>urlPath</code>는 상대 경로를 해결하는 모듈 <code>path</code>의 <code>resolve</code> 함수를 사용합니다. 그런 다음 결과가 작업 디렉토리 아래에 있는지 확인합니다. <code>process.cwd</code> 함수는 (여기서 <code>cwd</code>는 현재 작업 디렉토리를 의미) 작업 디렉토리를 찾을 수 있습니다. 패키지 <code>path</code>의 <code>sep</code> 바인딩은 시스템의 경로 구분 기호입니다. Windows에서는 백슬래시이고 대부분의 다른 시스템에서는 슬래시입니다. 경로가 기본 디렉터리로 시작하지 않으면 함수는 리소스에 대한 액세스가 금지되었음을 나타내는 HTTP 상태 코드를 사용하여 오류 응답 객체를 던집니다.</p>

<p><a class="p_ident" id="p_0E1fkrPcjR" href="#p_0E1fkrPcjR" tabindex="-1" role="presentation"></a>디렉토리를 읽을 때 파일 목록을 반환하고 일반 파일을 읽을 때 파일 내용을 반환하는 <code>GET</code> 메서드를 설정합니다.</p>

<p><a class="p_ident" id="p_zj6fKVP9SD" href="#p_zj6fKVP9SD" tabindex="-1" role="presentation"></a>한 가지 까다로운 사항은 파일 내용을 반환할 때 어떤 종류의 <code>Content-Type</code> 헤더를 설정해야 하는지 입니다. 이러한 파일은 무엇이든 될 수 있으므로 서버는 단순히 모든 파일에 대해 동일한 콘텐츠 타입을 반환할 수 없습니다. NPM은 여기에서 다시 도움이 됩니다. <code>mime</code> 패키지는 (<code>text/plain</code>와 같은 콘텐츠 타입 지표 또한 <em>MIME types</em>) 많은 파일 확장자의 정확한 타입을 알고 있습니다.</p>

<p><a class="p_ident" id="p_ZZr+O24IMr" href="#p_ZZr+O24IMr" tabindex="-1" role="presentation"></a>다음 <code>npm</code> 명령은 서버 스크립트가 있는 디렉토리에 <code>mime</code>의 특정 버전을 설치합니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_nzfHTZ/5TP" href="#c_nzfHTZ/5TP" tabindex="-1" role="presentation"></a>$ npm install mime@2.2.0</pre>

<p><a class="p_ident" id="p_0oNrzailqn" href="#p_0oNrzailqn" tabindex="-1" role="presentation"></a>요청된 파일이 존재하지 않을 때 반환할 올바른 HTTP 상태 코드는 404입니다. 파일에 대한 정보를 조회하는 <code>stat</code> 함수를 사용하여 파일이 있는지 여부와 디렉터리인지 여부를 모두 알아볼 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bUezN7Otmf" href="#c_bUezN7Otmf" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createReadStream</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);
<span class="cm-keyword">const</span> {<span class="cm-def">stat</span>, <span class="cm-def">readdir</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;
<span class="cm-keyword">const</span> <span class="cm-def">mime</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;mime&quot;</span>);

<span class="cm-variable">methods</span>.<span class="cm-property">GET</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">stats</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable-2">stats</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">stat</span>(<span class="cm-variable-2">path</span>);
  } <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">code</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;ENOENT&quot;</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">404</span>, <span class="cm-property">body</span>: <span class="cm-string">&quot;File not found&quot;</span>};
  }
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">stats</span>.<span class="cm-property">isDirectory</span>()) {
    <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: (<span class="cm-keyword">await</span> <span class="cm-variable">readdir</span>(<span class="cm-variable-2">path</span>)).<span class="cm-property">join</span>(<span class="cm-string">&quot;\n&quot;</span>)};
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> {<span class="cm-property">body</span>: <span class="cm-variable">createReadStream</span>(<span class="cm-variable-2">path</span>),
            <span class="cm-property">type</span>: <span class="cm-variable">mime</span>.<span class="cm-property">getType</span>(<span class="cm-variable-2">path</span>)};
  }
};</pre>

<p><a class="p_ident" id="p_iYt4Ms5dC4" href="#p_iYt4Ms5dC4" tabindex="-1" role="presentation"></a>디스크를 거드려야 하기 때문에 시간이 오래 걸릴 수 있으므로 <code>stat</code>는 비동기식입니다. 콜백 스타일보다 프라미스를 사용하고 있기 때문에 <code>fs</code>에서 직접 가져오는 대신 <code>promises</code>에서 가져와야 합니다.</p>

<p><a class="p_ident" id="p_tdTunaPFS/" href="#p_tdTunaPFS/" tabindex="-1" role="presentation"></a>파일이 없으면 <code>stat</code>는 속성이 <code>&quot;ENOENT&quot;</code>인 <code>code</code> 속성을 가진 에러 객체를 던집니다. 이러한 다소 모호한 Unix에서 영감을 받은 코드는 Node.js에서 오류 타입을 인식하는 방식입니다.</p>

<p><a class="p_ident" id="p_f1+vCwgX9M" href="#p_f1+vCwgX9M" tabindex="-1" role="presentation"></a><code>stat</code>에 의해 반환된 <code>stats</code> 객체는 그것의 크기 (<code>size</code> 속성) 및 변경 날짜(<code>mtime</code> 속성)와 같은 파일에 대한 몇 가지 것을 알립니다. 여기서는 <code>isDirectory</code> 메서드가 알려주는 디렉터리인지 일반 파일인지에 대한 질문에 관심이 있습니다.</p>

<p><a class="p_ident" id="p_E8HtJSMMtj" href="#p_E8HtJSMMtj" tabindex="-1" role="presentation"></a>디렉토리에 있는 파일의 배열을 읽어 그것을 클라이언트에 반환하는 <code>readdir</code>를 사용합니다. 일반 파일의 경우 <code>createReadStream</code>을 사용하여 읽기 가능 스트림을 생성하고 <code>mime</code> 패키지가 파일 이름에 대해 제공하는 콘텐츠 타입과 함께 그것을 본문으로 반환합니다.</p>

<p><a class="p_ident" id="p_3SF21U54yR" href="#p_3SF21U54yR" tabindex="-1" role="presentation"></a><code>DELETE</code> 요청을 처리하는 코드는 조금 더 간단합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QVBbtdK0s5" href="#c_QVBbtdK0s5" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">rmdir</span>, <span class="cm-def">unlink</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>).<span class="cm-property">promises</span>;

<span class="cm-variable">methods</span>.<span class="cm-property">DELETE</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">stats</span>;
  <span class="cm-keyword">try</span> {
    <span class="cm-variable-2">stats</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">stat</span>(<span class="cm-variable-2">path</span>);
  } <span class="cm-keyword">catch</span> (<span class="cm-def">error</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">code</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;ENOENT&quot;</span>) <span class="cm-keyword">throw</span> <span class="cm-variable-2">error</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
  }
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">stats</span>.<span class="cm-property">isDirectory</span>()) <span class="cm-keyword">await</span> <span class="cm-variable">rmdir</span>(<span class="cm-variable-2">path</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">await</span> <span class="cm-variable">unlink</span>(<span class="cm-variable-2">path</span>);
  <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
};</pre>

<p><a class="p_ident" id="p_AXYF3FSJbj" href="#p_AXYF3FSJbj" tabindex="-1" role="presentation"></a>HTTP 응답에 데이터가 포함되어 있지 않으면 상태 코드 204("내용 없음")를 사용하여 이를 나타낼 수 있습니다. 삭제에 대한 응답은 작업 성공 여부 이외의 정보를 전송할 필요가 없으므로 여기에 반환하는 것이 합리적입니다.</p>

<p><a class="p_ident" id="p_1CFycX4t/q" href="#p_1CFycX4t/q" tabindex="-1" role="presentation"></a>존재하지 않는 파일을 삭제하려고 하면 오류가 아닌 성공 상태 코드가 반환되는 이유가 궁금할 수 있습니다. 삭제되는 파일이 없으면 요청의 목적이 이미 달성되었다고 말할 수 있습니다. HTTP 표준은 요청을 <em>idempotent</em>로 만들도록 권장합니다. 즉, 동일한 요청을 여러 번 수행하면 한 번 수행하는 것과 동일한 결과가 생성됩니다. 어떤 면에서 이미 사라진 것을 삭제하려고 하면 하려고 했던 효과가 달성된 것입니다. 즉, 더 이상 존재하지 않습니다.</p>

<p><a class="p_ident" id="p_q7xnjGCxyr" href="#p_q7xnjGCxyr" tabindex="-1" role="presentation"></a>다음은 <code>PUT</code> 요청에 대한 처리기입니다.:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SSOayCBrzD" href="#c_SSOayCBrzD" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> {<span class="cm-def">createWriteStream</span>} <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">&quot;fs&quot;</span>);

<span class="cm-keyword">function</span> <span class="cm-def">pipeStream</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">from</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;error&quot;</span>, <span class="cm-variable-2">reject</span>);
    <span class="cm-variable-2">to</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;error&quot;</span>, <span class="cm-variable-2">reject</span>);
    <span class="cm-variable-2">to</span>.<span class="cm-property">on</span>(<span class="cm-string">&quot;finish&quot;</span>, <span class="cm-variable-2">resolve</span>);
    <span class="cm-variable-2">from</span>.<span class="cm-property">pipe</span>(<span class="cm-variable-2">to</span>);
  });
}

<span class="cm-variable">methods</span>.<span class="cm-property">PUT</span> <span class="cm-operator">=</span> <span class="cm-keyword">async</span> <span class="cm-keyword">function</span>(<span class="cm-def">request</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">path</span> <span class="cm-operator">=</span> <span class="cm-variable">urlPath</span>(<span class="cm-variable-2">request</span>.<span class="cm-property">url</span>);
  <span class="cm-keyword">await</span> <span class="cm-variable">pipeStream</span>(<span class="cm-variable-2">request</span>, <span class="cm-variable">createWriteStream</span>(<span class="cm-variable-2">path</span>));
  <span class="cm-keyword">return</span> {<span class="cm-property">status</span>: <span class="cm-number">204</span>};
};</pre>

<p><a class="p_ident" id="p_uDb6FJuQ47" href="#p_uDb6FJuQ47" tabindex="-1" role="presentation"></a>이번에는 파일이 존재하는지 확인할 필요가 없습니다. 존재하는 경우 파일을 덮어씁니다. 읽기 가능 스트림에서 쓰기 가능 스트림으로 데이터를 이동하는 데 다시 <code>pipe</code>를 사용합니다. 이 경우에는 요청에서 파일로 데이터를 이동합니다. 그러나 <code>pipe</code>는 promise를 반환하도록 작성되지 않았기 때문에 <code>pipe</code> 호출 결과에 대한 프라미스를 생성하는 래퍼 <code>pipeStream</code>를 작성해야 합니다.</p>

<p><a class="p_ident" id="p_DGGAMEixPQ" href="#p_DGGAMEixPQ" tabindex="-1" role="presentation"></a>파일을 열 때 문제가 발생하면 여전히 <code>createWriteStream</code>은 스트림을 반환하지만 해당 스트림은 <code>&quot;error&quot;</code> 이벤트를 발생시킵니다. 네트워크가 다운되는 경우와 같이 요청에 대한 출력 스트림도 실패할 수 있습니다. 그래서 약속을 거부하기 위해 두 스트림의 <code>&quot;error&quot;</code> 이벤트를 연결합니다. <code>pipe</code>가 완료되면 출력 스트림을 닫아 <code>&quot;finish&quot;</code> 이벤트를 발생시킵니다. 이것이 약속을 성공적으로 해결할 수 있는 지점입니다(아무것도 반환하지 않음).</p>

<p><a class="p_ident" id="p_ig7HitKqRz" href="#p_ig7HitKqRz" tabindex="-1" role="presentation"></a>서버에 대한 전체 스크립트는 <a href="https://eloquentjavascript.net/code/file_server.js"><em>https://eloquentjavascript.net/code/file_server.js</em></a>을 참조할 수 있습니다. 이를 다운로드하고 종속성을 설치한 후 Node로 실행하여 고유한 파일 서버를 시작할 수 있습니다. 그리고 물론 이 페이지의 연습문제를 풀거나 실험하기 위해 수정하고 확장할 수 있습니다.</p>

<p><a class="p_ident" id="p_fBFWTJncql" href="#p_fBFWTJncql" tabindex="-1" role="presentation"></a>Unix 계열 시스템(예를 들어, macOS 및 Linux)에서 널리 사용 가능한 명령줄 도구 <code>curl</code>을 사용하여 HTTP 요청을 할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_1De9cCo/FY" href="#c_1De9cCo/FY" tabindex="-1" role="presentation"></a>$ curl http://localhost:8000/file.txt
File not found
$ curl -X PUT -d hello http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
hello
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
File not found</pre>

<p><a class="p_ident" id="p_AmMFBJGSkb" href="#p_AmMFBJGSkb" tabindex="-1" role="presentation"></a>파일이 아직 존재하지 않기 때문에 <code>file.txt</code>에 대한 첫 번째 요청이 실패합니다. <code>PUT</code> 요청은 파일을 생성하고, 다음 요청이 성공적으로 진행되도록 합니다. <code>DELETE</code> 요청으로 삭제한 후 파일이 다시 누락되었습니다.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_aI1QIDZs29" href="#p_aI1QIDZs29" tabindex="-1" role="presentation"></a>Node는 브라우저가 아닌 컨텍스트에서 JavaScript를 실행할 수 있는 훌륭하고 작은 시스템입니다. 원래 네트워크 작업이 네트워크에서 <em>node</em> 역할을 하도록 설계되었습니다. 그러나 모든 종류의 스크립팅 작업에 적합하며 JavaScript 작성을 즐기는 경우 Node로 작업을 자동화하는 것이 좋습니다.</p>

<p><a class="p_ident" id="p_pVLEV4YWAu" href="#p_pVLEV4YWAu" tabindex="-1" role="presentation"></a>NPM은 생각할 수 있는 모든 것에 대한 패키지를 제공하며 <code>npm</code> 프로그램과 함께 해당 패키지를 가져와 설치할 수 있습니다. Node는 파일 시스템 작업을 위한 <code>fs</code> 모듈과 HTTP 서버를 실행하고 HTTP 요청을 하기 위한 <code>http</code> 모듈을 포함하여 다수의 내장 모듈과 함께 제공됩니다.</p>

<p><a class="p_ident" id="p_FBsszxt4wi" href="#p_FBsszxt4wi" tabindex="-1" role="presentation"></a>Node의 모든 입력 및 출력은 <code>readFileSync</code>와 같은 함수의 동기 변형을 명확히 사용하지 않은 한 비동기적으로 행해집니다. 이러한 비동기 함수를 호출할 때 콜백 함수를 제공하고 Node는 준비가 되면 오류 값과 결과(사용 가능한 경우)로 호출합니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_9+y+iovU0J" href="#i_9+y+iovU0J" tabindex="-1" role="presentation"></a>검색 도구</h3>

<p><a class="p_ident" id="p_ca6ZBtGx1B" href="#p_ca6ZBtGx1B" tabindex="-1" role="presentation"></a>Unix 시스템에는 정규식에 대한 파일을 빠르게 검색하는데 사용할 수 있는 명령줄 도구 <code>grep</code>가 있습니다.</p>

<p><a class="p_ident" id="p_/pAmPm2px7" href="#p_/pAmPm2px7" tabindex="-1" role="presentation"></a>명령줄에서 실행할 수 있고 <code>grep</code>과 같이 작동하는 노드 스크립트를 작성합니다. 첫 번째 명령줄 인수를 정규식으로 취급하고 추가 인수를 검색할 파일로 취급합니다. 내용이 정규식과 일치하는 모든 파일의 이름을 출력해야 합니다.</p>

<p><a class="p_ident" id="p_ddYdvItkvN" href="#p_ddYdvItkvN" tabindex="-1" role="presentation"></a>그것이 작동하면 인수 중 하나가 디렉토리일 때 해당 디렉토리와 하위 디렉토리의 모든 파일을 검색하도록 확장하십시오.</p>

<p><a class="p_ident" id="p_y4ht4tsxKI" href="#p_y4ht4tsxKI" tabindex="-1" role="presentation"></a>필요에 따라 비동기 또는 동기 파일 시스템 기능을 사용하십시오. 여러 비동기 작업이 동시에 요청되도록 설정하면 작업 속도가 약간 빨라지지만 많은 양은 아닙니다. 대부분의 파일 시스템은 한 번에 하나만 읽을 수 있기 때문입니다.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_3yQPGLxU85" href="#p_3yQPGLxU85" tabindex="-1" role="presentation"></a>첫 번째 명령 라인 인수인 정규식은 <code>process.argv[2]</code>에서 찾을 수 있습니다. 입력 파일은 그 다음에 옵니다. <code>RegExp</code> 생성자를 사용하여 문자열에서 정규식 객체로 이동할 수 있습니다.</p>

<p><a class="p_ident" id="p_h+mtaoCbhZ" href="#p_h+mtaoCbhZ" tabindex="-1" role="presentation"></a><code>readFileSync</code>를 사용하여 동기식으로 작업하는 것이 보다 간단하지만, <code>async</code> 함수를 작성하기 위해 다시 <code>fs.promises</code>를 사용하면 유사한 코드가 됩니다.</p>

<p><a class="p_ident" id="p_r0XgnA8VK0" href="#p_r0XgnA8VK0" tabindex="-1" role="presentation"></a>어떤 것이 디렉토리인지 알아내려면 <code>stat</code> (또는 <code>statSync</code>) 및 stats 객체의 <code>isDirectory</code> 메서드를 다시 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_KiWSClPPul" href="#p_KiWSClPPul" tabindex="-1" role="presentation"></a>디렉토리 탐색은 분기 과정입니다. 재귀 함수를 사용하거나 작업 배열(아직 탐색해야 하는 파일)을 유지하여 이를 수행할 수 있습니다. 디렉토리에서 파일을 찾으려면 <code>readdir</code> 또는 <code>readdirSync</code>를 호출할 수 있습니다. Node의 파일 시스템 함수 이름 붙이기는 <code>readdir</code>와 같은 표준 Unix 함수들을  바탕으로 하는 모든 소문자들이지만 대문자로 <code>Sync</code>를 추가합니다.</p>

<p><a class="p_ident" id="p_dYrkZNxSEL" href="#p_dYrkZNxSEL" tabindex="-1" role="presentation"></a><code>readdir</code>로 읽은 파일 이름에서 전체 경로 이름으로 이동하려면 디렉토리 이름과 결합하고 슬래시 문자(<code>/</code>)를 넣어야 합니다.</p>

</div></div>

<h3><a class="i_ident" id="i_h8iNiA8ezX" href="#i_h8iNiA8ezX" tabindex="-1" role="presentation"></a>디렉토리 생성</h3>

<p><a class="p_ident" id="p_eKscmrM/cp" href="#p_eKscmrM/cp" tabindex="-1" role="presentation"></a>파일 서버에서 <code>DELETE</code> 메서드는 디렉터리를 삭제할 수 있지만 (<code>rmdir</code> 사용), 현재 서버는 디렉터리를 생성하기 위한 어떠한 방식도 제공하지 않습니다.</p>

<p><a class="p_ident" id="p_GpjSLUJk84" href="#p_GpjSLUJk84" tabindex="-1" role="presentation"></a><code>fs</code> 모듈에서 <code>mkdir</code>를 호출하여 디렉터리를 생성해야 하는 <code>MKCOL</code> 메서드("make collection")에 대한 지원을 추가합니다. 널리 사용되는 HTTP 방법은 아니지만 문서 작성에 적합하도록 HTTP 위에 일련의 규칙을 지정하는 <em>WebDAV</em> 표준에도 동일한 목적으로 존재합니다.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_Ptyerm4lHs" href="#p_Ptyerm4lHs" tabindex="-1" role="presentation"></a><code>DELETE</code> 메서드를 구현하는 함수를 <code>MKCOL</code> 메서드의 청사진으로 사용할 수 있습니다. 파일을 찾을 수 없으면 <code>mkdir</code>로 디렉토리를 만듭니다. 해당 경로에 디렉터리가 있으면 디렉터리 생성 요청이 멱등성이 되도록 204 응답을 반환할 수 있습니다. 여기에 디렉토리가 아닌 파일이 있으면 오류 코드를 반환합니다. 코드 400("잘못된 요청")이 적합합니다.</p>

</div></div>

<h3><a class="i_ident" id="i_TLRTlwK6ZU" href="#i_TLRTlwK6ZU" tabindex="-1" role="presentation"></a>웹상의 공개 공간</h3>

<p><a class="p_ident" id="p_fGFbxH6/FF" href="#p_fGFbxH6/FF" tabindex="-1" role="presentation"></a>파일 서버는 모든 종류의 파일을 제공하고 올바른 <code>Content-Type</code> 헤더를 포함하기 때문에 웹사이트를 제공하는데 사용할 수 있습니다. 모든 사람이 파일을 삭제하고 교체할 수 있기 때문에 시간을 들여 올바른 HTTP 요청을 생성하는 모든 사람이 수정, 개선 및 파손할 수 있는 흥미로운 종류의 웹사이트가 될 것입니다.</p>

<p><a class="p_ident" id="p_A9LlE9TbZm" href="#p_A9LlE9TbZm" tabindex="-1" role="presentation"></a>간단한 JavaScript 파일을 포함하는 기본 HTML 페이지를 작성하십시오. 파일 서버가 제공하는 디렉토리에 파일을 넣고 브라우저에서 엽니다.</p>

<p><a class="p_ident" id="p_6IZvK/z6Ez" href="#p_6IZvK/z6Ez" tabindex="-1" role="presentation"></a>다음으로 고급 연습 또는 주말 프로젝트로 이 페이지에서 얻은 모든 지식을 결합하여 웹 사이트 내부 에서 웹 사이트를 수정하기 위한 보다 사용자 친화적인 인터페이스를 구축하십시오.</p>

<p><a class="p_ident" id="p_PMJCxe07g5" href="#p_PMJCxe07g5" tabindex="-1" role="presentation"></a>HTML 양식을 사용하여 웹사이트를 구성하는 파일의 내용을 편집하고 18장에 설명된 대로 HTTP 요청을 사용하여 사용자가 서버에서 파일을 업데이트할 수 있도록 합니다.</p>

<p><a class="p_ident" id="p_hWSA1+odAv" href="#p_hWSA1+odAv" tabindex="-1" role="presentation"></a>하나의 파일만 편집 가능하게 만드는 것으로 시작하십시오. 그런 다음 사용자가 편집할 파일을 선택할 수 있도록 합니다. 디렉토리를 읽을 때 파일 서버가 파일 목록을 반환한다는 사실을 사용하십시오.</p>

<p><a class="p_ident" id="p_5JDgu6tuAT" href="#p_5JDgu6tuAT" tabindex="-1" role="presentation"></a>실수를 하면 파일이 손상될 수 있으므로 파일 서버에 의해 노출된 코드에서 직접 작업하지 마십시오. 대신 공개적으로 액세스할 수 있는 디렉터리 외부에 작업을 보관하고 테스트할 때 해당 디렉터리에 복사합니다.</p>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_v9JKMD5WJI" href="#p_v9JKMD5WJI" tabindex="-1" role="presentation"></a><textarea>편집 중인 파일의 내용을 담을 <code>&lt;textarea&gt;</code> 요소를 생성할 수 있습니다. <code>fetch</code>를 사용하는 <code>GET</code> 요청은 파일의 현재 내용을 검색할 수 있습니다. <a href="http://localhost:8000/index.html"><em>http://localhost:8000/index.html</em></a> 대신에 <em>index.html</em>과 같은 상대적인 URL을 사용하여 실행 중인 스크립트와 동일한 서버에 있는 파일을 참조할 수 있습니다.</p>

<p><a class="p_ident" id="p_AddxfNwTA3" href="#p_AddxfNwTA3" tabindex="-1" role="presentation"></a>그런 다음 사용자가 버튼을 클릭하면(<code>&lt;form&gt;</code> 요소 및 <code>&quot;submit&quot;</code> 이벤트를 사용할 수 있음) 동일한 URL에 대한 <code>PUT</code> 요청이 요청 본문으로 <code>&lt;textarea&gt;</code>의 내용을 파일에 저장하도록 합니다.</p>

<p><a class="p_ident" id="p_E3aBDoYaVe" href="#p_E3aBDoYaVe" tabindex="-1" role="presentation"></a>그런 다음 URL <code>/</code>에 대한 <code>GET</code> 요청에서 반환된 라인들을 포함하는 <code>&lt;option&gt;</code> 요소를 추가하여 서버의 최상위 디렉토리에 있는 모든 파일을 포함하는 요소를 추가할 수 있습니다. 사용자가 다른 파일을 (필드 상의 <code>&quot;change&quot;</code>이벤트) 선택하면 스크립트는 해당 파일을 가져와 표시해야 합니다. 파일을 저장할 때 현재 선택된 파일 이름을 사용하십시오.</p>

</div></div><nav><a href="19_paint.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="21_skillsharing.html" title="next chapter">▶</a></nav>
</article>