<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>함수</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 3;</script></head>

<article>
<nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>3장</span>함수</h1>

<blockquote>

<p><a class="p_ident" id="p_hkFlscMSbe" href="#p_hkFlscMSbe" tabindex="-1" role="presentation"></a>사람들은 컴퓨터 과학이 천재의 예술이라고 생각하지만 실제 현실은 그 반대입니다. 많은 사람들이 작은 돌로된 벽처럼 서로를 쌓아올리는 일을 하고 있습니다.</p>

<footer>Donald Knuth</footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_3.jpg" alt="Picture of fern leaves with a fractal shape"></figure>

<p><a class="p_ident" id="p_SVgYA3/kPi" href="#p_SVgYA3/kPi" tabindex="-1" role="presentation"></a>함수는 JavaScript 프로그래밍의 빵과 버터입니다. 값으로 프로그램 조각을 래핑하는 개념은 많은 용도가 있습니다. 그것은 더 큰 프로그램을 구조화하고, 반복을 줄이고, 이름을 하위 프로그램과 연결하고, 이러한 하위 프로그램을 서로 분리하는 방법을 제공합니다.</p>

<p><a class="p_ident" id="p_R3iRdVuyh5" href="#p_R3iRdVuyh5" tabindex="-1" role="presentation"></a>함수의 가장 명백한 적용은 새로운 어휘를 정의하는 것입니다. 산문에서 새로운 단어를 만드는 것은 일반적으로 나쁜 스타일입니다. 그러나 프로그래밍에서는 필수입니다.</p>

<p><a class="p_ident" id="p_PyAqHadpmm" href="#p_PyAqHadpmm" tabindex="-1" role="presentation"></a>일반적인 성인 영어 사용자는 어휘에 약 20,000개의 단어가 있습니다. 몇몇 프로그래밍 언어에 내장된 20,000개 명령이 제공됩니다. 어휘는 가능한 보다 정확하게 정의되어 있지만, 인간 언어보다 유연성이 덜어집니다. 따라서 일반적으로 너무 많은 반복을 피하기 위해 새로운 개념을 도입해야 합니다.</p>

<h2><a class="h_ident" id="h_tqLFw/oazr" href="#h_tqLFw/oazr" tabindex="-1" role="presentation"></a>함수 정의</h2>

<p><a class="p_ident" id="p_pBsAbh0THD" href="#p_pBsAbh0THD" tabindex="-1" role="presentation"></a>함수 정의는 바인딩 값이 함수인 일반 바인딩입니다. 예를 들어, 다음 코드는 주어진 숫자의 제곱을 생성하는 함수를 참조하는 <code>square</code>를 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JW7vLBZMWv" href="#c_JW7vLBZMWv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">12</span>));
<span class="cm-comment">// → 144</span></pre>

<p><a class="p_ident" id="p_pEd/iApjCb" href="#p_pEd/iApjCb" tabindex="-1" role="presentation"></a>키워드 <code>function</code>로 시작하는 표현식으로 함수가 생성됩니다. 함수에는 매개변수 집합(이 경우에는 <code>x</code>)과 함수가 호출될 때 실행될 명령문이 포함 된 본문이 있습니다. 이렇게 생성된 함수의 함수 본문은 단일 명령문으로 구성된 경우에도 항상 중괄호로 묶어야 합니다.</p>

<p><a class="p_ident" id="p_H5CjsrL2Dh" href="#p_H5CjsrL2Dh" tabindex="-1" role="presentation"></a>함수에는 여러 매개변수가 있거나 매개변수가 전혀 없을 수 있습니다. 다음 예에서 <code>makeNoise</code>는 매개변수 이름을 나열하지 않지만, <code>power</code>는 두 개를 나열합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8fTeYA4ABW" href="#c_8fTeYA4ABW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">makeNoise</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Pling!&quot;</span>);
};

<span class="cm-variable">makeNoise</span>();
<span class="cm-comment">// → Pling!</span>

<span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1024</span></pre>

<p><a class="p_ident" id="p_5CRGZYJdq3" href="#p_5CRGZYJdq3" tabindex="-1" role="presentation"></a><code>power</code> 및 <code>square</code>와 같은 일부 함수는 값을 생성하고 일부는 <code>makeNoise</code>와 같이 값을 생성하지 않습니다. <code>return</code> 문은 값을 함수가 반환합니다. 제어가 이러한 명령문을 발견하면 즉시 현재 함수에서 벗어나 해당 함수를 호출한 코드에 반환된 값을 제공합니다. 식이 없는 <code>return</code> 키워드는 함수가 <code>undefined</code>를 반환하게 됩니다. <code>makeNoise</code>와 같이 return 문이 전혀 없는 함수도 마찬가지로 <code>undefined</code>를 반환합니다.</p>

<p><a class="p_ident" id="p_tSSGXmQE8/" href="#p_tSSGXmQE8/" tabindex="-1" role="presentation"></a>함수에 대한 매개변수는 일반 바인딩처럼 작동하지만 초기 값은 함수 자체의 코드가 아니라 함수 호출자가 제공합니다.</p>

<h2><a class="h_ident" id="h_XqQR5FlX+8" href="#h_XqQR5FlX+8" tabindex="-1" role="presentation"></a>바인딩과 스코프</h2>

<p><a class="p_ident" id="p_l52g4cvZTH" href="#p_l52g4cvZTH" tabindex="-1" role="presentation"></a>각 바인딩은 바인딩이 가시적인 프로그램의 일부인 <em>범위(scope)</em>가 있습니다. 함수나 블록 외부에 정의된 바인딩의 경우 범위는 전체 프로그램입니다. 원하는 곳 어디에서나 이러한 바인딩을 참조할 수 있습니다. 이것을 <em>global</em>이라고 합니다.</p>

<p><a class="p_ident" id="p_+fqarrTTZ3" href="#p_+fqarrTTZ3" tabindex="-1" role="presentation"></a>함수 매개변수에 대해 생성되거나 함수 내부에서 선언된 바인딩은 해당 함수에서만 참조할 수 있으므로 로컬 바인딩이라고 합니다. 함수가 호출될 때마다 이러한 바인딩의 새 인스턴스가 생성됩니다. 이것은 함수 사이에 약간의 격리를 제공합니다. 각 함수 호출은 자체의 작은 세계(해당 로컬 환경)에서 작동하고 종종 글로벌 환경에서 무슨 일이 일어나는지 많이 알지 못해도 이해할 수 있습니다.</p>

<p><a class="p_ident" id="p_F5R+6ujj0e" href="#p_F5R+6ujj0e" tabindex="-1" role="presentation"></a><code>let</code>와 <code>const</code>로 선언된 바인딩은 그것들이 선언된 <em>블록</em>에 대해서만 가시적입니다. 따라서 루프 내에서 바인딩 중 하나를 생성하면 루프 전과 후의 코드는 그것을 볼 수 없습니다. 2015 이전의 JavaScript에서는 함수만이 새로운 범위를 생성하기 때문에 <code>var</code> 키워드로 생성된 구식 바인딩에서는 해당 바인딩이 나타나는 전체 함수에서 볼 수 있거나 또는 함수에 없는 경우 전역 범위 전체에서 볼 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_d7ecKvF5xD" href="#c_d7ecKvF5xD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-keyword">if</span> (<span class="cm-atom">true</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">z</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable">y</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
  <span class="cm-comment">// → 60</span>
}
<span class="cm-comment">// y is not visible here</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span> <span class="cm-operator">+</span> <span class="cm-variable">z</span>);
<span class="cm-comment">// → 40</span></pre>

<p><a class="p_ident" id="p_f7Rf2Pe44s" href="#p_f7Rf2Pe44s" tabindex="-1" role="presentation"></a>각 스코프는 주변 스코프를 감시할 수 있으므로 <code>x</code>는 블록 내에서 가시적입니다. 여러 바인딩의 이름이 같은 경우는 예외입니다. 이 경우 코드는 가장 안쪽에 있는 바인딩만 볼 수 있습니다. 예를 들어, <code>halve</code> 함수 내부의 코드가 <code>n</code>을 참조할 때 전역적인 <code>n</code>이 아닌 자체 <code>n</code>을 보고 있는 것입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_5g6POeoiQv" href="#c_5g6POeoiQv" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">halve</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">n</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
};

<span class="cm-keyword">let</span> <span class="cm-def">n</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">halve</span>(<span class="cm-number">100</span>));
<span class="cm-comment">// → 50</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">n</span>);
<span class="cm-comment">// → 10</span></pre>

<h3 id="scoping"><a class="i_ident" id="i_c/Ms2Ed/N0" href="#i_c/Ms2Ed/N0" tabindex="-1" role="presentation"></a>중첩 범위</h3>

<p><a class="p_ident" id="p_tVHjFnvTdQ" href="#p_tVHjFnvTdQ" tabindex="-1" role="presentation"></a>JavaScript는 <em>global</em> 및 <em>local</em> 바인딩을 구분하지 않습니다. 블록과 함수는 다른 블록과 함수 내부에 생성되어 여러 수준의 지역성을 생성할 수 있습니다.</p>

<p><a class="p_ident" id="p_XO/6uCTKGf" href="#p_XO/6uCTKGf" tabindex="-1" role="presentation"></a>예를 들어, hummus 배치를 만드는 데 필요한 재료를 출력하는 다음 함수에는 내부에 또 다른 함수가 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_cOSfyI1GsW" href="#c_cOSfyI1GsW" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">hummus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">const</span> <span class="cm-def">ingredient</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">amount</span>, <span class="cm-def">unit</span>, <span class="cm-def">name</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">ingredientAmount</span> <span class="cm-operator">=</span> <span class="cm-variable-2">amount</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">ingredientAmount</span> <span class="cm-operator">&gt;</span> <span class="cm-number">1</span>) {
      <span class="cm-variable-2">unit</span> <span class="cm-operator">+=</span> <span class="cm-string">&quot;s&quot;</span>;
    }
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">ingredientAmount</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">unit</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  };
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;can&quot;</span>, <span class="cm-string">&quot;chickpeas&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;tahini&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.25</span>, <span class="cm-string">&quot;cup&quot;</span>, <span class="cm-string">&quot;lemon juice&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;clove&quot;</span>, <span class="cm-string">&quot;garlic&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">2</span>, <span class="cm-string">&quot;tablespoon&quot;</span>, <span class="cm-string">&quot;olive oil&quot;</span>);
  <span class="cm-variable-2">ingredient</span>(<span class="cm-number">0.5</span>, <span class="cm-string">&quot;teaspoon&quot;</span>, <span class="cm-string">&quot;cumin&quot;</span>);
};</pre>

<p><a class="p_ident" id="p_UnbSAUz/Hi" href="#p_UnbSAUz/Hi" tabindex="-1" role="presentation"></a><code>ingredient</code> 함수 내부의 코드는 외부 함수로부터 <code>factor</code> 바인딩을 볼 수 있습니다. 그러나 <code>unit</code> 또는 <code>ingredientAmount</code>와 같은 로컬 바인딩은 외부 함수에서 볼 수 없습니다.</p>

<p><a class="p_ident" id="p_OFMMq4wzcg" href="#p_OFMMq4wzcg" tabindex="-1" role="presentation"></a>블록 내부에서 볼 수 있는 바인딩 집합은 프로그램 텍스트에서 해당 블록의 위치에 따라 결정됩니다. 또한 각 로컬 범위는 이를 포함하는 모든 로컬 범위를 볼 수 있으며 모든 범위는 전역 범위를 볼 수 있습니다. 바인딩 가시성에 대한 이러한 접근 방식을 <em>어휘 범위(lexical scoping)</em> 지정이라고 합니다.</p>

<h2><a class="h_ident" id="h_y6WGSsYfER" href="#h_y6WGSsYfER" tabindex="-1" role="presentation"></a>값으로서 함수</h2>

<p><a class="p_ident" id="p_EP0+emaZPf" href="#p_EP0+emaZPf" tabindex="-1" role="presentation"></a>함수 바인딩은 일반적으로 단순히 프로그램의 특정 부분에 대한 이름 역할을 합니다. 이러한 바인딩은 한 번 정의되고 변경되지 않습니다. 이렇게 하면 함수와 이름을 혼동하기 쉽습니다.</p>

<p><a class="p_ident" id="p_GmVFAjNN+C" href="#p_GmVFAjNN+C" tabindex="-1" role="presentation"></a>함수 값은 다른 값이 할 수 있는 모든 작업을 수행할 수 있습니다. 단순히 호출하는 것이 아니라 임의의 표현식에서 사용할 수 있습니다. 새 바인딩에 함수 값을 저장하고 함수에 인수로 전달하는 등의 작업이 가능합니다. 마찬가지로, 함수를 보유하는 바인딩은 여전히 일반 바인딩이며, 일정하지 않더라도 다음과 같이 새 값을 할당할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SZ7MmN0oGC" href="#c_SZ7MmN0oGC" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">missileSystem</span>.<span class="cm-property">launch</span>(<span class="cm-string">&quot;now&quot;</span>);
};
<span class="cm-keyword">if</span> (<span class="cm-variable">safeMode</span>) {
  <span class="cm-variable">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {<span class="cm-comment">/* do nothing */</span>};
}</pre>


<h2><a class="h_ident" id="h_H2WKvqbgVY" href="#h_H2WKvqbgVY" tabindex="-1" role="presentation"></a>선언 표기</h2>

<p><a class="p_ident" id="p_n4ivDQoJxV" href="#p_n4ivDQoJxV" tabindex="-1" role="presentation"></a>함수 바인딩을 만드는 약간 더 짧은 방법이 있습니다. <code>function</code> 키워드가 문의 시작 부분에 사용되면 다르게 작동합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4uHhsg+h7S" href="#c_4uHhsg+h7S" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
}</pre>

<p><a class="p_ident" id="p_duIlcl5Ee6" href="#p_duIlcl5Ee6" tabindex="-1" role="presentation"></a>이것은 함수 <em>선언</em>입니다. 명령문은 바인딩 <code>square</code>를 정의하고 지정된 함수를 가리킵니다. 작성하기가 약간 더 쉬우며 함수 뒤에 세미콜론이 필요하지 않습니다.</p>

<p><a class="p_ident" id="p_lCZw7EPvYa" href="#p_lCZw7EPvYa" tabindex="-1" role="presentation"></a>이 형식의 함수 정의에는 한 가지 미묘한 것이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_41Tuq8c/gg" href="#c_41Tuq8c/gg" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The future says:&quot;</span>, <span class="cm-variable">future</span>());

<span class="cm-keyword">function</span> <span class="cm-def">future</span>() {
  <span class="cm-keyword">return</span> <span class="cm-string">&quot;You'll never have flying cars&quot;</span>;
}</pre>

<p><a class="p_ident" id="p_OO22/MKYA8" href="#p_OO22/MKYA8" tabindex="-1" role="presentation"></a>위의 코드는 함수를 사용하는 코드 아래에 함수가 정의되어 있어도 작동합니다. 함수 선언은 일반적인 위에서 아래로 제어 흐름의 일부가 아닙니다. 개념적으로 범위의 맨 위로 이동하고 해당 범위의 모든 코드에서 사용할 수 있습니다. 이것은 사용하기 전에 모든 함수를 정의해야 하는 걱정 없이 의미 있는 방식으로 코드를 정렬할 수 있는 자유를 제공하기 때문에 때때로 유용합니다.</p>

<h2><a class="h_ident" id="h_/G0LSjQxoo" href="#h_/G0LSjQxoo" tabindex="-1" role="presentation"></a>화살표 함수</h2>

<p><a class="p_ident" id="p_3pnFB5yqlb" href="#p_3pnFB5yqlb" tabindex="-1" role="presentation"></a>함수에 대한 세 번째 표기법이 있는데, 이는 다른 표기법과 매우 다릅니다. <code>function</code> 키워드 대신 등호와 보다 큼 문자로 구성된 화살표(<code>=&gt;</code>)를 사용합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4WdKJKvocO" href="#c_4WdKJKvocO" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">power</span> <span class="cm-operator">=</span> (<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};</pre>

<p><a class="p_ident" id="p_spvzaI8qML" href="#p_spvzaI8qML" tabindex="-1" role="presentation"></a>화살표는 매개 변수 리스트 다음에 오고 함수의 몸체가 수반됩니다.</p>

<p><a class="p_ident" id="p_ylUHhZPsv6" href="#p_ylUHhZPsv6" tabindex="-1" role="presentation"></a>매개변수 이름이 하나만 있는 경우 매개변수 리스트 주위의 괄호를 생략할 수 있습니다. 몸체가 중괄호로 묶인 블록이 아니라 단일 표현식인 경우 해당 표현식이 함수에서 반환됩니다. 따라서 다음 두 <code>square</code> 정의는 동일한 작업을 수행합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VIDIsvgTjA" href="#c_VIDIsvgTjA" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">square1</span> <span class="cm-operator">=</span> (<span class="cm-def">x</span>) <span class="cm-operator">=&gt;</span> { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; };
<span class="cm-keyword">const</span> <span class="cm-def">square2</span> <span class="cm-operator">=</span> <span class="cm-def">x</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;</pre>

<p><a class="p_ident" id="p_fUkn+dhyOi" href="#p_fUkn+dhyOi" tabindex="-1" role="presentation"></a>화살표 함수에 매개변수가 전혀 없으면 매개변수 리스트는 빈 괄호 집합일 뿐입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VfJZoQnqTl" href="#c_VfJZoQnqTl" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">horn</span> <span class="cm-operator">=</span> () <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Toot&quot;</span>);
};</pre>

<h2 id="stack"><a class="h_ident" id="h_D2Yui+mx6D" href="#h_D2Yui+mx6D" tabindex="-1" role="presentation"></a>호출 스택</h2>

<p><a class="p_ident" id="p_0M8AnI8lnL" href="#p_0M8AnI8lnL" tabindex="-1" role="presentation"></a>함수를 통한 제어 흐름 방식은 다소 관련이 있습니다. 자세히 살펴보겠습니다. 다음은 몇 가지 함수 호출을 수행하는 간단한 프로그램입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_vruWG+bXUz" href="#c_vruWG+bXUz" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">greet</span>(<span class="cm-def">who</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Hello &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">who</span>);
}
<span class="cm-variable">greet</span>(<span class="cm-string">&quot;Harry&quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Bye&quot;</span>);</pre>

<p><a class="p_ident" id="p_XTLaqYuUGF" href="#p_XTLaqYuUGF" tabindex="-1" role="presentation"></a>이 프로그램의 실행은 대략 다음과 같습니다. <code>greet</code>에 대한 호출은 제어가 해당 함수의 시작 부분으로 이동하도록 합니다. 함수는 <code>console.log</code>를 호출하고 작업을 수행한 다음 제어를 두 번째 라인으로 반환합니다. 거기에서 <code>greet</code> 함수의 끝에 도달하므로 이를 호출한 곳인 4번째 라닝으로 돌아갑니다. 그 뒤의 라인은 <code>console.log</code>를 다시 호출합니다. 반환 후에 프로그램은 끝에 도달합니다.</p>

<p><a class="p_ident" id="p_l2J0qZcbr2" href="#p_l2J0qZcbr2" tabindex="-1" role="presentation"></a>다음과 같이 제어 흐름을 도식적으로 표시할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_sK38O0sD4t" href="#c_sK38O0sD4t" tabindex="-1" role="presentation"></a>not in function
   in greet
        in console.log
   in greet
not in function
   in console.log
not in function</pre>

<p><a class="p_ident" id="p_osbZNdYf81" href="#p_osbZNdYf81" tabindex="-1" role="presentation"></a>함수는 반환될 때 호출한 위치로 다시 점프해야 하므로 컴퓨터는 호출이 발생한 컨텍스트를 기억해야 합니다. <code>console.log</code>는 완료되면 <code>greet</code> 함수로 돌아가야 합니다. 다른 경우에는 프로그램의 끝으로 돌아갑니다.</p>

<p><a class="p_ident" id="p_PCO8aj4Plj" href="#p_PCO8aj4Plj" tabindex="-1" role="presentation"></a>컴퓨터가 이러한 컨텍스트를 저장하는 위치는 스택입니다. 함수가 호출될 때마다 현재 컨텍스트가 이 스택의 맨 위에 저장됩니다. 함수가 반환되면 스택에서 최상위 컨텍스트를 제거하고 해당 컨텍스트를 사용하여 실행을 계속합니다.</p>

<p><a class="p_ident" id="p_HxxwtLgAhP" href="#p_HxxwtLgAhP" tabindex="-1" role="presentation"></a>이 스택을 저장하려면 컴퓨터 메모리에 공간이 필요합니다. 스택이 너무 커지면 스택 공간 부족 또는 재귀가 너무 많음과 같은 메시지와 함께 컴퓨터가 실패합니다. 다음 코드는 컴퓨터에 두 함수 간에 무한한 왕복을 일으키는 경우를 나타냅니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fZaWglCohr" href="#c_fZaWglCohr" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">chicken</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">egg</span>();
}
<span class="cm-keyword">function</span> <span class="cm-def">egg</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">chicken</span>();
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">chicken</span>() <span class="cm-operator">+</span> <span class="cm-string">&quot; came first.&quot;</span>);
<span class="cm-comment">// → ??</span></pre>

<h2><a class="h_ident" id="h_1pGtRjrCUp" href="#h_1pGtRjrCUp" tabindex="-1" role="presentation"></a>선택적 인수</h2>

<p><a class="p_ident" id="p_npZ63wzfMQ" href="#p_npZ63wzfMQ" tabindex="-1" role="presentation"></a>다음 코드는 문제가 없이 실행됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IckdVt0tqA" href="#c_IckdVt0tqA" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">4</span>, <span class="cm-atom">true</span>, <span class="cm-string">&quot;hedgehog&quot;</span>));
<span class="cm-comment">// → 16</span></pre>

<p><a class="p_ident" id="p_JyyXKkZ6u6" href="#p_JyyXKkZ6u6" tabindex="-1" role="presentation"></a>하나의 매개변수를 갖는 <code>square</code>를 정의했습니다. 그것을 3으로 호출했을 때, 언어는 불평하지 않습니다. 추가 인수를 무시하고 첫 번째 인수의 제곱을 계산합니다.</p>

<p><a class="p_ident" id="p_kzCivbonMM" href="#p_kzCivbonMM" tabindex="-1" role="presentation"></a>JavaScript는 함수에 전달하는 인수의 수에 대해 너그럽습니다. 너무 많이 주면 추가 항목은 무시됩니다. 너무 적게 전달하면 누락된 매개변수에 <code>undefined</code> 값이 할당됩니다.</p>

<p><a class="p_ident" id="p_U01Tix9/O1" href="#p_U01Tix9/O1" tabindex="-1" role="presentation"></a>이것의 단점은 실수로 잘못된 수의 인수를 함수에 전달할 가능성이 있다는 것입니다.</p>

<p><a class="p_ident" id="p_+iLdQF0mc4" href="#p_+iLdQF0mc4" tabindex="-1" role="presentation"></a>장점은 이 동작을 사용하여 다른 수의 인수로 함수를 호출할 수 있다는 것입니다. 예를 들어, 다음 <code>minus</code> 함수는 하나 또는 두 개의 인수에 대해 작동하여 <code>-</code> 연산자를 모방합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8zGcY0SKdo" href="#c_8zGcY0SKdo" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">minus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">b</span> <span class="cm-operator">===</span> <span class="cm-atom">undefined</span>) <span class="cm-keyword">return</span> <span class="cm-operator">-</span><span class="cm-variable-2">a</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">-</span> <span class="cm-variable-2">b</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">minus</span>(<span class="cm-number">10</span>, <span class="cm-number">5</span>));
<span class="cm-comment">// → 5</span></pre>

<p id="power"><a class="p_ident" id="p_CqaWdlpcAr" href="#p_CqaWdlpcAr" tabindex="-1" role="presentation"></a>매개 변수 다음에 <code>=</code> 연산자를 사용하면(식이 수반된) 해당 식의 값은 인수가 주어지지 않을 때 인수를 대체합니다.</p>

<p><a class="p_ident" id="p_MIT3QGp7wx" href="#p_MIT3QGp7wx" tabindex="-1" role="presentation"></a>예를 들어, <code>power</code>의 다음 버전은 그것이 갖는 두 번재 인수를 선택적으로 사용할 수 있도록 합니다. 제공하지 않거나 <code>undefined</code> 값을 전달하면 기본 값이 2가 되고, 함수는 <code>square</code>처럼 작동합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_nTMMMpMRLQ" href="#c_nTMMMpMRLQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 16</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">6</span>));
<span class="cm-comment">// → 64</span></pre>

<p><a class="p_ident" id="p_HXV4vPfIcZ" href="#p_HXV4vPfIcZ" tabindex="-1" role="presentation"></a>다음 장에서 함수 본문이 전달된 인수의 전체 리스트를 얻을 수 있는 방법을 볼 수 있습니다. 이것은 함수가 인수의 개수를 허용할 수 있도록 하기 때문에 유용합니다. 예를 들어, <code>console.log</code>를 사용하면 주어진 모든 값을 출력합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RvkwVkcUZ7" href="#c_RvkwVkcUZ7" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;C&quot;</span>, <span class="cm-string">&quot;O&quot;</span>, <span class="cm-number">2</span>);
<span class="cm-comment">// → C O 2</span></pre>

<h2><a class="h_ident" id="h_hOd+yVxaku" href="#h_hOd+yVxaku" tabindex="-1" role="presentation"></a>폐쇄(Closure)</h2>

<p><a class="p_ident" id="p_Y88pfbKskW" href="#p_Y88pfbKskW" tabindex="-1" role="presentation"></a>함수를 값으로 처리하는 기능과 함께 함수가 호출될 때마다 로컬 바인딩이 다시 생성된다는 사실은 흥미로운 질문을 제기합니다. 로컬 바인딩을 생성한 함수 호출이 더 이상 활성화되지 않으면 로컬 바인딩은 어떻게 되는가?</p>

<p><a class="p_ident" id="p_f5+48lfrgA" href="#p_f5+48lfrgA" tabindex="-1" role="presentation"></a>다음 코드는 이에 대한 예를 나타냅니다. 로컬 바인딩을 생성하는 함수 <code>wrapValue</code>를 정의합니다. 그런 다음 이 로컬 바인딩에 액세스하고 반환하는 함수를 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_DF70h3opbx" href="#c_DF70h3opbx" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">wrapValue</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;
  <span class="cm-keyword">return</span> () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">local</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">wrap1</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">1</span>);
<span class="cm-keyword">let</span> <span class="cm-def">wrap2</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap1</span>());
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap2</span>());
<span class="cm-comment">// → 2</span></pre>

<p><a class="p_ident" id="p_lgksIxSi8X" href="#p_lgksIxSi8X" tabindex="-1" role="presentation"></a>이것은 허용되며 원하는 대로 작동합니다. 바인딩의 두 인스턴스 모두 계속 액세스할 수 있습니다. 이 상황은 모든 호출에 대해 로컬 바인딩이 새로 생성되고 다른 호출이 서로의 로컬 바인딩을 짓밟을 수 없다는 사실을 잘 보여줍니다.</p>

<p><a class="p_ident" id="p_O3ISvGjNhj" href="#p_O3ISvGjNhj" tabindex="-1" role="presentation"></a>둘러싸는 범위에서 로컬 바인딩의 특정 인스턴스를 참조할 수 있는 이 기능을 <em>closure</em>라 합니다. 주변의 로컬 범위에서 바인딩을 참조하는 함수를 클로저라 합니다. 이 동작을 사용하면 바인딩 수명에 대해 걱정할 필요가 없을 뿐만 아니라 몇 가지 창의적인 방법으로 함수 값을 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_YtnB1+ZhQb" href="#p_YtnB1+ZhQb" tabindex="-1" role="presentation"></a>약간의 변경으로 이전 예를 임의의 양으로 곱하는 함수를 만드는 방법으로 바꿀 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_iIlCVmvMSs" href="#c_iIlCVmvMSs" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">multiplier</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-def">number</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">number</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
}

<span class="cm-keyword">let</span> <span class="cm-def">twice</span> <span class="cm-operator">=</span> <span class="cm-variable">multiplier</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">twice</span>(<span class="cm-number">5</span>));
<span class="cm-comment">// → 10</span></pre>

<p><a class="p_ident" id="p_fVSBR58hMQ" href="#p_fVSBR58hMQ" tabindex="-1" role="presentation"></a>매개변수 자체가 로컬 바인딩이기 때문에 <code>wrapValue</code> 예의 명시적 로컬 바인딩은 실제로 필요하지 않습니다.</p>

<p><a class="p_ident" id="p_cC96lnpdpR" href="#p_cC96lnpdpR" tabindex="-1" role="presentation"></a>이와 같은 프로그램을 작성하려면 약간의 연습이 필요합니다. 좋은 모델은 함수 값을 몸체 코드와 코드가 생성되는 환경 모두를 포함하는 것으로 간주하는 것입니다. 호출될 때 함수 본문은 호출된 환경이 아니라 생성된 환경을 봅니다.</p>

<p><a class="p_ident" id="p_tgRn+dIrL8" href="#p_tgRn+dIrL8" tabindex="-1" role="presentation"></a>예에서 <code>multiplier</code>가 호출되고 그것의 <code>factor</code> 매개 변수가 2로 결합되는 환경을 생성합니다. 반환되는 함수 값은 (<code>twice</code>에 저장) 이러한 환경을 기억합니다. 따라서 호출될 때 인수에 2를 곱합니다.</p>

<h2><a class="h_ident" id="h_jxl1p970Fy" href="#h_jxl1p970Fy" tabindex="-1" role="presentation"></a>순환</h2>

<p><a class="p_ident" id="p_LKVxHXuHsE" href="#p_LKVxHXuHsE" tabindex="-1" role="presentation"></a>스택 오버플로가 너무 자주 수행되지 않는 한 함수가 자체를 호출하는 것은 완벽하게 괜찮습니다. 자신을 호출하는 함수를 재귀라 합니다. 재귀를 사용하면 일부 함수를 다른 스타일로 작성할 수 있습니다. 예를 들어 다음과 같은 <code>power</code>의 또 다른 구현을 살펴보십시오.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_agdELfiRGm" href="#c_agdELfiRGm" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponent</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">base</span> <span class="cm-operator">*</span> <span class="cm-variable">power</span>(<span class="cm-variable-2">base</span>, <span class="cm-variable-2">exponent</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
  }
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 8</span></pre>

<p><a class="p_ident" id="p_/7VYZ2mLWF" href="#p_/7VYZ2mLWF" tabindex="-1" role="presentation"></a>이것은 수학자들이 지수화를 정의하는 방식에 가깝고 반복 변형보다 개념을 더 명확하게 설명합니다. 이 함수는 반복 곱셈을 달성하기 위해 더 작은 지수로 여러 번 자신을 호출합니다.</p>

<p><a class="p_ident" id="p_0kxF7WAzdn" href="#p_0kxF7WAzdn" tabindex="-1" role="presentation"></a>그러나 이 구현에는 한 가지 문제가 있습니다. 일반적인 JavaScript 구현에서는 반복 버전보다 약 3배 느립니다. 간단한 루프를 실행하는 것은 일반적으로 함수를 여러 번 호출하는 것보다 저렴합니다.</p>

<p><a class="p_ident" id="p_wtRoace6Zn" href="#p_wtRoace6Zn" tabindex="-1" role="presentation"></a>속도 대비 우아함의 딜레마는 흥미로운 것입니다. 인간 친화적인 것과 기계 친화적인 것 사이의 일종의 연속체로 볼 수 있습니다. 거의 모든 프로그램을 더 크고 복잡하게 만들면 더 빠르게 만들 수 있습니다. 프로그래머는 적절한 균형을 결정해야 합니다.</p>

<p><a class="p_ident" id="p_NQDJXQ8GE2" href="#p_NQDJXQ8GE2" tabindex="-1" role="presentation"></a><code>power</code> 함수의 경우에 루프 버전은 여전히 상당히 간단하고 읽기 쉽습니다. 재귀 버전으로 대체하는 것은 의미가 없습니다. 그러나 종종 프로그램은 프로그램을 보다 직관적으로 만들기 위해 일부 효율성을 포기하는 것이 도움이 되는 복잡한 개념을 다룹니다.</p>

<p><a class="p_ident" id="p_m264IT3dFt" href="#p_m264IT3dFt" tabindex="-1" role="presentation"></a>순환은 항상 루핑에 대한 비효율적인 대안이 아닙니다. 일부 문제는 루프보다 순환으로 해결하기가 더 쉽습니다. 대부분의 경우 이러한 문제는 여러 분기를 탐색하거나 처리해야 하며, 각 분기는 더 많은 분기로 다시 분기될 수 있습니다.</p>

<p id="recursive_puzzle"><a class="p_ident" id="p_s9LmvfKAdX" href="#p_s9LmvfKAdX" tabindex="-1" role="presentation"></a>다음과 같은 퍼즐을 생각해 보십시오. 숫자 1에서 시작하여 반복적으로 5를 더하거나 3을 곱하면 무한한 숫자 집합이 생성될 수 있습니다. 숫자가 주어졌을 때 그 숫자를 생성하는 덧셈과 곱셈의 수열을 찾으려는 함수를 어떻게 작성하겠습니까?</p>

<p><a class="p_ident" id="p_mWzvA1dWtJ" href="#p_mWzvA1dWtJ" tabindex="-1" role="presentation"></a>예를 들어, 숫자 13은 먼저 3을 곱한 다음 5를 두 번 더하면 도달할 수 있지만 숫자 15는 전혀 도달할 수 없습니다.</p>

<p><a class="p_ident" id="p_ca4W5yMbty" href="#p_ca4W5yMbty" tabindex="-1" role="presentation"></a>다음은 순환 솔루션을 나타냅니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WGJ7JdCP7T" href="#c_WGJ7JdCP7T" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findSolution</span>(<span class="cm-def">target</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">find</span>(<span class="cm-def">current</span>, <span class="cm-def">history</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">history</span>;
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">current</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">target</span>) {
      <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">+</span> <span class="cm-number">5</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">+ 5)`</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span>
             <span class="cm-variable-2">find</span>(<span class="cm-variable-2">current</span> <span class="cm-operator">*</span> <span class="cm-number">3</span>, <span class="cm-string-2">`(${</span><span class="cm-variable-2">history</span><span class="cm-string-2">}</span> <span class="cm-string-2">* 3)`</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-number">1</span>, <span class="cm-string">&quot;1&quot;</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findSolution</span>(<span class="cm-number">24</span>));
<span class="cm-comment">// → (((1 * 3) + 5) * 3)</span></pre>

<p><a class="p_ident" id="p_TgOX2ClB7+" href="#p_TgOX2ClB7+" tabindex="-1" role="presentation"></a>이 프로그램은 반드시 가장 짧은 작업 수열을 찾는 것은 아닙니다. 모든 수열을 찾으면 만족합니다.</p>

<p><a class="p_ident" id="p_GCxpDILpM6" href="#p_GCxpDILpM6" tabindex="-1" role="presentation"></a>바로 작동하는지 확인하지 않아도 괜찮습니다. 재귀적 사고에 대한 훌륭한 연습이 되기 때문에 그것을 통해 작업해 봅시다.</p>

<p><a class="p_ident" id="p_AlwczX9axy" href="#p_AlwczX9axy" tabindex="-1" role="presentation"></a>내부 함수 <code>find</code>는 실제 재귀를 수행합니다. 두 개의 인수가 필요합니다. 현재 숫자와 이 숫자에 도달한 방법을 기록하는 문자열입니다. 솔루션을 찾으면 대상에 도달하는 방법을 보여주는 문자열을 반환합니다. 이 숫자에서 시작하는 솔루션을 찾을 수 없으면 <code>null</code>을 반환합니다.</p>

<p><a class="p_ident" id="p_2m+jfYF6Yv" href="#p_2m+jfYF6Yv" tabindex="-1" role="presentation"></a>이를 위해 함수는 세 가지 작업 중 하나를 수행합니다. 현재 숫자가 목표 숫자라면 현재 이력은 그 목표에 도달하는 방법이므로 반환한다. 현재 숫자가 목표값보다 크면 더하기와 곱하기 모두 숫자를 더 크게 만들 뿐이므로 이 분기를 더 탐색하는 것은 의미가 없습니다. 마지막으로, 여전히 목표 숫자 아래에 있다면 함수는 자신을 두 번 호출하여 현재 숫자에서 시작하는 가능한 경로를 모두 시도합니다. 한 번은 더하기, 한 번은 곱하기입니다. 첫 번째 호출이 <code>null</code>이 아닌 것을 반환하면 됩니다. 그렇지 않으면 문자열 또는 <code>null</code>을 생성하는지 여부에 관계없이 두 번째 호출이 반환됩니다.</p>

<p><a class="p_ident" id="p_QvX/6dUvST" href="#p_QvX/6dUvST" tabindex="-1" role="presentation"></a>이 함수에 대한 이해를 위해 숫자 13에 대한 솔루션을 검색할 때 만들어진 모든 <code>find</code> 호출을 살펴보겠습니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_KtyfRslIz2" href="#c_KtyfRslIz2" tabindex="-1" role="presentation"></a>find(1, &quot;1&quot;)
  find(6, &quot;(1 + 5)&quot;)
    find(11, &quot;((1 + 5) + 5)&quot;)
      find(16, &quot;(((1 + 5) + 5) + 5)&quot;)
        too big
      find(33, &quot;(((1 + 5) + 5) * 3)&quot;)
        too big
    find(18, &quot;((1 + 5) * 3)&quot;)
      too big
  find(3, &quot;(1 * 3)&quot;)
    find(8, &quot;((1 * 3) + 5)&quot;)
      find(13, &quot;(((1 * 3) + 5) + 5)&quot;)
        found!</pre>

<p><a class="p_ident" id="p_Akhgah+Kcu" href="#p_Akhgah+Kcu" tabindex="-1" role="presentation"></a>처음 <code>find</code>가 호출되면 <code>(1 + 5)</code>로 시작하는 솔루션을 탐색하기 위해 자신을 호출하여 시작합니다. 그 호출은 목표 숫자보다 작거나 같은 숫자를 산출하는 모든 연속 솔루션 을 탐색하기 위해 더 재귀할 것입니다. 목표물에 맞는 것을 찾지 못했기 때문에 첫 번째 호출에서 다시 <code>null</code>을 반환합니다. <code>||</code> 연산자는 탐색하는 호출이 <code>(1 * 3)</code>을 발생하도록 합니다. 이 검색에는 더 많은 운이 따릅니다. 첫 번째 재귀 호출은 또 다른 재귀 호출을 통해 대상 넘버에 도달합니다. 가장 안쪽 호출은 문자열을 반환하고 중간 호출의 각 <code>||</code> 연산자는 해당 문자열을 전달하여 궁극적으로 솔루션을 반환합니다.</p>

<h2><a class="h_ident" id="h_eVDWIAuyBK" href="#h_eVDWIAuyBK" tabindex="-1" role="presentation"></a>함수 도입</h2>

<p><a class="p_ident" id="p_/Xqzd2kxYz" href="#p_/Xqzd2kxYz" tabindex="-1" role="presentation"></a>함수가 프로그램에 도입되는 자연스러운 방식에는 두 가지가 있습니다.</p>

<p><a class="p_ident" id="p_zNh7WEzSLI" href="#p_zNh7WEzSLI" tabindex="-1" role="presentation"></a>첫 번째는 유사한 코드를 여러 번 작성하는 자신을 발견한다는 것입니다. 그렇게 하지 않는 것이 좋습니다. 코드가 더 많다는 것은 실수를 숨길 공간이 더 많고 프로그램을 이해하려는 사람들이 읽을 자료가 더 많다는 것을 의미합니다. 따라서 반복되는 기능을 취하여 적절한 이름을 찾아 함수에 넣습니다.</p>

<p><a class="p_ident" id="p_HJxU0H/STP" href="#p_HJxU0H/STP" tabindex="-1" role="presentation"></a>두 번째는 아직 작성하지 않은 기능이 필요하고 자체 기능이 필요한 것처럼 들리는 것입니다. 먼저 함수의 이름을 지정한 다음 본문을 작성합니다. 실제로 함수 자체를 정의하기 전에 함수를 사용하는 코드 작성을 시작할 수도 있습니다.</p>

<p><a class="p_ident" id="p_7YCpyNM9KP" href="#p_7YCpyNM9KP" tabindex="-1" role="presentation"></a>함수에 대해 좋은 이름을 찾는 것이 얼마나 어려운지는 감싸고자 하는 개념이 얼마나 명확한지를 잘 보여줍니다. 예를 들어 보겠습니다.</p>

<p><a class="p_ident" id="p_NB82EwGY1X" href="#p_NB82EwGY1X" tabindex="-1" role="presentation"></a>두 개의 숫자를 인쇄하는 프로그램을 작성한다고 합시다. 농장의 소와 닭의 숫자, 단어 <code>Cows</code>와 그 다음에 <code>Chickens</code> 그리고 두 숫자 앞에 0을 채워 항상 세 자리 숫자가 되도록 합니다.</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_NGDR3Ll2Zn" href="#c_NGDR3Ll2Zn" tabindex="-1" role="presentation"></a>007 Cows
011 Chickens</pre>

<p><a class="p_ident" id="p_YmL+RnMybe" href="#p_YmL+RnMybe" tabindex="-1" role="presentation"></a>이것은 소의 수와 닭의 수라는 두 가지 인수의 함수를 요구합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RO+Vw8FSPK" href="#c_RO+Vw8FSPK" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">cowString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">cows</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">cowString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">cowString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">cowString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">cowString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">chickenString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">chickens</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">chickenString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">chickenString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">chickenString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">chickenString</span><span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
}
<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>);</pre>

<p><a class="p_ident" id="p_YLs54aH93M" href="#p_YLs54aH93M" tabindex="-1" role="presentation"></a>문자열 표현식 뒤에 <code>.length</code>를 작성하면 해당 문자열의 길이를 알 수 있습니다. 따라서 <code>while</code> 루프는 길이가 최소 3자가 될 때까지 숫자 문자열 앞에 0을 계속 추가합니다.</p>

<p><a class="p_ident" id="p_8ePN7y41fs" href="#p_8ePN7y41fs" tabindex="-1" role="presentation"></a>돼지를 인쇄할 수 있도록 소프트웨어를 확장해 보도록 합니다. 다음은 첫 번째 시도입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RHETS/If7p" href="#c_RHETS/If7p" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">printZeroPaddedWithLabel</span>(<span class="cm-def">number</span>, <span class="cm-def">label</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">numberString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">numberString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) {
    <span class="cm-variable-2">numberString</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">numberString</span>;
  }
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">numberString</span><span class="cm-string-2">}</span> <span class="cm-string-2">${</span><span class="cm-variable-2">label</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">cows</span>, <span class="cm-string">&quot;Cows&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-string">&quot;Chickens&quot;</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-string">&quot;Pigs&quot;</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>, <span class="cm-number">3</span>);</pre>

<p><a class="p_ident" id="p_6/4BxnwWvK" href="#p_6/4BxnwWvK" tabindex="-1" role="presentation"></a>효과가 있지만, 이름 <code>printZeroPaddedWithLabel</code>가 조금 생소합니다. 인쇄, 제로 패딩 및 라벨 추가의 세 가지를 단일 기능으로 통합합니다.</p>

<p><a class="p_ident" id="p_/zEyox400N" href="#p_/zEyox400N" tabindex="-1" role="presentation"></a>프로그램 전체에서 반복되는 부분을 제거하고 단일 개념을 선택하도록 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_L3v+xO5gBH" href="#c_L3v+xO5gBH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">zeroPad</span>(<span class="cm-def">number</span>, <span class="cm-def">width</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">string</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">width</span>) {
    <span class="cm-variable-2">string</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;0&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">string</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-def">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">cows</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Cows`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Chickens`</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-number">3</span>)<span class="cm-string-2">}</span> <span class="cm-string-2">Pigs`</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">16</span>, <span class="cm-number">3</span>);</pre>

<p><a class="p_ident" id="p_pRacTERPvh" href="#p_pRacTERPvh" tabindex="-1" role="presentation"></a>멋지고 분명한 이름을 가진 함수 zeroPad는 코드를 읽는 사람이 그 역할을 더 쉽게 이해할 수 있도록 합니다. 그리고 이러한 함수는 이 특정 프로그램보다 더 많은 상황에서 유용합니다. 예를 들어, 잘 정렬된 숫자 표를 인쇄하는 데 사용할 수 있습니다.</p>

<h2 id="pure"><a class="h_ident" id="h_EdyBGBF6y/" href="#h_EdyBGBF6y/" tabindex="-1" role="presentation"></a>함수와 측면 효과</h2>

<p><a class="p_ident" id="p_WWC8zZChk6" href="#p_WWC8zZChk6" tabindex="-1" role="presentation"></a>함수는 크게 측면 효과를 위해 호출되는 함수와 반환 값을 위해 호출되는 함수로 나눌 수 있습니다(물론 모두 측면 효과가 있고 값을 반환하는 것도 가능함).</p>

<p><a class="p_ident" id="p_NoFe+XFM0N" href="#p_NoFe+XFM0N" tabindex="-1" role="presentation"></a>농장 예의 첫 번째 도우미 함수 <code>printZeroPaddedWithLabel</code>는 측면 효과로 호출됩니다. 한 줄을 인쇄합니다. 두 번째 버전인 <code>zeroPad</code>는 반환 값을 위해 호출됩니다. 두 번째가 첫 번째보다 더 많은 상황에서 유용하다는 것은 우연이 아닙니다. 값을 생성하는 함수는 측면 효과를 직접 수행하는 함수보다 새로운 방식으로 결합하기가 더 쉽습니다.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_LLhiHGkZNx" href="#p_LLhiHGkZNx" tabindex="-1" role="presentation"></a>이 페이지에서는 고유한 함수를 작성하는 방법을 나타냈습니다. <code>function</code> 키워드는 식으로 사용될 경우 함수 값을 생성 할 수 있습니다. 명령문으로 사용하면 바인딩을 선언하고 값으로 함수를 제공하는 데 사용할 수 있습니다. 화살표 함수는 함수를 만드는 또 다른 방법입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x2/+thzlca" href="#c_x2/+thzlca" tabindex="-1" role="presentation"></a><span class="cm-comment">// Define f to hold a function value</span>
<span class="cm-keyword">const</span> <span class="cm-def">f</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">a</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-number">2</span>);
};

<span class="cm-comment">// Declare g to be a function</span>
<span class="cm-keyword">function</span> <span class="cm-def">g</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span> <span class="cm-operator">*</span> <span class="cm-number">3.5</span>;
}

<span class="cm-comment">// A less verbose function value</span>
<span class="cm-keyword">let</span> <span class="cm-def">h</span> <span class="cm-operator">=</span> <span class="cm-def">a</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span> <span class="cm-operator">%</span> <span class="cm-number">3</span>;</pre>

<p><a class="p_ident" id="p_2uxoSaANas" href="#p_2uxoSaANas" tabindex="-1" role="presentation"></a>함수 이해의 핵심은 범위를 이해하는 것입니다. 각 블록은 새 범위를 만듭니다. 지정된 범위에서 선언된 매개변수 및 바인딩은 로컬이며 외부에서 볼 수 없습니다. <code>var</code>로 선언된 바인딩은 다르게 동작합니다. 가장 가까운 함수 범위 또는 전역 범위입니다.</p>

<p><a class="p_ident" id="p_MIZ+5rL4hE" href="#p_MIZ+5rL4hE" tabindex="-1" role="presentation"></a>프로그램이 수행하는 작업을 다른 함수들로 분리하는 것이 도움이 됩니다. 자신을 많이 반복할 필요가 없으며 함수는 코드를 특정 작업을 수행하는 조각으로 그룹화하여 프로그램을 구성하는 데 도움이 될 수 있습니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_XTmO7z7MPq" href="#i_XTmO7z7MPq" tabindex="-1" role="presentation"></a>Minimum</h3>

<p><a class="p_ident" id="p_aW/Uoj4mDd" href="#p_aW/Uoj4mDd" tabindex="-1" role="presentation"></a>두 개의 인수를 취하고 최소값을 반환하는 함수 <code>min</code>을 작성합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_zoK4eQ6E3E" href="#c_zoK4eQ6E3E" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_jbGq7vKDsS" href="#p_jbGq7vKDsS" tabindex="-1" role="presentation"></a>유효한 함수 정의를 얻기 위해 올바른 위치에 중괄호와 괄호를 배치하는 데 문제가 있는 경우 이 페이지의 예 중 하나를 복사하고 수정하여 시작하십시오.</p>

<p><a class="p_ident" id="p_V+p4wKaMty" href="#p_V+p4wKaMty" tabindex="-1" role="presentation"></a>함수에는 여러 <code>return</code> 명령문이 포함될 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_jxl1p970Fy" href="#i_jxl1p970Fy" tabindex="-1" role="presentation"></a>순환</h3>

<p><a class="p_ident" id="p_jU1r1XPp0G" href="#p_jU1r1XPp0G" tabindex="-1" role="presentation"></a>나머지 연산자 <code>%</code>는 짝수와 홀수 구분에 사용될 수 있습니다. 다음은 양의 정수가 짝수인지 홀수인지 정의하는 또 다른 방법입니다.</p>

<ul>

<li>

<p><a class="p_ident" id="p_lCOBPDdrEk" href="#p_lCOBPDdrEk" tabindex="-1" role="presentation"></a>0은 짝수</p></li>

<li>

<p><a class="p_ident" id="p_fWhtKbL+Su" href="#p_fWhtKbL+Su" tabindex="-1" role="presentation"></a>1은 홀수</p></li>

<li>

<p><a class="p_ident" id="p_1dwrqpocrW" href="#p_1dwrqpocrW" tabindex="-1" role="presentation"></a>따른 수 <em>N</em>에 관해 그것의 짝수 여부는 <em>N</em> - 2를 사용하는 것입니다.</p></li></ul>

<p><a class="p_ident" id="p_zxMN8E0WOI" href="#p_zxMN8E0WOI" tabindex="-1" role="presentation"></a>순환 함수 <code>isEven</code>을 작성합니다. 함수는 단일 매개변수 (양수, 정수)를 허용하고 부울을 반환해야 합니다.</p>

<p><a class="p_ident" id="p_0+fMeza2x5" href="#p_0+fMeza2x5" tabindex="-1" role="presentation"></a>50과 75를 테스트 합니다. -1에서 어떻게 작동하는지 확인합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_7Dyz/3MMqh" href="#c_7Dyz/3MMqh" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">50</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">75</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → ??</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_Y58IopmAbB" href="#p_Y58IopmAbB" tabindex="-1" role="presentation"></a>함수는 이 페이지의 <code>findSolution</code>의 <code>find</code>와 유사해야 합니다. 최종 <code>else</code>는 세 번째 경우에 대응하고 순환 호출을 가집니다. 각 분기는 <code>return</code>을 포함하거나 다른 방식으로 반환될 특정 값의 배치이어야 합니다.</p>

<p><a class="p_ident" id="p_QIaN+xYJ+M" href="#p_QIaN+xYJ+M" tabindex="-1" role="presentation"></a>음수가 주어지면 함수는 계속해서 반복되어 더 많은 음수를 전달하므로 결과를 반환하는데 점점 더 멀어집니다. 결국 스택 공간이 부족하여 중단됩니다.</p>

</div></div>

<h3><a class="i_ident" id="i_3rsiDgC2do" href="#i_3rsiDgC2do" tabindex="-1" role="presentation"></a>Bean 헤아리기</h3>

<p><a class="p_ident" id="p_8y74cOkS91" href="#p_8y74cOkS91" tabindex="-1" role="presentation"></a><code>&quot;string&quot;[N]</code>를 작성하여 문자열에서 N번째 문자 또는 문자를 가져올 수 있습니다. 반환된 값은 하나의 문자만 포함하는 문자열입니다(예: <code>&quot;b&quot;</code>). 첫 번째 문자의 위치는 0이므로 마지막 문자는 <code>string.<wbr>length - 1</code> 위치에서 찾을 수 있습니다. 즉, 두 문자 문자열의 길이는 2이고 해당 문자의 위치는 0과 1입니다.</p>

<p><a class="p_ident" id="p_3+wBcfMbYR" href="#p_3+wBcfMbYR" tabindex="-1" role="presentation"></a>문자열을 유일한 인수로 취하고 문자열에 대문자 "B"가 몇 개 있는지 나타내는 숫자를 반환하는 함수 <code>countBs</code>를 작성하십시오.</p>

<p><a class="p_ident" id="p_WdA52+sgwM" href="#p_WdA52+sgwM" tabindex="-1" role="presentation"></a>다음으로 대문자 "B"를 헤아리는 대신에 계산할 문자를 나타내는 두 번째 인수를 취한다는 점을 제외하고 <code>countBs</code>처럼 동작하는 <code>countChar</code>라는 함수를 작성합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QN+QdpdCe+" href="#c_QN+QdpdCe+" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBs</span>(<span class="cm-string">&quot;BBC&quot;</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countChar</span>(<span class="cm-string">&quot;kakkerlak&quot;</span>, <span class="cm-string">&quot;k&quot;</span>));
<span class="cm-comment">// → 4</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_iXtbGSBd1r" href="#p_iXtbGSBd1r" tabindex="-1" role="presentation"></a>함수에는 문자열의 모든 문자를 보는 루프가 필요합니다. 인덱스를 0에서 길이 아래 1까지 실행할 수 있습니다(<code>&lt; string.<wbr>length</code>). 현재 위치의 문자가 함수가 찾고 있는 문자와 같으면 카운터 변수에 1을 추가합니다. 루프가 완료되면 카운터를 반환할 수 있습니다.</p>

<p><a class="p_ident" id="p_h0vFGXYL6A" href="#p_h0vFGXYL6A" tabindex="-1" role="presentation"></a><code>let</code> 또는 <code>const</code> 키워드로 적절하게 선언하여 함수에 사용된 모든 바인딩을 함수에서 로컬로 만들도록 주의하십시오.</p>

</div></div><nav><a href="02_program_structure.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="04_data.html" title="next chapter">▶</a></nav>
</article>