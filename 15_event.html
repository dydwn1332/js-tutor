<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>이벤트 처리</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 15;</script></head>

<article>
<nav><a href="14_dom.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="16_game.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>15장</span>이벤트 처리</h1>

<blockquote>

<p><a class="p_ident" id="p_9vGtY0kynX" href="#p_9vGtY0kynX" tabindex="-1" role="presentation"></a>외부 사건이 아닌 마음을 지배할 수 있는 힘을 가지고 있습니다. 이것을 깨닫고 힘을 얻게 될 것입니다.</p>

<footer>Marcus Aurelius, <cite>명상</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_15.jpg" alt="Picture a Rube Goldberg machine"></figure>

<p><a class="p_ident" id="p_xpTTTgjdUW" href="#p_xpTTTgjdUW" tabindex="-1" role="presentation"></a>일부 프로그램은 마우스 및 키보드 동작과 같은 직접 사용자 입력으로 작동합니다. 이러한 종류의 입력은 잘 구성된 데이터 구조로 사용할 수 없습니다. 실시간으로 부분 별로 제공되며 프로그램은 발생하는 대로 이에 응답할 것으로 예상됩니다.</p>

<h2><a class="h_ident" id="h_HQoLxG2r2l" href="#h_HQoLxG2r2l" tabindex="-1" role="presentation"></a>이벤트 처리기</h2>

<p><a class="p_ident" id="p_4crjoEGjCE" href="#p_4crjoEGjCE" tabindex="-1" role="presentation"></a>키보드의 키가 눌렸는지 여부를 알아내는 유일한 방법은 해당 키의 현재 상태를 읽는 것뿐인 인터페이스를 상상해 보십시오. 키 누름에 반응할 수 있으려면 키의 상태를 지속적으로 읽어야 키가 다시 해제되기 전에 잡을 수 있습니다. 키 누름을 놓칠 수 있으므로 다른 시간 집약적인 계산을 수행하는 것은 위험합니다.</p>

<p><a class="p_ident" id="p_2XITYSlZAe" href="#p_2XITYSlZAe" tabindex="-1" role="presentation"></a>일부 원시 기계는 그런 입력을 처리합니다. 여기서 한 단계 더 나아가 하드웨어나 운영 체제가 키 누름을 알아차리고 큐에 넣는 것입니다. 그런 다음 프로그램은 정기적으로 대기열에서 새 이벤트를 확인하고 발견한 내용에 반응할 수 있습니다.</p>

<p><a class="p_ident" id="p_z76x9gnNzd" href="#p_z76x9gnNzd" tabindex="-1" role="presentation"></a>물론, 큐를 살펴보고 자주 수행해야 한다는 것을 기억해야 합니다. 키가 눌려진 것과 프로그램이 이벤트를 인지하는 사이의 시간은 소프트웨어가 응답하지 않는 느낌을 주기 때문입니다. 이 접근 방식을 폴링 이라고 합니다. 대부분의 프로그래머는 그것을 피하는 것을 선호합니다.</p>

<p><a class="p_ident" id="p_yR0Vf6qqc8" href="#p_yR0Vf6qqc8" tabindex="-1" role="presentation"></a>더 나은 메커니즘은 이벤트가 발생할 때 시스템이 코드에 능동적으로 알리는 것입니다. 브라우저는 특정 이벤트에 대한 처리기로 함수를 등록할 수 있도록 하여 이를 수행합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_z0Q59PvLev" href="#c_z0Q59PvLev" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Click this document to activate the handler.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;You knocked?&quot;</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_3pQVpu1yal" href="#p_3pQVpu1yal" tabindex="-1" role="presentation"></a><code>window</code> 바인딩은 내장 객체 브라우저에서 제공을 의미한다. 문서가 포함된 브라우저 창을 나타냅니다. <code>addEventListener</code> 메서드를 호출하면 첫 번째 인수로 설명된 이벤트가 발생할 때마다 호출될 두 번째 인수가 등록됩니다.</p>

<h2><a class="h_ident" id="h_Kx1VwAV7ei" href="#h_Kx1VwAV7ei" tabindex="-1" role="presentation"></a>이벤트 및 DOM 노드</h2>

<p><a class="p_ident" id="p_tVKEGdxeqi" href="#p_tVKEGdxeqi" tabindex="-1" role="presentation"></a>각 브라우저 이벤트 처리기는 컨텍스트에 등록됩니다. 이전 예에서 전체 창에 대한 처리기를 등록하기 위해 <code>window</code> 객체 상에서 <code>addEventListener</code>를 호출했습니다. 이러한 메서드는 DOM 요소 및 일부 다른 타입의 객체에서도 찾을 수 있습니다. 이벤트 리스너는 등록된 객체의 컨텍스트에서 이벤트가 발생할 때만 호출됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_srTkrKlkl+" href="#c_srTkrKlkl+" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Click me<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>No handler here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;button&quot;</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Button clicked.&quot;</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_NDsx/r9YFj" href="#p_NDsx/r9YFj" tabindex="-1" role="presentation"></a>이 예에서는 버튼 노드에 처리기를 연결합니다. 버튼을 클릭하면 해당 처리기가 실행되지만 문서의 나머지 부분을 클릭하면 실행되지 않습니다.</p>

<p><a class="p_ident" id="p_nXR5M/glIi" href="#p_nXR5M/glIi" tabindex="-1" role="presentation"></a>노드에 <code>onclick</code> 속성을 부여하면 비슷한 효과가 있습니다. 이것은 대부분의 이벤트 유형에서 작동합니다. 이름이 이벤트 이름 앞에 있는 <code>on</code> 속성을 통해 처리기를 연결할 수 있습니다.</p>

<p><a class="p_ident" id="p_2j++Jf85vd" href="#p_2j++Jf85vd" tabindex="-1" role="presentation"></a>그러나 노드는 하나의 <code>onclick</code> 속성만 가질 수 있으므로 노드당 하나의 처리기만 등록할 수 있습니다. <code>addEventListener</code> 메서드를 사용하면 요소에 이미 다른 처리기가 있는 경우에도 처리기를 추가하는 것이 안전하도록 처리기를 원하는 수만큼 추가할 수 있습니다.</p>

<p><a class="p_ident" id="p_kTdN4mDFS6" href="#p_kTdN4mDFS6" tabindex="-1" role="presentation"></a><code>removeEventListener</code> 메서드는 처리기를 제거합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_nMrNUG0bzK" href="#c_nMrNUG0bzK" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Act-once button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;button&quot;</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">once</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Done.&quot;</span>);
    <span class="cm-variable">button</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, <span class="cm-variable">once</span>);
  }
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, <span class="cm-variable">once</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_I5Z7Y0phDC" href="#p_I5Z7Y0phDC" tabindex="-1" role="presentation"></a><code>removeEventListener</code>에 주어진 함수는 <code>addEventListener</code>에 주어진 것과 같은 함수 값이어야 합니다. 따라서 처리기를 등록 취소하려면 두 메서드에 동일한 함수 값을 전달할 수 있도록 함수에 이름을 지정해야 합니다.</p>

<h2><a class="h_ident" id="h_0d6qd0WrDY" href="#h_0d6qd0WrDY" tabindex="-1" role="presentation"></a>이벤트 객체</h2>

<p><a class="p_ident" id="p_ALjvdUiK0y" href="#p_ALjvdUiK0y" tabindex="-1" role="presentation"></a>지금까지는 무시했지만 이벤트 처리기 함수에는 인수인 이벤트 객체가 전달 됩니다. 이 객체는 이벤트에 대한 추가 정보를 보유합니다. 예를 들어, 어떤 마우스 버튼이 눌렸는지 알고 싶다면 이벤트 객체의 <code>button</code> 속성을 참조할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_ogCz14mujk" href="#c_ogCz14mujk" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>Click me any way you want<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;button&quot;</span>);
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousedown&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Left button&quot;</span>);
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Middle button&quot;</span>);
    } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">2</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Right button&quot;</span>);
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_2YZPvB2Zm4" href="#p_2YZPvB2Zm4" tabindex="-1" role="presentation"></a>이벤트 객체에 저장되는 정보는 이벤트 타입에 따라 다릅니다. 이 장의 뒷부분에서 다양한 유형에 대해 논의할 것입니다. 객체의 <code>type</code> 속성은 항상 이벤트를 식별하는 문자열을 (<code>&quot;click&quot;</code> 또는 <code>&quot;mousedown&quot;</code>와 같은) 보유합니다.</p>

<h2><a class="h_ident" id="h_NEhx0cDpml" href="#h_NEhx0cDpml" tabindex="-1" role="presentation"></a>전파</h2>

<p><a class="p_ident" id="p_9PGPBJSMFn" href="#p_9PGPBJSMFn" tabindex="-1" role="presentation"></a>대부분의 이벤트 타입에서 자식이 있는 노드에 등록된 처리기는 자식에서 발생하는 이벤트도 수신합니다. 단락 내부의 버튼을 클릭하면 단락의 이벤트 처리기도 click 이벤트를 보게 됩니다.</p>

<p><a class="p_ident" id="p_0VuJPBg2UB" href="#p_0VuJPBg2UB" tabindex="-1" role="presentation"></a>그러나 단락과 버튼 모두에 처리기가 있는 경우 버튼에 있는 보다 구체적인 처리기가 먼저 이동합니다. 이벤트가 발생한 노드에서 해당 노드의 부모 노드와 문서의 루트로 외부로 전파된다고 합니다. 마지막으로 특정 노드에 등록된 모든 처리기의 차례가 끝나면 전체 창에 등록된 처리기가 이벤트에 응답할 기회를 얻습니다.</p>

<p><a class="p_ident" id="p_unHabXBzty" href="#p_unHabXBzty" tabindex="-1" role="presentation"></a>언제든지 이벤트 처리기는 <code>stopPropagation</code> 메서드를 호출하여 처리기가 더 이상 이벤트를 수신하지 못하도록 할 수 있습니다. 예를 들어, 다른 클릭 가능한 요소 내부에 버튼이 있고 버튼을 클릭하여 외부 요소의 클릭 동작을 활성화하지 않으려는 경우에 유용할 수 있습니다.</p>

<p><a class="p_ident" id="p_qKf3t2phih" href="#p_qKf3t2phih" tabindex="-1" role="presentation"></a>다음 예는 버튼과 그것을 둘러싼 단락의 <code>&quot;mousedown&quot;</code> 처리기를 등록합니다. 마우스 오른쪽 버튼으로 클릭하면 버튼에 대한 처리기가 <code>stopPropagation</code>를 호출하여 단락의 처리기가 실행되지 않도록 합니다. 다른 마우스 버튼으로 버튼을 클릭하면 두 처리기가 모두 실행됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_ApZbQ8dI12" href="#c_ApZbQ8dI12" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>A paragraph with a <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>button<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">para</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;p&quot;</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">button</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;button&quot;</span>);
  <span class="cm-variable">para</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousedown&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler for paragraph.&quot;</span>);
  });
  <span class="cm-variable">button</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousedown&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler for button.&quot;</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">2</span>) <span class="cm-variable-2">event</span>.<span class="cm-property">stopPropagation</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_NocTrrs2K+" href="#p_NocTrrs2K+" tabindex="-1" role="presentation"></a>대부분의 이벤트 객체에는 해당 이벤트가 시작된 노드를 참조하는 <code>target</code> 속성이 있습니다. 이 속성을 사용하여 처리하고 싶지 않은 노드에서 전파된 항목을 실수로 처리하지 않도록 할 수 있습니다.</p>

<p><a class="p_ident" id="p_RrFjk/g1ly" href="#p_RrFjk/g1ly" tabindex="-1" role="presentation"></a>또한 <code>target</code> 속성을 사용하여 특정 타입의 이벤트를 위해 넓은 그물을 던지는 것도 가능합니다. 예를 들어, 긴 버튼 목록을 포함하는 노드가 있는 경우 개별 처리기를 등록하는 것보다 외부 노드에 단일 클릭 처리기를 등록하고 속성을 사용하여 버튼이 클릭되었는지 확인하도록 하는 것이 더 편리할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_dpl2XD58ol" href="#c_dpl2XD58ol" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>A<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>B<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>C<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">nodeName</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;BUTTON&quot;</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Clicked&quot;</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">textContent</span>);
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_GaHJsztrot" href="#h_GaHJsztrot" tabindex="-1" role="presentation"></a>기본 작업</h2>

<p><a class="p_ident" id="p_mNZd3hJWtB" href="#p_mNZd3hJWtB" tabindex="-1" role="presentation"></a>많은 이벤트에는 연관된 기본 작업이 있습니다. 링크를 클릭하면 링크 대상으로 이동합니다. 아래쪽 화살표를 누르면 브라우저가 페이지를 아래로 스크롤합니다. 마우스 오른쪽 버튼을 클릭하면 컨텍스트 메뉴가 나타납니다.</p>

<p><a class="p_ident" id="p_BXr+oTOrOE" href="#p_BXr+oTOrOE" tabindex="-1" role="presentation"></a>대부분의 이벤트 타입에서 JavaScript 이벤트 처리기는 기본 동작이 발생하기 전에 호출됩니다. 일반적으로 이미 이벤트 처리를 처리했기 때문에 처리기가 이러한 정상적인 동작이 발생하지 않도록 하는 경우 이벤트 객체에서 <code>preventDefault</code> 메서드를 호출할 수 있습니다.</p>

<p><a class="p_ident" id="p_hu1WU9Uwj3" href="#p_hu1WU9Uwj3" tabindex="-1" role="presentation"></a>이것은 사용자 고유의 키보드 단축키 또는 컨텍스트 메뉴를 구현하는 데 사용할 수 있습니다. 또한 사용자가 기대하는 동작을 불쾌하게 방해하는 데 사용할 수도 있습니다. 예를 들어 다음은 따라갈 수 없는 링크입니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_0/0kxevSeD" href="#c_0/0kxevSeD" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">a</span> <span class="cm-attribute">href</span>=<span class="cm-string">&quot;https://developer.mozilla.org/&quot;</span><span class="cm-tag cm-bracket">&gt;</span>MDN<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">a</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;a&quot;</span>);
  <span class="cm-variable">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Nope.&quot;</span>);
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_pN3dm88Fmp" href="#p_pN3dm88Fmp" tabindex="-1" role="presentation"></a>정말 합당한 이유가 없는 한 그러한 일을 하지 마십시오. 예상 동작이 깨졌을 때 페이지를 사용하는 사람들에게는 불쾌할 것입니다.</p>

<p><a class="p_ident" id="p_KMgK6E70da" href="#p_KMgK6E70da" tabindex="-1" role="presentation"></a>브라우저에 따라 일부 이벤트는 전혀 가로채지 못할 수 있습니다. 예를 들어 Chrome에서 현재 탭을 닫는 키보드 단축키(<span class="keyname">control</span>-W 또는 <span class="keyname">command</span>-W)는 JavaScript에서 처리할 수 없습니다.</p>

<h2><a class="h_ident" id="h_974t15Z9oa" href="#h_974t15Z9oa" tabindex="-1" role="presentation"></a>키 이벤트</h2>

<p><a class="p_ident" id="p_cxWc3fDa17" href="#p_cxWc3fDa17" tabindex="-1" role="presentation"></a>키보드의 키를 누르면 브라우저가 <code>&quot;keydown&quot;</code> 이벤트를 발생시킵니다. 해제하면 <code>&quot;keyup&quot;</code> 이벤트를 받을 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_KkYEaH5/cU" href="#c_KkYEaH5/cU" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>This page turns violet when you hold the V key.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;keydown&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">key</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;v&quot;</span>) {
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;violet&quot;</span>;
    }
  });
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;keyup&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">key</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;v&quot;</span>) {
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">style</span>.<span class="cm-property">background</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_OIjS/pXtfk" href="#p_OIjS/pXtfk" tabindex="-1" role="presentation"></a><code>&quot;keydown&quot;</code>은 물리적으로 키를 눌렀을 때만 발동되는 것은 아닙니다. 키를 길게 누르면 키가 반복될 때마다 이벤트가 다시 시작 됩니다. 때때로 이것에 대해 조심해야 합니다. 예를 들어, 키를 눌렀을 때 DOM에 버튼을 추가하고 키를 놓을 때 다시 제거하면 키를 더 오래 누르고 있을 때 실수로 수백 개의 버튼을 추가할 수 있습니다.</p>

<p><a class="p_ident" id="p_91YbvgP75t" href="#p_91YbvgP75t" tabindex="-1" role="presentation"></a>예에서는 이벤트 객체 <code>key</code>의 속성을 살펴보고 이벤트에 대한 키를 확인했습니다. 이 속성은 대부분의 키에 대해 해당 키를 누르면 입력되는 문자열에 해당하는 문자열을 보유합니다. <span class="keyname">enter</span>와 같은 특수 키에 관해 그것은 키 이름의 문자열을 보유합니다(이 경우에는 <code>&quot;Enter&quot;</code>). 키를 누른 상태에서 <span class="keyname">shift</span>를 사용하면 키의 이름에 영향을 주게 되어 <code>&quot;v&quot;</code>가 <code>&quot;V&quot;</code>가 되고, <code>&quot;1&quot;</code>이 <code>&quot;!&quot;</code>가 될 수 있습니다.</p>

<p><a class="p_ident" id="p_4cdQPevWxW" href="#p_4cdQPevWxW" tabindex="-1" role="presentation"></a><span class="keyname">shift</span>, <span class="keyname">control</span>, <span class="keyname">alt</span> 및 <span class="keyname">meta</span>와 같은 수정 키들은 일반 키와 마찬가지로 키 이벤트를 생성합니다. 그러나 키 조합을 찾을 때 키보드 및 마우스 이벤트의 shiftKey, ctrlKey, altKey, 및 metaKey 속성을 보면 이러한 키가 눌려져 있는지 여부도 알 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_aHmyG7GoKB" href="#c_aHmyG7GoKB" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Press Control-Space to continue.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;keydown&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">key</span> <span class="cm-operator">==</span> <span class="cm-string">&quot; &quot;</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">event</span>.<span class="cm-property">ctrlKey</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Continuing!&quot;</span>);
    }
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_EHGULml9MQ" href="#p_EHGULml9MQ" tabindex="-1" role="presentation"></a>키 이벤트가 발생하는 DOM 노드는 키를 눌렀을 때 포커스가 있는 요소에 따라 다릅니다. 대부분의 노드는 <code>tabindex</code> 속성을 부여하지 않는 한 포커스를 가질 수 없지만 링크, 버튼 및 양식 필드와 같은 것은 가능합니다.</p>

<p><a class="p_ident" id="p_gWNn34dc3l" href="#p_gWNn34dc3l" tabindex="-1" role="presentation"></a>사용자가 텍스트를 입력할 때 키 이벤트를 사용하여 입력 중인 내용을 파악하는 것은 문제가 됩니다. 일부 플랫폼, 특히 Android 휴대폰의 가상 키보드는 키 이벤트를 실행하지 않습니다.</p>

<p><a class="p_ident" id="p_zRpxwczivX" href="#p_zRpxwczivX" tabindex="-1" role="presentation"></a>입력된 것을 확인하기 위해 <code>&lt;input&gt;</code> 및 <code>&lt;textarea&gt;</code> 태그와 같이 입력할 수 있는 요소는 사용자가 콘텐츠를 변경할 때마다 <code>&quot;input&quot;</code> 이벤트를 실행합니다. 입력된 실제 내용을 얻으려면 초점이 맞춰진 필드에서 직접 읽는 것이 가장 좋습니다.</p>

<h2><a class="h_ident" id="h_cF46QKpzec" href="#h_cF46QKpzec" tabindex="-1" role="presentation"></a>포인터 이벤트</h2>

<p><a class="p_ident" id="p_mTy2muIADb" href="#p_mTy2muIADb" tabindex="-1" role="presentation"></a>현재 화면에서 사물을 가리키는 데 널리 사용되는 두 가지 방법이 있습니다. 마우스(터치패드 및 트랙볼과 같이 마우스처럼 작동하는 장치 포함)와 터치스크린입니다. 이들은 다양한 종류의 이벤트를 생성합니다.</p>

<h3><a class="i_ident" id="i_D5iwImkmyt" href="#i_D5iwImkmyt" tabindex="-1" role="presentation"></a>마우스 클릭</h3>

<p><a class="p_ident" id="p_zZHDVhEhYY" href="#p_zZHDVhEhYY" tabindex="-1" role="presentation"></a>마우스 버튼을 누르면 여러 이벤트가 발생합니다. <code>&quot;mousedown&quot;</code> and <code>&quot;mouseup&quot;</code> 이벤트들은 <code>&quot;keydown&quot;</code> 및 <code>&quot;keyup&quot;</code> 이벤트와 유사하고, 버튼을 누르고 해제할 때 작동됩니다. 이벤트가 발생할 때 마우스 포인터 바로 아래에 있는 DOM 노드에서 이러한 일이 발생합니다.</p>

<p><a class="p_ident" id="p_nNPZmPzglj" href="#p_nNPZmPzglj" tabindex="-1" role="presentation"></a><code>&quot;mouseup&quot;</code> 이벤트 다음에 <code>&quot;click&quot;</code> 이벤트는 버튼 누름 및 해제 모두를 포함하는 대부분의 특정 노드에서 작동합니다. 예를 들어 한 단락에서 마우스 버튼을 누른 다음 포인터를 다른 단락으로 이동하고 버튼을 놓으면 두 단락이 모두 포함된 요소에서 <code>&quot;click&quot;</code> 이벤트가 발생합니다.</p>

<p><a class="p_ident" id="p_gzmmLlVcMF" href="#p_gzmmLlVcMF" tabindex="-1" role="presentation"></a>두 번의 클릭이 가깝게 발생하면 두 번째 클릭 이벤트 이후에 <code>&quot;dblclick&quot;</code> (더블 클릭) 이벤트도 발생합니다.</p>

<p><a class="p_ident" id="p_kaCGAW6CrN" href="#p_kaCGAW6CrN" tabindex="-1" role="presentation"></a>마우스 이벤트가 발생한 장소에 대한 정확한 정보를 얻으려면 창의 왼쪽 상단 모서리에 상대적인 이벤트 좌표(픽셀 단위)를 포함하는 <code>clientX</code> 및 <code>clientY</code> 속성을 확인하거나 <code>pageX</code>와 <code>pageY</code>를 참조할 수 있습니다.</p>

<p id="mouse_drawing"><a class="p_ident" id="p_A7YDC3hfu1" href="#p_A7YDC3hfu1" tabindex="-1" role="presentation"></a>다음은 기본 그리기 프로그램을 구현합니다. 문서를 클릭할 때마다 마우스 포인터 아래에 점이 추가됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_2eo6Jw+49U" href="#c_2eo6Jw+49U" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">200px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">beige</span>;
  }
  <span class="cm-qualifier">.dot</span> {
    <span class="cm-property">height</span>: <span class="cm-number">8px</span>; <span class="cm-property">width</span>: <span class="cm-number">8px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">4px</span>; <span class="cm-comment">/* rounds corners */</span>
    <span class="cm-property">background</span>: <span class="cm-keyword">blue</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;click&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">dot</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">&quot;div&quot;</span>);
    <span class="cm-variable-2">dot</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;dot&quot;</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageX</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
    <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">pageY</span> <span class="cm-operator">-</span> <span class="cm-number">4</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">dot</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h3><a class="i_ident" id="i_XojjiOmg7v" href="#i_XojjiOmg7v" tabindex="-1" role="presentation"></a>마우스 모션</h3>

<p><a class="p_ident" id="p_yS6GUjUh7f" href="#p_yS6GUjUh7f" tabindex="-1" role="presentation"></a>마우스 포인터가 움직일 때마다 <code>&quot;mousemove&quot;</code> 이벤트가 발생합니다. 이 이벤트는 마우스의 위치를 추적하는 데 사용할 수 있습니다. 이것이 유용한 일반적인 상황은 어떤 형태의 마우스 끌기 기능을 구현할 때입니다.</p>

<p><a class="p_ident" id="p_uNUrAgInXR" href="#p_uNUrAgInXR" tabindex="-1" role="presentation"></a>예를 들어, 다음 프로그램은 막대를 표시하고 이 막대를 왼쪽이나 오른쪽으로 끌면 좁아지거나 넓어지도록 이벤트 처리기를 설정합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_+CX2XtmsmE" href="#c_+CX2XtmsmE" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Drag the bar to change its width:<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">style</span>=<span class="cm-string">&quot;background: orange; width: 60px; height: 20px&quot;</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">lastX</span>; <span class="cm-comment">// Tracks the last observed mouse X position</span>
  <span class="cm-keyword">let</span> <span class="cm-def">bar</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>);
  <span class="cm-variable">bar</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousedown&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">button</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-variable">lastX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span>;
      <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousemove&quot;</span>, <span class="cm-variable">moved</span>);
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>(); <span class="cm-comment">// Prevent selection</span>
    }
  });

  <span class="cm-keyword">function</span> <span class="cm-def">moved</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">buttons</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-variable">window</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">&quot;mousemove&quot;</span>, <span class="cm-variable">moved</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">dist</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span> <span class="cm-operator">-</span> <span class="cm-variable">lastX</span>;
      <span class="cm-keyword">let</span> <span class="cm-def">newWidth</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">10</span>, <span class="cm-variable">bar</span>.<span class="cm-property">offsetWidth</span> <span class="cm-operator">+</span> <span class="cm-variable-2">dist</span>);
      <span class="cm-variable">bar</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newWidth</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
      <span class="cm-variable">lastX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span>;
    }
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_NkCRDxiDFs" href="#p_NkCRDxiDFs" tabindex="-1" role="presentation"></a><code>&quot;mousemove&quot;</code> 처리기는 전체 창에 등록됨에 유의합니다. 크기를 조정하는 동안 마우스가 막대 밖으로 나가더라도 버튼을 누르고 있는 동안에는 크기를 업데이트하려고 합니다.</p>

<p><a class="p_ident" id="p_KGCUn+UzhW" href="#p_KGCUn+UzhW" tabindex="-1" role="presentation"></a>마우스 버튼을 놓을 때 막대 크기 조정을 중지해야 합니다. 이를 위해 현재 누르고 있는 버튼에 대해 알려주는 <code>buttons</code> 속성(복수형 참고)을 사용할 수 있습니다. 이 값이 0이면 버튼이 눌리지 않습니다. 버튼을 누르고 있으면 해당 값은 해당 버튼에 대한 코드의 합입니다. 왼쪽 버튼에는 코드 1, 오른쪽 버튼 2, 가운데 버튼 4가 있습니다. 예를 들어 왼쪽 및 오른쪽 버튼을 누르고 있으면 <code>buttons</code> 값이 3일 것입니다.</p>

<p><a class="p_ident" id="p_CmfoIcvJii" href="#p_CmfoIcvJii" tabindex="-1" role="presentation"></a>이 코드의 순서는 <code>button</code>에서 사용하는 것과 다르며 가운데 버튼이 오른쪽 버튼보다 먼저 옵니다. 언급했듯이 일관성은 실제로 브라우저 프로그래밍 인터페이스의 장점이 아닙니다.</p>

<h3><a class="i_ident" id="i_jF9QgltzXD" href="#i_jF9QgltzXD" tabindex="-1" role="presentation"></a>터치 이벤트</h3>

<p><a class="p_ident" id="p_sd0bzLSga7" href="#p_sd0bzLSga7" tabindex="-1" role="presentation"></a>현재 사용하는 그래픽 브라우저의 스타일은 터치스크린이 드물었던 시기에 마우스 인터페이스를 염두에 두고 설계되었습니다. 초기 터치스크린 전화기에서 웹을 작동시키기 위해 해당 장치의 브라우저는 어느 정도 터치 이벤트가 마우스 이벤트인 것처럼 가장했습니다. 화면을 탭하면 <code>&quot;mousedown&quot;</code>, <code>&quot;mouseup&quot;</code> 및 <code>&quot;click&quot;</code> 이벤트가 표시됩니다.</p>

<p><a class="p_ident" id="p_jD6s34l+nR" href="#p_jD6s34l+nR" tabindex="-1" role="presentation"></a>터치스크린은 마우스와 다르게 작동합니다. 버튼이 여러 개 없고 화면에 없을 때 손가락을 추적할 수 없으며(시뮬레이션을 위한 <code>&quot;mousemove&quot;</code>), 여러 손가락을 동시에 화면에 표시할 수 있습니다.</p>

<p><a class="p_ident" id="p_5INtcl6su5" href="#p_5INtcl6su5" tabindex="-1" role="presentation"></a>마우스 이벤트는 간단한 경우에만 터치 상호 작용을 다룹니다. 버튼에 <code>&quot;click&quot;</code> 처리기를 추가하면 터치 사용자가 계속 사용할 수 있습니다. 그러나 이전 예의 크기 조정 가능한 막대와 같은 것은 터치스크린에서 작동하지 않습니다.</p>

<p><a class="p_ident" id="p_cQNA+9JYLs" href="#p_cQNA+9JYLs" tabindex="-1" role="presentation"></a>터치 상호 작용에 의해 발생하는 특정 이벤트 타입이 있습니다. 손가락이 화면을 터치하기 시작하면 <code>&quot;touchstart&quot;</code> 이벤트가 발생합니다. 터치하면서 움직이면 <code>&quot;touchmove&quot;</code> 이벤트가 발생합니다. 마지막으로 화면 터치를 멈추면 <code>&quot;touchend&quot;</code> 이벤트가 표시됩니다.</p>

<p><a class="p_ident" id="p_IHGyrDKsGS" href="#p_IHGyrDKsGS" tabindex="-1" role="presentation"></a>많은 터치스크린이 동시에 여러 손가락을 감지할 수 있기 때문에 이러한 이벤트에는 연결된 단일 좌표 집합이 없습니다. 오히려 그것들의 이벤트 객체는 자체 <code>clientX</code>, <code>clientY</code>, <code>pageX</code> 및 <code>pageY</code> 속성을 가집니다.</p>

<p><a class="p_ident" id="p_6DdNmVnXwi" href="#p_6DdNmVnXwi" tabindex="-1" role="presentation"></a>터치하는 모든 손가락 주위에 빨간색 원을 표시하려면 다음과 같이 할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_TpxWIP8ylU" href="#c_TpxWIP8ylU" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag">dot</span> { <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>; <span class="cm-property">display</span>: <span class="cm-atom">block</span>;
        <span class="cm-property">border</span>: <span class="cm-number">2px</span> <span class="cm-atom">solid</span> <span class="cm-keyword">red</span>; <span class="cm-property">border-radius</span>: <span class="cm-number">50px</span>;
        <span class="cm-property">height</span>: <span class="cm-number">100px</span>; <span class="cm-property">width</span>: <span class="cm-number">100px</span>; }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Touch this page<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">update</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">dot</span>; <span class="cm-variable-2">dot</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;dot&quot;</span>);) {
      <span class="cm-variable-2">dot</span>.<span class="cm-property">remove</span>();
    }
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">event</span>.<span class="cm-property">touches</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">let</span> {<span class="cm-def">pageX</span>, <span class="cm-def">pageY</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">touches</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">let</span> <span class="cm-def">dot</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">&quot;dot&quot;</span>);
      <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">pageX</span> <span class="cm-operator">-</span> <span class="cm-number">50</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
      <span class="cm-variable-2">dot</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">pageY</span> <span class="cm-operator">-</span> <span class="cm-number">50</span>) <span class="cm-operator">+</span> <span class="cm-string">&quot;px&quot;</span>;
      <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">dot</span>);
    }
  }
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;touchstart&quot;</span>, <span class="cm-variable">update</span>);
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;touchmove&quot;</span>, <span class="cm-variable">update</span>);
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;touchend&quot;</span>, <span class="cm-variable">update</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_NZHqbUebJ6" href="#p_NZHqbUebJ6" tabindex="-1" role="presentation"></a>종종 터치 이벤트 처리기에서 <code>preventDefault</code>를 호출하여 브라우저의 기본 동작(스와이프 시 페이지 스크롤을 포함할 수 있음)을 재정의하고 마우스 이벤트가 발생하는 것을 방지하기를 원할 것입니다. 이에 대한 처리기도 있을 수 있습니다.</p>

<h2><a class="h_ident" id="h_xGSp7W5DAZ" href="#h_xGSp7W5DAZ" tabindex="-1" role="presentation"></a>스크롤 이벤트</h2>

<p><a class="p_ident" id="p_RLg7GV0Uge" href="#p_RLg7GV0Uge" tabindex="-1" role="presentation"></a>요소가 스크롤될 때마다 <code>&quot;scroll&quot;</code> 이벤트가 발생합니다. 이것은 사용자가 현재 보고 있는 것을 알거나(오프스크린 애니메이션을 비활성화하거나 spy 보고서를 본부에 보내기 위해) 또는 진행률 표시를 표시하는 것과 같이 다양한 용도로 사용됩니다(목차의 일부를 강조 표시하거나 페이지를 표시하는 숫자).</p>

<p><a class="p_ident" id="p_koAfRfBrN2" href="#p_koAfRfBrN2" tabindex="-1" role="presentation"></a>다음 예에서는 문서 위에 진행률 표시줄을 그리고 아래로 스크롤할 때 채워지도록 업데이트합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_7tyBZD/B1O" href="#c_7tyBZD/B1O" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-builtin">#progress</span> {
    <span class="cm-property">border-bottom</span>: <span class="cm-number">2px</span> <span class="cm-atom">solid</span> <span class="cm-keyword">blue</span>;
    <span class="cm-property">width</span>: <span class="cm-number">0</span>;
    <span class="cm-property">position</span>: <span class="cm-atom">fixed</span>;
    <span class="cm-property">top</span>: <span class="cm-number">0</span>; <span class="cm-property">left</span>: <span class="cm-number">0</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;progress&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// Create some content</span>
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(
    <span class="cm-string">&quot;supercalifragilisticexpialidocious &quot;</span>.<span class="cm-property">repeat</span>(<span class="cm-number">1000</span>)));

  <span class="cm-keyword">let</span> <span class="cm-def">bar</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;#progress&quot;</span>);
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;scroll&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">max</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">scrollHeight</span> <span class="cm-operator">-</span> <span class="cm-variable">innerHeight</span>;
    <span class="cm-variable">bar</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-string-2">`${</span>(<span class="cm-variable">pageYOffset</span> <span class="cm-operator">/</span> <span class="cm-variable-2">max</span>) <span class="cm-operator">*</span> <span class="cm-number">100</span><span class="cm-string-2">}</span><span class="cm-string-2">%`</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_K3MHOw7Pyv" href="#p_K3MHOw7Pyv" tabindex="-1" role="presentation"></a>요소가 주어졌을 때 <code>fixed</code>의 <code>position</code>은 <code>absolute</code> 위치처럼 작동되지만, 나머지 문서 부분의 경우에 scrolling이 방지됩니다. 효과는 진행이 상단에 머물도록 하는 것입니다. 너비가 변경되어 현재 진행 상황을 나타냅니다. 요소의 크기가 페이지 너비에 비례하도록 너비를 설정할 때 단위로 <code>px</code>보다는 <code>%</code>를 사용합니다.</p>

<p><a class="p_ident" id="p_98WgTyMsUp" href="#p_98WgTyMsUp" tabindex="-1" role="presentation"></a>전역 <code>innerHeight</code> 바인딩은 전체 스크롤 가능한 높이에서 빼야 하는 창의 높이를 제공합니다. 문서의 맨 아래에 닿으면 스크롤을 계속할 수 없습니다. 창 너비에 대한 <code>innerWidth</code>도 있습니다. <code>pageYOffset</code>로 나눔으로써 최대 스크롤 위치와 100을 곱해 진행 막대의 비율을 얻습니다.</p>

<p><a class="p_ident" id="p_tX0nzFvZnA" href="#p_tX0nzFvZnA" tabindex="-1" role="presentation"></a>스크롤 이벤트 상에서 <code>preventDefault</code> 호출은 스크롤 발생을 방해하지 않습니다. 실제, 이벤트 처리기는 스크롤이 위치를 차지한 경우에만 호출됩니다.</p>

<h2><a class="h_ident" id="h_NoKd+BgJRm" href="#h_NoKd+BgJRm" tabindex="-1" role="presentation"></a>포커스 이벤트</h2>

<p><a class="p_ident" id="p_Rd7wWTGmsl" href="#p_Rd7wWTGmsl" tabindex="-1" role="presentation"></a>요소가 focus를 취하면 브라우저는 <code>&quot;focus&quot;</code> 이벤트를 발생시킵니다. 초커스가 상실되면 요소는 <code>&quot;blur&quot;</code> 이벤트를 취합니다.</p>

<p><a class="p_ident" id="p_rU6XEBvIwF" href="#p_rU6XEBvIwF" tabindex="-1" role="presentation"></a>앞에서 설명한 이벤트와 달리 이 두 이벤트는 전파되지 않습니다. 부모 요소의 핸들러는 자식 요소가 포커스를 얻거나 잃을 때 알림을 받지 않습니다.</p>

<p><a class="p_ident" id="p_CuMJTkSD/k" href="#p_CuMJTkSD/k" tabindex="-1" role="presentation"></a>다음 예는 현재 포커스가 있는 텍스트 필드에 대한 도움말 텍스트를 표시합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_0ajEiAUCqr" href="#c_0ajEiAUCqr" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Name: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">&quot;text&quot;</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">&quot;Your full name&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Age: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">&quot;text&quot;</span> <span class="cm-attribute">data-help</span>=<span class="cm-string">&quot;Your age in years&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span> <span class="cm-attribute">id</span>=<span class="cm-string">&quot;help&quot;</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">help</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;#help&quot;</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">fields</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-string">&quot;input&quot;</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">field</span> <span class="cm-keyword">of</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable">fields</span>)) {
    <span class="cm-variable">field</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;focus&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">target</span>.<span class="cm-property">getAttribute</span>(<span class="cm-string">&quot;data-help&quot;</span>);
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">text</span>;
    });
    <span class="cm-variable">field</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;blur&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-variable">help</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
    });
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_ncYRMnjZTA" href="#p_ncYRMnjZTA" tabindex="-1" role="presentation"></a>window 객체는 사용자가 문서가 표시된 브라우저 탭이나 창에서 이동할 때 <code>&quot;focus&quot;</code>와 <code>&quot;blur&quot;</code> 이벤트를 받습니다.</p>

<h2><a class="h_ident" id="h_NmV8RP8lpt" href="#h_NmV8RP8lpt" tabindex="-1" role="presentation"></a>이벤트 로드</h2>

<p><a class="p_ident" id="p_zOHPnpKQpO" href="#p_zOHPnpKQpO" tabindex="-1" role="presentation"></a>페이지 로드가 완료되면 <code>&quot;load&quot;</code> 이벤트가 문서 및 본문 객체에서 발생합니다. 이것은 전체 문서를 작성해야 하는 초기화 작업을 예약하는 데 자주 사용됩니다. <code>&lt;script&gt;</code> 태그의 내용은 태그를 만나면 즉시 실행 된다는 것을 기억하십시오 . 예를 들어 스크립트가 <code>&lt;script&gt;</code> 태그 뒤에 표시되는 문서 부분에 대해 작업을 수행해야 하는 경우와 같이 너무 빠를 수 있습니다.</p>

<p><a class="p_ident" id="p_SqGooUkpJY" href="#p_SqGooUkpJY" tabindex="-1" role="presentation"></a>외부 파일을 로드하는 이미지 및 스크립트 태그와 같은 요소에는 참조하는 파일이 로드되었음을 나타내는 이벤트 <code>&quot;load&quot;</code>도 있습니다. 포커스 관련 이벤트와 마찬가지로 로딩 이벤트는 전파되지 않습니다.</p>

<p><a class="p_ident" id="p_41hBiFLDEt" href="#p_41hBiFLDEt" tabindex="-1" role="presentation"></a>페이지가 닫히거나 다른 곳으로 이동하면(예를 들어, 링크를 따라 이동) <code>&quot;beforeunload&quot;</code> 이벤트가 발생합니다. 이 이벤트의 주요 용도는 사용자가 문서를 닫아 실수로 작업이 손실되는 것을 방지하는 것입니다. 이 이벤트의 기본 동작을 방지하는 경우와 <code>returnValue</code>를 문자열로 설정하면, 브라우저는 그것들이 진짜로 페이지를 떠날 것인지 묻는 사용자에게 대화 상자를 표시합니다. 이 대화 상자에는 문자열이 포함될 수 있지만 일부 악의적인 사이트는 이러한 대화 상자를 사용하여 사람들이 페이지에 머물지 않고 이상한 체중 감량 광고를 보도록 하기 때문에 대부분의 브라우저에서 더 이상 해당 대화 상자를 표시하지 않습니다.</p>

<h2 id="timeline"><a class="h_ident" id="h_nX2hsbjECC" href="#h_nX2hsbjECC" tabindex="-1" role="presentation"></a>이벤트 루프</h2>

<p><a class="p_ident" id="p_IdpDwNDDaS" href="#p_IdpDwNDDaS" tabindex="-1" role="presentation"></a>이벤트 루프의 컨텍스트에서 브라우저 이벤트 처리기는 다른 비동기 알림처럼 작동합니다. 이벤트가 발생할 때 예약되지만 실행 기회를 얻기 전에 실행 중인 다른 스크립트가 완료될 때까지 기다려야 합니다.</p>

<p><a class="p_ident" id="p_U9K4BTMkUk" href="#p_U9K4BTMkUk" tabindex="-1" role="presentation"></a>다른 것이 실행되고 있지 않을 때만 이벤트를 처리할 수 있다는 사실은 이벤트 루프가 다른 작업과 연결되어 있는 경우 페이지와의 상호 작용(이벤트를 통해 발생)이 처리할 시간이 될 때까지 지연된다는 것을 의미합니다. 따라서 장기 실행 이벤트 처리기 또는 단기 실행 이벤트 처리기로 너무 많은 작업을 예약하면 페이지가 느려지고 사용하기 번거로워집니다.</p>

<p><a class="p_ident" id="p_KfmkFMZHYK" href="#p_KfmkFMZHYK" tabindex="-1" role="presentation"></a>페이지를 고정하지 않고 백그라운드에서 시간 소모적인 작업을 실제로 수행하려는 경우 브라우저는 <em>web workers</em>라는 것을 제공합니다. 작업자는 자체 타임라인에서 기본 스크립트와 함께 실행되는 JavaScript 프로세스입니다.</p>

<p><a class="p_ident" id="p_V7fk5zfZyU" href="#p_V7fk5zfZyU" tabindex="-1" role="presentation"></a>숫자를 제곱하는 것이 별도의 스레드에서 수행하려는 무겁고 오래 실행되는 계산이라고 할 때, 정사각형을 계산하고 메시지를 다시 전송하여 메시지에 응답하는 <code>code/<wbr>squareworker.<wbr>js</code> 파일을 작성할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FgmodjGwd9" href="#c_FgmodjGwd9" tabindex="-1" role="presentation"></a><span class="cm-variable">addEventListener</span>(<span class="cm-string">&quot;message&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">postMessage</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">data</span> <span class="cm-operator">*</span> <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});</pre>

<p><a class="p_ident" id="p_dG9n2QuEiF" href="#p_dG9n2QuEiF" tabindex="-1" role="presentation"></a>여러 스레드가 동일한 데이터를 만지는 문제를 피하기 위해 작업자는 전역 범위 또는 다른 데이터를 기본 스크립트 환경과 공유하지 않습니다. 대신 메시지를 주고받아 그들과 소통해야 합니다.</p>

<p><a class="p_ident" id="p_JZ/vp+7+lV" href="#p_JZ/vp+7+lV" tabindex="-1" role="presentation"></a>다음 코드는 해당 스크립트를 실행하는 작업자를 생성하고 몇 가지 메시지를 보내고 응답을 출력합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_43W0FL82No" href="#c_43W0FL82No" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">squareWorker</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Worker</span>(<span class="cm-string">&quot;code/squareworker.js&quot;</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;message&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;The worker responded:&quot;</span>, <span class="cm-variable-2">event</span>.<span class="cm-property">data</span>);
});
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">10</span>);
<span class="cm-variable">squareWorker</span>.<span class="cm-property">postMessage</span>(<span class="cm-number">24</span>);</pre>

<p><a class="p_ident" id="p_/l2saz0Kwz" href="#p_/l2saz0Kwz" tabindex="-1" role="presentation"></a><code>postMessage</code> 함수는 메시지를 보내는데, 이것은 수신기에서 작동하도록 <code>&quot;message&quot;</code> 이벤트를 생성합니다. 작업자를 만든 스크립트는 <code>Worker</code> 객체를 통해 메시지를 보내고 받는 반면 작업자는 전역 범위에서 직접 보내고 수신하여 객체를 만든 스크립트와 통신합니다. JSON으로 나타낼 수 있는 값만 메시지로 보낼 수 있습니다. 상대방은 값 자체가 아닌 복사본을 받습니다.</p>

<h2><a class="h_ident" id="h_hBzQOpfNhU" href="#h_hBzQOpfNhU" tabindex="-1" role="presentation"></a>타이머</h2>

<p><a class="p_ident" id="p_oH4C56AxK/" href="#p_oH4C56AxK/" tabindex="-1" role="presentation"></a>11장에서 <code>setTimeout</code> 함수를 나타냈습니다. 주어진 밀리초 후에 다른 함수가 나중에 호출되도록 예약합니다.</p>

<p><a class="p_ident" id="p_FeJ5k8rGCc" href="#p_FeJ5k8rGCc" tabindex="-1" role="presentation"></a>가끔 예약한 기능을 취소해야 하는 경우가 있습니다. 이것은 <code>setTimeout</code>에 의해 반환된 값을 저장하고 <code>clearTimeout</code>를 호출하여 수행됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_EYaodyT5pj" href="#c_EYaodyT5pj" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">bombTimer</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;BOOM!&quot;</span>);
}, <span class="cm-number">500</span>);

<span class="cm-keyword">if</span> (<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">&lt;</span> <span class="cm-number">0.5</span>) { <span class="cm-comment">// 50% chance</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Defused.&quot;</span>);
  <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">bombTimer</span>);
}</pre>

<p><a class="p_ident" id="p_J6c+vHyMhN" href="#p_J6c+vHyMhN" tabindex="-1" role="presentation"></a><code>cancelAnimationFrame</code> 함수는 <code>clearTimeout</code>과 같은 방식으로 수행됩니다. <code>requestAnimationFrame</code>에 의해 반환된 값 상에서 그것의 호출은 해당 프레임을 취소합니다.</p>

<p><a class="p_ident" id="p_MTqUUpmFIN" href="#p_MTqUUpmFIN" tabindex="-1" role="presentation"></a><code>setInterval</code> 및 <code>clearInterval</code>과 같은 함수 집합은 <em>X</em> milliseconds마다 타이머가 반복되도록 설정하는데 사용됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_WmiFQBAos1" href="#c_WmiFQBAos1" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">ticks</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-keyword">let</span> <span class="cm-def">clock</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(() <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;tick&quot;</span>, <span class="cm-variable">ticks</span><span class="cm-operator">++</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable">ticks</span> <span class="cm-operator">==</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable">clock</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;stop.&quot;</span>);
  }
}, <span class="cm-number">200</span>);</pre>

<h2><a class="h_ident" id="h_AOVmaqj10I" href="#h_AOVmaqj10I" tabindex="-1" role="presentation"></a>Debouncing</h2>

<p><a class="p_ident" id="p_xHU4bJ8gsS" href="#p_xHU4bJ8gsS" tabindex="-1" role="presentation"></a>일부 이벤트 타입은 여러 번 연속으로 빠르게 실행될 가능성이 있습니다(예를 들어, <code>&quot;mousemove&quot;</code> 및 <code>&quot;scroll&quot;</code> 이벤트). 이러한 이벤트를 처리할 때 너무 시간이 많이 걸리는 작업을 수행하지 않도록 주의해야 합니다.</p>

<p><a class="p_ident" id="p_CvRYtJPZwz" href="#p_CvRYtJPZwz" tabindex="-1" role="presentation"></a>이러한 처리기에서 특별한 일을 수행해야 하는 경우 <code>setTimeout</code>을 사용할 수 있습니다. 이를 일반적으로 이벤트 <em>debouncing</em>이라 합니다. 이에 대한 몇 가지 약간 다른 접근 방식이 있습니다.</p>

<p><a class="p_ident" id="p_8qDwbjQg0l" href="#p_8qDwbjQg0l" tabindex="-1" role="presentation"></a>첫 번째 예는 사용자가 무언가를 입력했을 때 반응하고 싶지만 모든 입력 이벤트에 대해 즉시 반응하고 싶지 않는 경우입니다. 빠르게 타이핑할 때 일시 정지가 발생할 때까지 기다리기만 하면 됩니다. 이벤트 처리기에서 즉시 작업을 수행하는 대신 시간 제한을 설정합니다. 또한 이벤트가 서로 가깝게(시간 초과 지연보다 가까움) 발생하면 이전 이벤트의 시간 초과가 취소되도록 이전 시간 초과를 (있는 경우) 지웁니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_amVDbwAaoI" href="#c_amVDbwAaoI" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">&gt;</span>Type something here...<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">textarea</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;textarea&quot;</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">timeout</span>;
  <span class="cm-variable">textarea</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;input&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">clearTimeout</span>(<span class="cm-variable">timeout</span>);
    <span class="cm-variable">timeout</span> <span class="cm-operator">=</span> <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Typed!&quot;</span>), <span class="cm-number">500</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<p><a class="p_ident" id="p_55az3iLtsc" href="#p_55az3iLtsc" tabindex="-1" role="presentation"></a><code>clearTimeout</code>에 정의되지 않은 값을 주거나 또는 이미 작동된 timeout 상에서 호출할 때 효과가 없습니다. 따라서 언제 호출할지 주의할 필요가 없으며 모든 이벤트에 대해 그렇게 하면 됩니다.</p>

<p><a class="p_ident" id="p_GisH+i+4tv" href="#p_GisH+i+4tv" tabindex="-1" role="presentation"></a>응답을 간격을 두어 최소한 특정 시간만큼 분리하되 그 직후가 아니라 일련의 이벤트 중에 실행하려는 경우 약간 다른 패턴을 사용할 수 있습니다. 예를 들어 마우스의 현재 좌표를 250밀리초마다 표시하여 <code>&quot;mousemove&quot;</code> 이벤트에 응답할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_Hx4a7naGCO" href="#c_Hx4a7naGCO" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">scheduled</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-variable">window</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousemove&quot;</span>, <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable">scheduled</span>) {
      <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
        <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span>
          <span class="cm-string-2">`Mouse at ${</span><span class="cm-variable">scheduled</span>.<span class="cm-property">pageX</span><span class="cm-string-2">}</span><span class="cm-string-2">, ${</span><span class="cm-variable">scheduled</span>.<span class="cm-property">pageY</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>;
        <span class="cm-variable">scheduled</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
      }, <span class="cm-number">250</span>);
    }
    <span class="cm-variable">scheduled</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>;
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_bKLVanKSm7" href="#p_bKLVanKSm7" tabindex="-1" role="presentation"></a>이벤트 처리기를 사용하면 웹 페이지에서 발생하는 이벤트를 감지하고 대응할 수 있습니다. <code>addEventListener</code> 메서드는 그러한 처리기를 등록하는데 사용됩니다.</p>

<p><a class="p_ident" id="p_pT/A7mXxlh" href="#p_pT/A7mXxlh" tabindex="-1" role="presentation"></a>각 이벤트는 그것을 식별하는 타입을 (<code>&quot;keydown&quot;</code>, <code>&quot;focus&quot;</code> 등) 가집니다. 대부분의 이벤트는 특정 DOM 요소 상에서 호출되고 그 요소의 조상으로 전파됩니다(그것들을 처리하기 위해 해당 요소들과 관련된 처리기들을 허용).</p>

<p><a class="p_ident" id="p_ot9NdEIh/U" href="#p_ot9NdEIh/U" tabindex="-1" role="presentation"></a>이벤트 처리기가 호출되면 이벤트에 대한 추가 정보가 포함된 이벤트 객체가 전달됩니다. 이 객체에는 추가 전파를 중지하고(<code>stopPropagation</code>) 브라우저의 기본 이벤트 처리를 방지할 수 있는 (<code>preventDefault</code>) 메서드도 있습니다.</p>

<p><a class="p_ident" id="p_3en9/+MrwJ" href="#p_3en9/+MrwJ" tabindex="-1" role="presentation"></a>키 누름은 <code>&quot;keydown&quot;</code> 및 <code>&quot;keyup&quot;</code> 이벤트를 작동시킵니다. 마우스 버튼 누름은 <code>&quot;mousedown&quot;</code>, <code>&quot;mouseup&quot;</code> 및 <code>&quot;click&quot;</code> 이벤트를 작동시킵니다. 마우스 이동은 <code>&quot;mousemove&quot;</code> 이벤트를 작동시킵니다. 터치 스크린 상호작용은 <code>&quot;touchstart&quot;</code>, <code>&quot;touchmove&quot;</code> 및 <code>&quot;touchend&quot;</code> 이벤트와 연관됩니다.</p>

<p><a class="p_ident" id="p_zwo0vgzm7O" href="#p_zwo0vgzm7O" tabindex="-1" role="presentation"></a>Scrolling은 <code>&quot;scroll&quot;</code> 이벤트로 탐지되고, focus 변화는 <code>&quot;focus&quot;</code> 및 <code>&quot;blur&quot;</code> 이벤트로 탐지될 수 있습니다. 문서 로드 종료 시에 <code>&quot;load&quot;</code> 이벤트가 윈도우 상에서 작동됩니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_ZPJB9UFdQA" href="#i_ZPJB9UFdQA" tabindex="-1" role="presentation"></a>Balloon</h3>

<p><a class="p_ident" id="p_bYd6pEDTM7" href="#p_bYd6pEDTM7" tabindex="-1" role="presentation"></a>풍선을 전시하는 페이지를 작성합니다(이모티콘 🎈을 사용). up 화살표를 누르면 10% 확대되고 down 화살표를 누르면 10% 축소됩니다.</p>

<p><a class="p_ident" id="p_ktZgwjxebp" href="#p_ktZgwjxebp" tabindex="-1" role="presentation"></a><code>font-size</code> CSS 속성을 (<code>style.fontSize</code>) 부모 요소 상에서 설정하여 텍스트 (emoji가 텍스트) 크기를 조정할 수 있습니다. 값에 단위를 포함시켜야 합니다(예를 들어, 픽셀 (<code>10px</code>)과 같은).</p>

<p><a class="p_ident" id="p_5IHxQ3D2Mc" href="#p_5IHxQ3D2Mc" tabindex="-1" role="presentation"></a>화살표 키의 이름은 <code>&quot;ArrowUp&quot;</code> 및 <code>&quot;ArrowDown&quot;</code>입니다. 페이지를 스크롤하지 않고 키가 풍선만 변경하는지 확인합니다.</p>

<p><a class="p_ident" id="p_kqnmdZaGYC" href="#p_kqnmdZaGYC" tabindex="-1" role="presentation"></a>그것이 작동되면 풍선을 특정 크기 이상으로 부풀리면 터지는 기능을 추가합니다. 이 경우에 폭발은 💥 이모티콘으로 대체되고 이벤트 처리기가 제거됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html"  data-focus="true"><a class="c_ident" id="c_cG9w6ciW0L" href="#c_cG9w6ciW0L" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>🎈<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// 여기에 코드 작성</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_01AbHu5E/h" href="#p_01AbHu5E/h" tabindex="-1" role="presentation"></a><code>&quot;keydown&quot;</code> 이벤트에 대한 처리기를 등록하고 up 또는 down 화살표 키가 눌렸는지 확인합니다.</p>

<p><a class="p_ident" id="p_HSkdm2Qn5Y" href="#p_HSkdm2Qn5Y" tabindex="-1" role="presentation"></a>현재 크기는 바인딩에 유지되어 새 크기를 기반으로 할 수 있습니다. DOM에서 풍선의 바인딩과 스타일 모두를 업데이트하는 크기를 업데이트하는 함수를 정의하면 이벤트 처리기에서 호출할 수 있고 시작 시 한 번 초기 크기를 설정할 수 있도록 정의하는데 도움이 됩니다.</p>

<p><a class="p_ident" id="p_H1O0U7JLAU" href="#p_H1O0U7JLAU" tabindex="-1" role="presentation"></a>텍스트 노드를 다른 노드로 교체하거나(<code>replaceChild</code>를 사용하여) 또는 그것의 부모 노드의 code>textContent</code> 속성을 새 문자열로 설정하여 풍선을 폭발로 변경할 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_NOgRH0Y9st" href="#i_NOgRH0Y9st" tabindex="-1" role="presentation"></a>마우스 트레일</h3>

<p><a class="p_ident" id="p_LbKyZCJxyG" href="#p_LbKyZCJxyG" tabindex="-1" role="presentation"></a>많은 애니메이션 이미지가 있는 화려한 홈 페이지의 전성기였던 JavaScript의 초기에 사람들은 언어를 사용하는 진정으로 영감을 주는 몇 가지 방법을 생각해 냈습니다.</p>

<p><a class="p_ident" id="p_ZseDCwl6/C" href="#p_ZseDCwl6/C" tabindex="-1" role="presentation"></a>그 중 하나는 페이지에서 마우스 포인터를 움직일 때 따라가는 일련의 요소인 마우스 흔적이었습니다.</p>

<p><a class="p_ident" id="p_jft4unkoqB" href="#p_jft4unkoqB" tabindex="-1" role="presentation"></a>이 연습에서는 마우스 트레일을 구현해 보겠습니다. 절대 위치 <code>&lt;div&gt;</code>에 고정된 크기와 배경색을 가진 요소를 사용하십시오. 이러한 요소를 많이 만들고 마우스가 움직일 때 마우스 포인터를 작동시켜 표시합니다.</p>

<p><a class="p_ident" id="p_mHJUfC5Anf" href="#p_mHJUfC5Anf" tabindex="-1" role="presentation"></a>여기에는 다양한 가능한 접근 방식이 있습니다. 솔루션을 원하는 만큼 간단하게 또는 복잡하게 만들 수 있습니다. 시작하는 간단한 솔루션은 고정된 수의 트레일 요소를 유지하고 이를 순환하면서 <code>&quot;mousemove&quot;</code> 이벤트가 발생할 때마다 다음 요소를 마우스의 현재 위치로 이동하는 것입니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_I0KwYAPM1r" href="#c_I0KwYAPM1r" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-qualifier">.trail</span> { <span class="cm-comment">/* className for the trail elements */</span>
    <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;
    <span class="cm-property">height</span>: <span class="cm-number">6px</span>; <span class="cm-property">width</span>: <span class="cm-number">6px</span>;
    <span class="cm-property">border-radius</span>: <span class="cm-number">3px</span>;
    <span class="cm-property">background</span>: <span class="cm-keyword">teal</span>;
  }
  <span class="cm-tag">body</span> {
    <span class="cm-property">height</span>: <span class="cm-number">300px</span>;
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">style</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// 여기에 코드 작성</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_2Ngnp4yWsj" href="#p_2Ngnp4yWsj" tabindex="-1" role="presentation"></a>요소를 만들기 위해 루프를 사용하는 것이 가장 좋습니다. 문서에 추가하여 표시되도록 합니다. 나중에 액세스하여 위치를 변경할 수 있도록 하려면 요소를 배열에 저장해야 합니다.</p>

<p><a class="p_ident" id="p_seJm6U8e4t" href="#p_seJm6U8e4t" tabindex="-1" role="presentation"></a>그것들을 순환하는 것은 카운터 변수를 유지하고 <code>&quot;mousemove&quot;</code> 이벤트가 발생할 때마다 1을 추가하여 수행할 수 있습니다. 그런 다음 나머지 연산자(<code>% elements.<wbr>length</code>)를 사용하여 주어진 이벤트 동안 배치하려는 요소를 선택하는 유효한 배열 인덱스를 얻을 수 있습니다.</p>

<p><a class="p_ident" id="p_cJRZn+Vuv9" href="#p_cJRZn+Vuv9" tabindex="-1" role="presentation"></a>간단한 물리 시스템을 모델링하여 또 다른 흥미로운 효과를 얻을 수 있습니다. <code>&quot;mousemove&quot;</code> 이벤트를 사용하여 마우스 위치를 추적하는 바인딩 쌍을 업데이트하십시오. 그런 다음 <code>requestAnimationFrame</code>를 사용하여 마우스 포인터 위치에 끌리는 후행 요소를 시뮬레이션합니다. 모든 애니메이션 단계에서 포인터에 상대적인 위치를 기반으로 위치를 업데이트합니다(선택적으로 각 요소에 대해 저장된 속도).</p>

</div></div>

<h3><a class="i_ident" id="i_Kk1WKx2anJ" href="#i_Kk1WKx2anJ" tabindex="-1" role="presentation"></a>Tabs</h3>

<p><a class="p_ident" id="p_hJ2BbC0iJH" href="#p_hJ2BbC0iJH" tabindex="-1" role="presentation"></a>탭 판넬은 사용자 인터페이스에서 널리 사용됩니다. 요소 위의 튀어 나온 탭의 수에서 선택하여 인터페이스 판넬을 선택할 수 있습니다.</p>

<p><a class="p_ident" id="p_rh5X8kUE8g" href="#p_rh5X8kUE8g" tabindex="-1" role="presentation"></a>다음 연습은 간단한 탭 인터페이스를 구현합니다. DOM 노드를 사용하여 해당 노드의 자식 요소를 표시하는 탭 인터페이스를 만드는 함수 <code>asTabs</code>을 작성합니다. 노드의 맨 위에 각 자식 요소에 대해 하나씩 자식의<code>data-tabname</code> 속성에서 검색된 텍스트가 포함된 요소 리스트를 삽입해야 합니다. 원래 자식 중 하나만 제외하고 모두 숨겨야 합니다(<code>none</code>의 <code>display</code> 스타일 지정). 현재 보이는 노드는 버튼을 클릭하여 선택할 수 있습니다.</p>

<p><a class="p_ident" id="p_TlKLllZaBb" href="#p_TlKLllZaBb" tabindex="-1" role="presentation"></a>작동하면 현재 선택된 탭의 버튼 스타일을 다르게 지정하여 어떤 탭이 선택되었는지 명확하게 알 수 있도록 확장합니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_FKji/iKKCg" href="#c_FKji/iKKCg" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">tab-panel</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">&quot;one&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Tab one<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">&quot;two&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Tab two<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span> <span class="cm-attribute">data-tabname</span>=<span class="cm-string">&quot;three&quot;</span><span class="cm-tag cm-bracket">&gt;</span>Tab three<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">tab-panel</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">asTabs</span>(<span class="cm-def">node</span>) {
    <span class="cm-comment">// 여기에 코드 작성</span>
  }
  <span class="cm-variable">asTabs</span>(<span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;tab-panel&quot;</span>));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_uF9atTSMgL" href="#p_uF9atTSMgL" tabindex="-1" role="presentation"></a>한 가지 함정은 노드의 <code>childNodes</code> 속성을 탭 노드의 모음으로 직접 사용할 수 없다는 것입니다. 우선 버튼을 추가할 때 버튼도 자식 노드가 되고 라이브 데이터 구조이기 때문에 이 개체에서 끝납니다. 다른 경우에는 노드 사이의 공백에 대해 생성된 텍스트 노드도 포함 childNodes되지만 자체 탭을 가져서는 안 됩니다. <code>childNodes</code> 대신에 <code>children</code>을 사용하여 텍스트 노드를 무시할 수 있습니다.</p>

<p><a class="p_ident" id="p_pEwUiY3Alw" href="#p_pEwUiY3Alw" tabindex="-1" role="presentation"></a>탭 배열을 구축하여 쉽게 액세스할 수 있도록 시작할 수 있습니다. 버튼의 스타일을 구현하기 위해 탭 패널과 해당 버튼을 모두 포함하는 객체를 저장할 수 있습니다.</p>

<p><a class="p_ident" id="p_Ejl1JbiNLC" href="#p_Ejl1JbiNLC" tabindex="-1" role="presentation"></a>탭 변경을 위한 별도의 함수를 작성하는 것이 좋습니다. 이전에 선택한 탭을 저장하고 해당 탭을 숨기고 새 탭을 표시하는 데 필요한 스타일만 변경하거나 새 탭이 선택될 때마다 모든 탭의 스타일을 업데이트할 수 있습니다.</p>

<p><a class="p_ident" id="p_2M7g5hWy1u" href="#p_2M7g5hWy1u" tabindex="-1" role="presentation"></a>이 함수를 즉시 호출하여 첫 번째 탭이 표시되는 인터페이스가 시작되도록 할 수 있습니다.</p>

</div></div><nav><a href="14_dom.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="16_game.html" title="next chapter">▶</a></nav>
</article>