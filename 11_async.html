<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>비동기 프로그래밍</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 11;var sandboxLoadFiles = ["code/crow-tech.js","code/chapter/11_async.js"];</script></head>

<article>
<nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>11장</span>비동기 프로그래밍</h1>

<blockquote>

<p><a class="p_ident" id="p_zgFDYrsuxU" href="#p_zgFDYrsuxU" tabindex="-1" role="presentation"></a>진흙이 가라앉는 동안 누가 조용히 기다릴 수 있겠습니까?<br>
행동의 순간까지 누가 가만히 있을 수 있겠습니까?</p>

<footer>Laozi, <cite>Tao Te Ching</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_11.jpg" alt="Picture of two crows on a branch"></figure>

<p><a class="p_ident" id="p_i07NtkAZRR" href="#p_i07NtkAZRR" tabindex="-1" role="presentation"></a>컴퓨터의 중심 부분, 즉 프로그램을 구성하는 개별 단계를 수행하는 부분을 <em>processor</em>라 합니다. 지금까지 살펴 본 프로그램은 작업을 마칠 때까지 프로세서를 계속 바쁘게 유지하는 것입니다. 숫자를 조작하는 루프와 같은 것이 실행될 수 있는 속도는 전적으로 프로세서의 속도에 달려 있습니다.</p>

<p><a class="p_ident" id="p_DvfTBQjvgo" href="#p_DvfTBQjvgo" tabindex="-1" role="presentation"></a>그러나 많은 프로그램은 프로세서 외부의 것들과 상호 작용합니다. 예를 들어, 컴퓨터 네트워크를 통해 통신하거나 하드 디스크에서 데이터를 요청할 수 있습니다. 이는 메모리에서 가져오는 것보다 훨씬 느립니다.</p>

<p><a class="p_ident" id="p_QDVyt/iXeq" href="#p_QDVyt/iXeq" tabindex="-1" role="presentation"></a>그러한 일이 발생했을 때 프로세서를 유휴 상태로 두는 것은 바람직하지 않습니다. 그 동안 다른 작업을 수행할 수 있습니다. 부분적으로 이것은 여러 실행 중인 프로그램 간에 프로세서를 전환하는 운영 체제에 의해 처리됩니다. 그러나 단일 프로그램이 네트워크 요청을 기다리는 동안 진행할 수 있기를 원하는 경우에는 도움이 되지 않습니다.</p>

<h2><a class="h_ident" id="h_HH3wvnWMnd" href="#h_HH3wvnWMnd" tabindex="-1" role="presentation"></a>비동기성(Asynchronicity)</h2>

<p><a class="p_ident" id="p_UMfVhtpDiH" href="#p_UMfVhtpDiH" tabindex="-1" role="presentation"></a><em>동기(synchronous)</em> 프로그래밍 모델에서는 한 번에 하나식 작업이 진행됩니다. 장기 실행 작업을 수행하는 함수를 호출하면 작업이 완료된 경우에만 결과를 반환할 수 있습니다. 이렇게 하면 작업이 수행되는 동안 프로그램이 중지됩니다.</p>

<p><a class="p_ident" id="p_w/nshgUouX" href="#p_w/nshgUouX" tabindex="-1" role="presentation"></a><em>비동기(asynchronous)</em> 모델은 동시에 여러 가지 작업이 진행되도록 합니다. 작업을 시작하면 프로그램이 계속 실행됩니다. 작업이 완료되면 프로그램이 이를 알리고 결과(예: 디스크에서 읽은 데이터)에 액세스합니다.</p>

<p><a class="p_ident" id="p_4+uLDdNazP" href="#p_4+uLDdNazP" tabindex="-1" role="presentation"></a>네트워크에서 두 리소스를 가져온 다음 결과를 결합하는 프로그램과 같은 예를 사용하여 동기식 프로그래밍과 비동기식 프로그래밍을 비교할 수 있습니다.</p>

<p><a class="p_ident" id="p_dCIBPdfDLZ" href="#p_dCIBPdfDLZ" tabindex="-1" role="presentation"></a>요청 함수가 작업을 완료한 후에만 반환되는 동기 환경에서 이 작업을 수행하는 가장 쉬운 방법은 요청을 하나씩 만드는 것입니다. 이것은 첫 번째 요청이 완료된 경우에만 두 번째 요청이 시작된다는 단점이 있습니다. 소요된 총 시간은 최소한 두 응답 시간의 합이 됩니다.</p>

<p><a class="p_ident" id="p_GzbDIalJ5Y" href="#p_GzbDIalJ5Y" tabindex="-1" role="presentation"></a>동기 시스템에서 이 문제에 대한 해결책은 제어 스레드를 추가로 시작하는 것입니다. <em>thread</em>는 또 다른 실행 프로그램으로 운영체제에 의해 다른 프로그램이 끼워질 수 있습니다. 여러 스레드가 각기 다른 다른 프로세서에서 동시에 실행될 수 있습니다. 두 번째 스레드가 두 번째 요청을 시작한 다음 두 스레드 모두 결과가 돌아올 때까지 기다린 후 결과를 결합하기 위해 재동기화합니다.</p>

<p><a class="p_ident" id="p_EWjYy77pGQ" href="#p_EWjYy77pGQ" tabindex="-1" role="presentation"></a>다음 다이어그램에서 굵은 선은 프로그램이 정상적으로 실행되는 데 소요된 시간을 나타내고 가는 선은 네트워크를 기다리는 데 소요된 시간을 나타냅니다. 동기식 모델에서 네트워크에 걸리는 시간은 주어진 제어 스레드에 대한 타임라인의 일부입니다. 비동기식 모델에서 개념적으로 네트워크 작업을 시작 하면 타임라인이 분할됩니다. 작업을 시작한 프로그램이 계속 실행되고 작업이 함께 수행되어 작업이 완료되면 프로그램에 알립니다.</p><figure><img src="img/control-io.svg" alt="Control flow for synchronous and asynchronous programming"></figure>

<p><a class="p_ident" id="p_2edJ/IzPV6" href="#p_2edJ/IzPV6" tabindex="-1" role="presentation"></a>차이점을 설명하는 또 다른 방법은 작업이 완료되기를 기다리는 것이 동기식 모델에서는 암시적이 지만 비동기식에서는 명시적으로 제어할 수 있다는 것입니다.</p>

<p><a class="p_ident" id="p_8Ij/ZgHMRP" href="#p_8Ij/ZgHMRP" tabindex="-1" role="presentation"></a>비동기성은 양방향을 차단합니다. 이는 직선 제어 모델에 맞지 않는 표현 프로그램을 쉽게 만들지만 직선을 따르는 표현 프로그램을 더 어색하게 만들 수도 있습니다. 이 페이지의 뒷부분에서 이러한 어색함을 해결하는 몇 가지 방법을 살펴보겠습니다.</p>

<p><a class="p_ident" id="p_9fBOnSzsqK" href="#p_9fBOnSzsqK" tabindex="-1" role="presentation"></a>JavaScript 프로그래밍 플랫폼인 브라우저와 Node.js는 스레드에 의존하지 않고 비동기식으로 작업을 수행합니다. 스레드를 사용한 프로그래밍은 악명 높기 때문에(프로그램이 한 번에 여러 작업을 수행할 때 프로그램이 하는 일을 이해하는 것이 훨씬 더 어려움) 이것은 일반적으로 좋은 것으로 간주됩니다.</p>

<h2><a class="h_ident" id="h_Lao/OEmKKI" href="#h_Lao/OEmKKI" tabindex="-1" role="presentation"></a>Crow 기법</h2>

<p><a class="p_ident" id="p_pnZ1JVpOVQ" href="#p_pnZ1JVpOVQ" tabindex="-1" role="presentation"></a>대부분의 사람들은 까마귀가 매우 똑똑한 새라는 사실을 알고 있습니다. 그것들은 도구를 사용하고, 미리 계획하고, 일을 기억하고, 심지어 이러한 일을 서로 소통할 수 있습니다.</p>

<p><a class="p_ident" id="p_C/prtcqwC/" href="#p_C/prtcqwC/" tabindex="-1" role="presentation"></a>예를 들어, 대부분의 까마귀 문화에는 컴퓨팅 장치를 구성할 수 있는 능력이 있습니다. 이들은 인간의 컴퓨팅 장치와 같이 전자가 아니지만 까마귀와 공생 관계를 발전시킨 흰개미와 밀접하게 관련된 종인 작은 곤충의 행동을 통해 작동합니다. 새들은 그들에게 음식을 제공하고, 그 대가로 곤충은 내부에 있는 생물의 도움으로 계산을 수행하는 복잡한 식민지를 만들고 운영합니다.</p>

<p><a class="p_ident" id="p_6lPeENM1/D" href="#p_6lPeENM1/D" tabindex="-1" role="presentation"></a>이러한 식민지는 일반적으로 크고 수명이 긴 둥지에 있습니다. 새와 곤충은 곤충이 살고 일하는 둥지의 나뭇가지 사이에 숨겨진 구근 모양의 점토 구조 네트워크를 구축하기 위해 함께 작동합니다.</p>

<p><a class="p_ident" id="p_GCtbVBOldY" href="#p_GCtbVBOldY" tabindex="-1" role="presentation"></a>다른 장치와 통신하기 위해 이러한 기계는 광 신호를 사용합니다. 까마귀는 특수 통신 줄기에 반사 물질 조각을 내장하고 곤충은 이를 다른 둥지에서 빛을 반사하도록 조준하여 데이터를 일련의 빠른 섬광으로 인코딩합니다. 이는 시각적 연결이 끊어지지 않은 둥지만 통신할 수 있음을 의미합니다.</p>

<p><a class="p_ident" id="p_vIkGOLeRGq" href="#p_vIkGOLeRGq" tabindex="-1" role="presentation"></a>다음은 Hières-sur-Amby 마을의 Rhône 강 유역에 있는 까마귀 둥지 네트워크로 둥지와 그 연결을 나타냅니다.</p><figure><img src="img/Hieres-sur-Amby.png" alt="A network of crow nests in a small village"></figure>

<p><a class="p_ident" id="p_DgtWrWr+T8" href="#p_DgtWrWr+T8" tabindex="-1" role="presentation"></a>까마귀 컴퓨터는 JavaScript를 실행합니다. 여기에서 그들을 위한 몇 가지 기본적인 네트워킹 함수들을 작성하기로 합니다.</p>

<h2><a class="h_ident" id="h_n9ws/jdPpb" href="#h_n9ws/jdPpb" tabindex="-1" role="presentation"></a>Callbacks</h2>

<p><a class="p_ident" id="p_He8eYTpzz8" href="#p_He8eYTpzz8" tabindex="-1" role="presentation"></a>비동기 프로그래밍에 대한 한 가지 접근 방식은 느린 동작을 수행하는 함수가 추가 인수인 <em>callback</em> 함수를 사용하도록 하는 것입니다. 작업이 시작되고 완료되면 결과와 함께 콜백 함수가 호출됩니다.</p>

<p><a class="p_ident" id="p_xXv7FoAy7v" href="#p_xXv7FoAy7v" tabindex="-1" role="presentation"></a>예를 들어, <code>setTimeout</code> 함수는 Node.js와 브라우저 모두에서 사용할 수 있는데 이 함수는 주어진 밀리초(1초는 1000밀리초) 동안 기다린 다음 함수를 호출합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RyFm7Uoiuv" href="#c_RyFm7Uoiuv" tabindex="-1" role="presentation"></a><span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Tick&quot;</span>), <span class="cm-number">500</span>);</pre>

<p><a class="p_ident" id="p_9Tu7uanv/t" href="#p_9Tu7uanv/t" tabindex="-1" role="presentation"></a>기다림은 일반적으로 그다지 중요한 작업 유형은 아니지만 애니메이션을 업데이트하거나 주어진 시간보다 오래 걸리는지 확인하는 것과 같은 작업을 수행할 때 유용할 수 있습니다.</p>

<p><a class="p_ident" id="p_7FItlRu6ne" href="#p_7FItlRu6ne" tabindex="-1" role="presentation"></a>콜백을 사용하여 연속으로 여러 비동기 작업을 수행한다는 것은 작업 이후에 계속되는 계산을 처리하기 위해 새 함수를 계속 전달해야 함을 의미합니다.</p>

<p><a class="p_ident" id="p_GBzdHEp9fD" href="#p_GBzdHEp9fD" tabindex="-1" role="presentation"></a>대부분의 까마귀 컴퓨터에는 나중에 검색할 수 있도록 정보 조각이 나뭇가지에 새겨지는 장기 데이터 저장 전구가 있습니다. 데이터를 식각하거나 찾는 데 시간이 걸리므로 장기 저장에 대한 인터페이스는 비동기식이며 콜백 함수를 사용합니다.</p>

<p><a class="p_ident" id="p_qrVbRBjxbB" href="#p_qrVbRBjxbB" tabindex="-1" role="presentation"></a>스토리지 전구는 JSON으로 인코딩 가능한 데이터 조각을 이름으로 저장합니다. 까마귀는 이름 아래에 음식이 숨겨져 있는 장소에 대한 정보를 <code>&quot;food caches&quot;</code>라는 이름으로 저장할 수 있습니다. 여기에는 실제 캐시를 설명하는 다른 데이터 조각을 가리키는 이름 배열이 포함될 수 있습니다. <em>Big Oak</em> 둥지의 저장 전구에서 음식 캐시를 조회하기 위해 까마귀는 다음과 같은 코드를 실행할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_f7XSZ4G+k8" href="#c_f7XSZ4G+k8" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">bigOak</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-string">&quot;food caches&quot;</span>, <span class="cm-def">caches</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">firstCache</span> <span class="cm-operator">=</span> <span class="cm-variable-2">caches</span>[<span class="cm-number">0</span>];
  <span class="cm-variable">bigOak</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">firstCache</span>, <span class="cm-def">info</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">info</span>);
  });
});</pre>

<p><a class="p_ident" id="p_drcmHan03C" href="#p_drcmHan03C" tabindex="-1" role="presentation"></a>(모든 바인딩 이름과 문자열은 까마귀 언어에서 영어로 번역되었습니다.)</p>

<p><a class="p_ident" id="p_aCzLiqd4ZF" href="#p_aCzLiqd4ZF" tabindex="-1" role="presentation"></a>이러한 스타일의 프로그래밍은 실행 가능하지만 다른 함수에서 끝나기 때문에 각 비동기 작업으로 들여쓰기 수준이 증가합니다. 동시에 여러 작업을 실행하는 것과 같이 더 복잡한 작업을 수행하는 것은 다소 어색할 수 있습니다.</p>

<p><a class="p_ident" id="p_HQVI9t8QwN" href="#p_HQVI9t8QwN" tabindex="-1" role="presentation"></a>까마귀 컴퓨터는 요청-응답 쌍을 사용하여 통신하도록 제작되었습니다. 즉, 하나의 내부 프로그램이 다른 내부 프로그램에 메시지를 보낸 다음 즉시 메시지를 다시 보내 수신을 확인하고 메시지에 묻는 질문에 대한 응답을 포함할 수 있습니다.</p>

<p><a class="p_ident" id="p_1UN167Dotu" href="#p_1UN167Dotu" tabindex="-1" role="presentation"></a>각 메시지에는 처리 방법을 결정하는 <em>type</em>으로 태그가 지정됩니다. 코드는 특정 요청 타입에 대한 처리기를 정의할 수 있으며 이러한 요청이 들어오면 처리기가 호출되어 응답을 생성합니다.</p>

<p><a class="p_ident" id="p_VJjqeXBfmZ" href="#p_VJjqeXBfmZ" tabindex="-1" role="presentation"></a><code>&quot;./<wbr>crow-tech&quot;</code> 모듈에서 내보낸 인터페이스는 통신을 위한 콜백 기반 기능을 제공합니다. 내부 프로그램에는 요청을 보내는 <code>send</code> 메서드가 있습니다. 대상 중첩의 이름, 요청 유형, 요청 내용을 처음 세 인수로 예상하고 네 번째이자 마지막 인수로 응답이 올 때 호출할 함수를 기대합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qzWIKDLKSP" href="#c_qzWIKDLKSP" tabindex="-1" role="presentation"></a><span class="cm-variable">bigOak</span>.<span class="cm-property">send</span>(<span class="cm-string">&quot;Cow Pasture&quot;</span>, <span class="cm-string">&quot;note&quot;</span>, <span class="cm-string">&quot;Let's caw loudly at 7PM&quot;</span>,
            () <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Note delivered.&quot;</span>));</pre>

<p><a class="p_ident" id="p_fY1oYJALqf" href="#p_fY1oYJALqf" tabindex="-1" role="presentation"></a>그러나 해당 요청을 수신할 수 있도록 하려면 먼저 <code>&quot;note&quot;</code>라는 요청 타입을 정의해야 합니다. 요청을 처리하는 코드는 이러한 타입의 메시지를 수신할 수 있는 모든 내부 프로그램에서 실행되어야 합니다. 까마귀가 날아와 모든 둥지에 처리기 코드를 설치한다고 가정하겠습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_38THPHvc7d" href="#c_38THPHvc7d" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">defineRequestType</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">defineRequestType</span>(<span class="cm-string">&quot;note&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">content</span>, <span class="cm-def">source</span>, <span class="cm-def">done</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received note: ${</span><span class="cm-variable-2">content</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable-2">done</span>();
});</pre>

<p><a class="p_ident" id="p_Mr/K2c1G6w" href="#p_Mr/K2c1G6w" tabindex="-1" role="presentation"></a><code>defineRequestType</code>ㅜ 함수는 새로운 타입의 요청을 정의합니다. 예에서는 <code>&quot;note&quot;</code> 요청에 대한 지원을 추가하여 주어진 내부 프로그램에 note를 보냅니다. 구현에서는 <code>console.log</code>를 호출하여 요청이 도착했는지 확인할 수 있도록 합니다. 내부 프로그램에는 이름을 유지하는 <code>name</code> 속성이 있습니다.</p>

<p><a class="p_ident" id="p_vzmLB4UIgA" href="#p_vzmLB4UIgA" tabindex="-1" role="presentation"></a>처리기에 제공된 네 번째 인수 <code>done</code>는 요청이 완료될 때 호출해야 하는 콜백 함수입니다. 처리기의 반환 값을 응답 값으로 사용한 경우 요청 처리기 자체가 비동기 작업을 수행할 수 없음을 의미합니다. 비동기식 작업을 수행하는 함수는 일반적으로 작업이 완료되기 전에 반환되며 완료될 때 콜백이 호출되도록 정렬합니다. 따라서 응답을 사용할 수 있을 때 신호를 보내는 비동기 메커니즘(이 경우 다른 콜백 함수)이 필요합니다.</p>

<p><a class="p_ident" id="p_Kg8Vsu1J2B" href="#p_Kg8Vsu1J2B" tabindex="-1" role="presentation"></a>어떤 면에서 비동기성은 <em>전파성</em>이 있습니다. 비동기식으로 작동하는 함수를 호출하는 모든 함수는 결과를 전달하기 위해 콜백 또는 유사한 메커니즘을 사용하여 자체적으로 비동기식이어야 합니다. 콜백 호출은 단순히 값을 반환하는 것보다 다소 복잡하고 오류가 발생하기 쉬우므로 프로그램의 많은 부분을 그런 식으로 구성해야 하는 것은 좋지 않습니다.</p>

<h2><a class="h_ident" id="h_sdRy5CTAP/" href="#h_sdRy5CTAP/" tabindex="-1" role="presentation"></a>Promises</h2>

<p><a class="p_ident" id="p_cJV/7Xc1YN" href="#p_cJV/7Xc1YN" tabindex="-1" role="presentation"></a>추상적 개념으로 작업하는 것은 그러한 개념이 값으로 표현될 수 있을 때 더 쉽습니다. 비동기 작업의 경우 미래의 어느 시점에서 함수가 호출되도록 배열하는 대신 이 미래 이벤트를 나타내는 객체를 반환할 수 있습니다.</p>

<p><a class="p_ident" id="p_c7IGxt0qcZ" href="#p_c7IGxt0qcZ" tabindex="-1" role="presentation"></a>이것이 바로 표준 클래스 <code>Promise</code>의 목적입니다. 약속은 어떤 시점에서 완료하고 값을 생성할 수 있는 비동기 작업입니다. 값이 있을 때 관심 있는 모든 사람에게 알릴 수 있습니다.</p>

<p><a class="p_ident" id="p_uoWOt7zYca" href="#p_uoWOt7zYca" tabindex="-1" role="presentation"></a>Promise를 생성하는 가장 쉬운 방법은 <code>Promise.resolve</code>를 호출하는 것입니다. 이 함수는 제공한 값이 약속으로 래핑되도록 합니다. 이미 promise인 경우 단순히 반환됩니다. 그렇지 않으면 결과로서 값으로 즉시 완료되는 새 promise를 얻습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_fzJ7VLwQ/i" href="#c_fzJ7VLwQ/i" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">fifteen</span> <span class="cm-operator">=</span> <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-number">15</span>);
<span class="cm-variable">fifteen</span>.<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`Got ${</span><span class="cm-variable-2">value</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>));
<span class="cm-comment">// → Got 15</span></pre>

<p><a class="p_ident" id="p_dq+GKs56Gg" href="#p_dq+GKs56Gg" tabindex="-1" role="presentation"></a>약속의 결과를 얻으려면 해당 <code>then</code> 메서드를 사용할 수 있습니다. 이것은 약속이 해결되고 값을 생성할 때 호출될 콜백 함수를 등록합니다. 하나의 약속에 여러 개의 콜백을 추가할 수 있으며 약속이 이미 해결(완료)된 후에 추가하더라도 호출됩니다.</p>

<p><a class="p_ident" id="p_BLNHvARdwj" href="#p_BLNHvARdwj" tabindex="-1" role="presentation"></a>하지만 <code>then</code> 메서드가 전부는 아닙니다. 처리기 함수가 반환하는 값으로 확인되는 다른 약속을 반환하거나, 약속을 반환하는 경우 해당 약속을 기다렸다가 결과로 확인할 수 있습니다.</p>

<p><a class="p_ident" id="p_I53M7bh5Zh" href="#p_I53M7bh5Zh" tabindex="-1" role="presentation"></a>약속을 비동기 현실로 값을 이동하는 장치로 생각하는 것이 유용합니다. 정상적인 값이 있을 뿐입니다. 약속된 값은 이미 존재하거나 미래의 어느 시점에 나타날 수 있는 값입니다 . 약속으로 정의된 계산은 이러한 래핑된 값에 대해 작동하며 값을 사용할 수 있게 되면 비동기적으로 실행됩니다.</p>

<p><a class="p_ident" id="p_sPGdi+3o75" href="#p_sPGdi+3o75" tabindex="-1" role="presentation"></a>Promise를 생성하기 위해 <code>Promise</code> 생성자를 사용할 수 있습니다. 그것은 다소 이상한 인터페이스를 가지고 있습니다. 생성자는 함수를 인수로 예상하고 즉시 호출하여 약속을 해결하는 데 사용할 수 있는 함수를 전달합니다. 예를 들어 <code>resolve</code> 메서드 대신 이러한 방식으로 작동하므로 약속을 생성한 코드만 이를 해결할 수 있습니다.</p>

<p><a class="p_ident" id="p_N1xvulQh1Y" href="#p_N1xvulQh1Y" tabindex="-1" role="presentation"></a>다음은 <code>readStorage</code> 함수에 대한 약속 기반 인터페이스를 만드는 방법입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gYXlRtzMyd" href="#c_gYXlRtzMyd" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">storage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">nest</span>.<span class="cm-property">readStorage</span>(<span class="cm-variable-2">name</span>, <span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">result</span>));
  });
}

<span class="cm-variable">storage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;enemies&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Got&quot;</span>, <span class="cm-variable-2">value</span>));</pre>

<p><a class="p_ident" id="p_teu5aKy22g" href="#p_teu5aKy22g" tabindex="-1" role="presentation"></a>이 비동기 함수는 의미 있는 값을 반환합니다. 이것이 Promise의 주요 장점입니다. 즉, 비동기 함수의 사용을 단순화합니다. 콜백을 전달하는 대신 약속 기반 함수는 일반 함수와 비슷하게 보입니다. 입력을 인수로 받아 출력을 반환합니다. 유일한 차이점은 출력이 아직 사용 가능하지 않을 수 있다는 것입니다.</p>

<h2><a class="h_ident" id="h_FlZkkRfkN/" href="#h_FlZkkRfkN/" tabindex="-1" role="presentation"></a>Failure</h2>

<p><a class="p_ident" id="p_3xQ2mMjPI/" href="#p_3xQ2mMjPI/" tabindex="-1" role="presentation"></a>일반 JavaScript 계산은 예외를 던져 실패할 수 있습니다. 비동기식 계산에는 종종 이와 같은 것이 필요합니다. 네트워크 요청이 실패하거나 비동기 계산의 일부인 일부 코드에서 예외가 발생할 수 있습니다.</p>

<p><a class="p_ident" id="p_U/HpYNT9Y/" href="#p_U/HpYNT9Y/" tabindex="-1" role="presentation"></a>비동기 프로그래밍의 콜백 스타일에서 가장 시급한 문제 중 하나는 실패가 콜백에 제대로 보고되는지 확인하기가 매우 어렵다는 것입니다.</p>

<p><a class="p_ident" id="p_o521HDp6Q3" href="#p_o521HDp6Q3" tabindex="-1" role="presentation"></a>널리 사용되는 규칙은 콜백에 대한 첫 번째 인수가 작업이 실패했음을 나타내는 데 사용되고 두 번째 인수는 성공했을 때 작업에서 생성된 값을 포함하는 것입니다. 이러한 콜백 함수는 항상 예외를 수신했는지 확인하고 호출한 함수에서 발생하는 예외를 포함하여 발생하는 모든 문제를 포착하여 올바른 함수에 제공해야 합니다.</p>

<p><a class="p_ident" id="p_sdBQKhfBzG" href="#p_sdBQKhfBzG" tabindex="-1" role="presentation"></a>약속은 이것을 더 쉽게 만듭니다. 해결(작업이 성공적으로 완료됨) 또는 거부(실패)할 수 있습니다. Resolve 처리기들은 (<code>then</code>을 통해 등록된) 작업이 성공한 경우에만 호출되고 거부는 <code>then</code>에서 반환하는 새 약속으로 자동으로 전파됩니다. 그리고 처리기가 예외를 던지면 <code>then</code>에 의해 생성된 프라미스가 자동으로 거부됩니다. 따라서 비동기 작업 체인의 요소가 실패하면 전체 체인의 결과가 거부된 것으로 표시되고 실패한 지점을 넘어서는 성공 처리기가 호출되지 않습니다.</p>

<p><a class="p_ident" id="p_/Duy2d2EJl" href="#p_/Duy2d2EJl" tabindex="-1" role="presentation"></a>약속을 해결하는 것이 값을 제공하는 것과 마찬가지로 하나를 거부하는 것도 하나를 제공합니다. 일반적으로 거부 사유라고 합니다. 처리기 함수의 예외로 인해 거부가 발생한 경우 예외 값을 사유로 사용합니다. 마찬가지로 처리기가 거부된 약속을 반환하면 해당 거부는 다음 약속으로 넘어갑니다. 즉시 거부된 새로운 promise를 생성하는 함수 <code>Promise.reject</code>가 있습니다.</p>

<p><a class="p_ident" id="p_n8xS1bRY5C" href="#p_n8xS1bRY5C" tabindex="-1" role="presentation"></a>이러한 거부를 명시적으로 처리하기 위해 프라미스에는 <code>then</code> 처리기가 일반 해결을 처리하는 방식과 유사하게 프라미스가 거부될 때 호출될 핸들러를 등록하는 <code>catch</code> 메서드가 있습니다. 또한 정상적으로 해결되면 원래 약속의 값으로 해결되고 그렇지 않으면 <code>catch</code> 처리기의 결과로 해결되는 새 약속을 반환한다는 점에서 <code>then</code>과 매우 유사합니다. <code>catch</code> 처리기에서 오류가 발생하면, 새로운 약속도 거부됩니다.</p>

<p><a class="p_ident" id="p_M0B+/Jkbg2" href="#p_M0B+/Jkbg2" tabindex="-1" role="presentation"></a>요컨대, <code>then</code> 또한 거부 처리기를 두 번째 인수로 허용하므로 단일 메서드 호출에서 두 가지 유형의 처리기를 모두 설치할 수 있습니다.</p>

<p><a class="p_ident" id="p_JarwEqSrWp" href="#p_JarwEqSrWp" tabindex="-1" role="presentation"></a><code>Promise</code> 생성자에 전달된 함수는 새 약속을 거부하는 데 사용할 수 있는 resolve 함수와 함께 두 번째 인수를 받습니다.</p>

<p><a class="p_ident" id="p_z3DyjoAwVl" href="#p_z3DyjoAwVl" tabindex="-1" role="presentation"></a><code>then</code>과 <code>catch</code> 호출에 의해 만들어진 약속 값의 체인은 비동기 값이나 실패가 이동되는 파이프 라인으로 간주할 수 있습니다. 이러한 체인은 처리기 등록하여 생성되기 때문에 각 링크에는 연결된 성공 처리기 또는 거부 처리기(또는 둘 다)가 있습니다. 결과 타입(성공 또는 실패)과 일치하지 않는 처리기는 무시됩니다. 그러나 일치하는 항목이 호출되고 결과에 따라 다음 값이 결정됩니다. 즉, non-promise 값을 반환하면 성공, 예외를 던지면 거부, 그 중 하나를 반환하면 약석의 결과가 나타납니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_TOwOnoqIIW" href="#c_TOwOnoqIIW" tabindex="-1" role="presentation"></a><span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">_</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Fail&quot;</span>)))
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 1&quot;</span>))
  .<span class="cm-property">catch</span>(<span class="cm-def">reason</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught failure &quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">reason</span>);
    <span class="cm-keyword">return</span> <span class="cm-string">&quot;nothing&quot;</span>;
  })
  .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Handler 2&quot;</span>, <span class="cm-variable-2">value</span>));
<span class="cm-comment">// → Caught failure Error: Fail</span>
<span class="cm-comment">// → Handler 2 nothing</span></pre>

<p><a class="p_ident" id="p_221BynGy7j" href="#p_221BynGy7j" tabindex="-1" role="presentation"></a>잡히지 않은 예외가 환경에서 처리되는 것과 마찬가지로 JavaScript 환경은 약속 거부가 처리되지 않을 때 이를 감지할 수 있으며 이를 오류로 보고합니다.</p>

<h2><a class="h_ident" id="h_o8Vlf60I8f" href="#h_o8Vlf60I8f" tabindex="-1" role="presentation"></a>네트워크의 어려움</h2>

<p><a class="p_ident" id="p_fjvcMK987B" href="#p_fjvcMK987B" tabindex="-1" role="presentation"></a>때때로 까마귀의 거울 시스템이 신호를 전송하기에 충분한 빛이 없거나 신호의 경로를 차단하는 것이 있습니다. 신호가 전송되었지만 수신되지 않을 수 있습니다.</p>

<p><a class="p_ident" id="p_lbPe1lr2o1" href="#p_lbPe1lr2o1" tabindex="-1" role="presentation"></a>있는 그대로 <code>send</code>에 주어진 콜백이 호출되지 않도록 하여 문제가 있음을 인지하지 못한 채 프로그램이 중지될 수 있습니다. 일정 기간 동안 응답을 받지 못한 후 요청이 시간 초과되어 실패를 보고하면 좋을 것입니다.</p>

<p><a class="p_ident" id="p_uW9fnd/IuC" href="#p_uW9fnd/IuC" tabindex="-1" role="presentation"></a>종종 전송 실패는 자동차의 헤드라이트가 빛 신호를 방해하는 것과 같은 무작위 사고이며 단순히 요청을 재시도하면 성공할 수 있습니다. 그래서 그것에 있는 동안 요청 기능이 포기하기 전에 요청 전송을 몇 번 자동으로 재시도하도록 합시다.</p>

<p><a class="p_ident" id="p_aJq/gxAcrD" href="#p_aJq/gxAcrD" tabindex="-1" role="presentation"></a>그리고 Promise가 좋은 것임을 확인했기 때문에 요청 함수가 Promise를 반환하도록 할 것입니다. 표현할 수 있는 것의 측면에서 콜백과 약속은 동일합니다. 콜백 기반 함수는 약속 기반 인터페이스를 노출하도록 래핑될 수 있으며 그 반대의 경우도 마찬가지입니다.</p>

<p><a class="p_ident" id="p_5BHxJdJVP6" href="#p_5BHxJdJVP6" tabindex="-1" role="presentation"></a>요청과 해당 응답이 성공적으로 전달된 경우에도 응답은 실패를 나타낼 수 있습니다. 예를 들어 요청이 정의되지 않은 요청 유형을 사용하려고 하거나 핸들러에서 오류가 발생하는 경우입니다. 이 기능을 지원하려면 <code>send</code>와 <code>defineRequestType</code>는 앞에 언급한 관례를 따라야 합니다. 콜백에 전달된 첫 번째 인수는 실패 이유(있는 경우), 두 번째는 실제 결과 이전에 언급한 규칙을 따릅니다.</p>

<p><a class="p_ident" id="p_97bGw9TnRL" href="#p_97bGw9TnRL" tabindex="-1" role="presentation"></a>이것은 래퍼에 의해 해결 및 거부를 약속하는 것으로 간주할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Wg7xZ1po7J" href="#c_Wg7xZ1po7J" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Timeout</span> <span class="cm-keyword">extends</span> <span class="cm-variable">Error</span> {}

<span class="cm-keyword">function</span> <span class="cm-def">request</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">done</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">function</span> <span class="cm-def">attempt</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable-2">nest</span>.<span class="cm-property">send</span>(<span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>, (<span class="cm-def">failed</span>, <span class="cm-def">value</span>) <span class="cm-operator">=&gt;</span> {
        <span class="cm-variable-2">done</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">failed</span>) <span class="cm-variable-2">reject</span>(<span class="cm-variable-2">failed</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">value</span>);
      });
      <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">done</span>) <span class="cm-keyword">return</span>;
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>) <span class="cm-variable-2">attempt</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span> <span class="cm-variable-2">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Timeout</span>(<span class="cm-string">&quot;Timed out&quot;</span>));
      }, <span class="cm-number">250</span>);
    }
    <span class="cm-variable-2">attempt</span>(<span class="cm-number">1</span>);
  });
}</pre>

<p><a class="p_ident" id="p_st0GjZl4iZ" href="#p_st0GjZl4iZ" tabindex="-1" role="presentation"></a>약속은 한 번만 해결(또는 거부)될 수 있으므로 이것이 작동합니다. 처음으로 <code>resolve</code> 또는 <code>reject</code>가 호출되면 약속의 결과가 결정되고 다른 요청이 완료된 후 다시 오는 요청으로 인해 발생하는 추가 호출은 무시됩니다.</p>

<p><a class="p_ident" id="p_WbNhsnDMXt" href="#p_WbNhsnDMXt" tabindex="-1" role="presentation"></a>비동기 루프를 구축하려면 재시도를 위해 재귀 함수를 사용해야 합니다. 일반 루프에서는 비동기 작업을 중지하고 기다릴 수 없습니다. <code>attempt</code> 함수는 요청 전송을 한 번만 시도합니다. 또한 250밀리초 후에 응답이 돌아오지 않으면 다음 시도를 시작하거나 세 번째 시도인 경우 의 인스턴스를 <code>Timeout</code> 이유로 약속을 거부하는 제한 시간을 설정합니다.</p>

<p><a class="p_ident" id="p_acM5kja+EL" href="#p_acM5kja+EL" tabindex="-1" role="presentation"></a>1/4초마다 재시도하고 3/4초 후에도 응답이 없을 때 포기하는 것은 확실히 다소 임의적입니다. 요청이 전달되었지만 핸들러가 요청을 여러 번 전달하는 데 시간이 조금 더 오래 걸리는 경우에도 가능합니다. 그 문제를 염두에 두고 처리기를 작성해야 합니다. 중복 메시지는 무해해야 합니다.</p>

<p><a class="p_ident" id="p_8G2rFK/pFH" href="#p_8G2rFK/pFH" tabindex="-1" role="presentation"></a>콜백에서 완전히 분리하기 위해 핸들러 함수가 약속 또는 일반 값을 반환하고 이를 콜백에 연결할 수 있도록 하는 <code>defineRequestType</code> 래퍼도 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HejJcHo3dj" href="#c_HejJcHo3dj" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">requestType</span>(<span class="cm-def">name</span>, <span class="cm-def">handler</span>) {
  <span class="cm-variable">defineRequestType</span>(<span class="cm-variable-2">name</span>, (<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>,
                           <span class="cm-variable">callback</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-variable-2">handler</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">content</span>, <span class="cm-variable">source</span>))
        .<span class="cm-property">then</span>(<span class="cm-def">response</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">response</span>),
              <span class="cm-def">failure</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">callback</span>(<span class="cm-variable-2">failure</span>));
    } <span class="cm-keyword">catch</span> (<span class="cm-def">exception</span>) {
      <span class="cm-variable">callback</span>(<span class="cm-variable-2">exception</span>);
    }
  });
}</pre>

<p><a class="p_ident" id="p_m5fm86hZW6" href="#p_m5fm86hZW6" tabindex="-1" role="presentation"></a><code>Promise.resolve</code>는 <code>handler</code>에 의해 반환되는 값이 존재하지 않는다는 약속으로 변환하는데 사용됩니다.</p>

<p><a class="p_ident" id="p_CAzmYCfy+I" href="#p_CAzmYCfy+I" tabindex="-1" role="presentation"></a><code>handler</code>에 대한 호출은 직접 발생하는 모든 예외가 콜백에 제공되도록 하기 위해 <code>try</code> 블록으로 래핑되어야 합니다. 이것은 원시 콜백으로 오류를 적절하게 처리하는 것의 어려움을 잘 보여줍니다. 이러한 예외를 적절하게 라우팅하는 것을 잊어버리기 쉽고, 그렇게 하지 않으면 실패가 올바른 콜백에 보고되지 않습니다. Promise는 이것을 대부분 자동으로 만들어 오류가 덜 발생합니다.</p>

<h2><a class="h_ident" id="h_4rfkjtrFcP" href="#h_4rfkjtrFcP" tabindex="-1" role="presentation"></a>promises 모음</h2>

<p><a class="p_ident" id="p_aICANM74sI" href="#p_aICANM74sI" tabindex="-1" role="presentation"></a>각 내부 프로그램은 해당 이웃 속성의 전송 거리 내에서 다른 포함된 배열을 유지합니다. 이들 중 현재 도달할 수 있는 항목을 확인하려면 각각에 <code>&quot;ping&quot;</code> 요청(단순히 응답을 요청하는 요청)을 보내고 어떤 항목이 돌아오는지 확인하는 함수를 작성할 수 있습니다.</p>

<p><a class="p_ident" id="p_fBcfo2czu8" href="#p_fBcfo2czu8" tabindex="-1" role="presentation"></a>동시에 실행되는 Promise 컬렉션으로 작업할 때 <code>Promise.all</code> 함수가 유용할 수 있습니다. 배열의 모든 프라미스가 확인될 때까지 기다린 다음 이러한 프라미스가 생성한 값의 배열(원래 배열과 동일한 순서로)로 확인되는 프라미스를 반환합니다. 약속이 거부되면 의 결과 <code>Promise.all</code> 자체가 거부됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZtEtR5AsHV" href="#c_ZtEtR5AsHV" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;ping&quot;</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-string">&quot;pong&quot;</span>);

<span class="cm-keyword">function</span> <span class="cm-def">availableNeighbors</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">requests</span> <span class="cm-operator">=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">map</span>(<span class="cm-def">neighbor</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;ping&quot;</span>)
      .<span class="cm-property">then</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-atom">true</span>, () <span class="cm-operator">=&gt;</span> <span class="cm-atom">false</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">requests</span>).<span class="cm-property">then</span>(<span class="cm-def">result</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">filter</span>((<span class="cm-def">_</span>, <span class="cm-def">i</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">result</span>[<span class="cm-variable-2">i</span>]);
  });
}</pre>

<p><a class="p_ident" id="p_p074kPsd4q" href="#p_p074kPsd4q" tabindex="-1" role="presentation"></a>이웃을 사용할 수 없을 때 결합된 전체 약속이 실패하는 것을 원하지 않습니다. 그 이후로는 여전히 아무것도 알 수 없기 때문입니다. 따라서 이웃 집합에 매핑되어 요청 약속으로 전환하는 함수는 성공적인 요청 <code>true</code>을 생성하고 거부된 요청은 <code>false</code>로 생성하는 처리기를 연결합니다.</p>

<p><a class="p_ident" id="p_xJZvWO1Y4P" href="#p_xJZvWO1Y4P" tabindex="-1" role="presentation"></a>결합된 약속에 관한 처리기에서 <code>filter</code>는 대응 값이 false인 <code>neighbors</code> 배열로부터 그러한 요소들을 제거하기 위해 사용됩니다. 이것은 <code>filter</code>가 현재 요소의 배열 인덱스를 필터링 함수에 두 번째 인수로 전달 한다는 사실을 이용합니다(<code>map</code>, <code>some</code> 및 유사한 고차 배열 메서드도 동일).</p>

<h2><a class="h_ident" id="h_pi4+kiBmAy" href="#h_pi4+kiBmAy" tabindex="-1" role="presentation"></a>Network flooding</h2>

<p><a class="p_ident" id="p_ktVbTscCrR" href="#p_ktVbTscCrR" tabindex="-1" role="presentation"></a>내부 프로그램들이 이웃과만 대화할 수 있다는 사실은 네트워크의 유용성을 크게 저해합니다.</p>

<p><a class="p_ident" id="p_/O0D1BFKEk" href="#p_/O0D1BFKEk" tabindex="-1" role="presentation"></a>전체 네트워크에 정보를 브로드캐스팅 하는 경우 한 가지 솔루션은 이웃에게 자동으로 전달되는 요청 타입을 설정하는 것입니다. 그런 다음 이러한 이웃은 전체 네트워크가 메시지를 수신할 때까지 이를 이웃에게 차례로 전달합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_wHo3Wk05Ya" href="#c_wHo3Wk05Ya" tabindex="-1" role="presentation"></a><span class="cm-keyword">import</span> {<span class="cm-def">everywhere</span>} <span class="cm-keyword">from</span> <span class="cm-string">&quot;./crow-tech&quot;</span>;

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span> <span class="cm-operator">=</span> [];
});

<span class="cm-keyword">function</span> <span class="cm-def">sendGossip</span>(<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">message</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;gossip&quot;</span>, <span class="cm-variable-2">message</span>);
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;gossip&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">message</span>, <span class="cm-def">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">gossip</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">message</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable-2">nest</span>.<span class="cm-property">name</span><span class="cm-string-2">}</span> <span class="cm-string-2">received gossip '${</span>
               <span class="cm-variable-2">message</span><span class="cm-string-2">}</span><span class="cm-string-2">' from ${</span><span class="cm-variable-2">source</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  <span class="cm-variable">sendGossip</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">message</span>, <span class="cm-variable-2">source</span>);
});</pre>

<p><a class="p_ident" id="p_BxJ3gAVNXY" href="#p_BxJ3gAVNXY" tabindex="-1" role="presentation"></a>네트워크에서 동일한 메시지를 영원히 보내는 것을 피하기 위해 각 내부 프로그램은 이미 본 가십 문자열의 배열을 유지합니다. 이 배열을 정의하기 위해 모든 중첩에서 코드를 실행하는 <code>everywhere</code> 함수를 사용하여 내부 프로그램의 <code>state</code> 객체에 속성을 추가합니다. 여기에서 중첩 로컬 상태를 유지할 것입니다.</p>

<p><a class="p_ident" id="p_iuIpNkZ6Y1" href="#p_iuIpNkZ6Y1" tabindex="-1" role="presentation"></a>내부 프로그램이 중복된 가십 메시지를 받으면 모든 사람이 맹목적으로 다시 보낼 가능성이 매우 높지만 무시합니다. 그러나 새로운 메시지를 받으면 메시지를 보낸 사람을 제외한 모든 이웃에게 신나게 말합니다.</p>

<p><a class="p_ident" id="p_Vf87ZzInCt" href="#p_Vf87ZzInCt" tabindex="-1" role="presentation"></a>이것은 물의 잉크 얼룩처럼 네트워크를 통해 새로운 가십 조각을 퍼뜨릴 것입니다. 일부 연결이 현재 작동하지 않는 경우에도 지정된 둥지에 대한 대체 경로가 있으면 그곳을 통해 가십이 도달합니다.</p>

<p><a class="p_ident" id="p_vuq8D4aVHG" href="#p_vuq8D4aVHG" tabindex="-1" role="presentation"></a>이러한 유형의 네트워크 통신을 <em>flooding</em>이라고 합니다. 모든 노드가 정보를 가질 때까지 정보를 네트워크에 플러딩 합니다.</p>

<p><a class="p_ident" id="p_uA2Fs2G7PW" href="#p_uA2Fs2G7PW" tabindex="-1" role="presentation"></a>메시지 흐름을 보기 위해 <code>sendGossip</code>을 호출합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KWBmLZ/aO7" href="#c_KWBmLZ/aO7" tabindex="-1" role="presentation"></a><span class="cm-variable">sendGossip</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Kids with airgun in the park&quot;</span>);</pre>

<h2><a class="h_ident" id="h_qb23G8H5P9" href="#h_qb23G8H5P9" tabindex="-1" role="presentation"></a>Message routing</h2>

<p><a class="p_ident" id="p_DfGu9P/nDx" href="#p_DfGu9P/nDx" tabindex="-1" role="presentation"></a>주어진 노드가 다른 단일 노드와 통신하기를 원할 경우 플러딩은 그다지 효율적인 접근 방식이 아닙니다. 특히 네트워크가 큰 경우 쓸모없는 데이터 전송이 많이 발생합니다.</p>

<p><a class="p_ident" id="p_+/v2WfaNg2" href="#p_+/v2WfaNg2" tabindex="-1" role="presentation"></a>다른 접근 방식은 메시지가 목적지에 도달할 때까지 노드에서 노드로 이동하는 방법을 설정하는 것입니다. 그것의 어려움은 네트워크의 레이아웃에 대한 지식이 필요하다는 것입니다. 멀리 떨어진 둥지 방향으로 요청을 보내려면 어느 이웃 둥지가 목적지에 더 가까워지는지를 알아야 합니다. 잘못된 방향으로 보내는 것은 별로 도움이 되지 않습니다.</p>

<p><a class="p_ident" id="p_H9F/PkVSom" href="#p_H9F/PkVSom" tabindex="-1" role="presentation"></a>각 둥지는 직접 이웃에 대해서만 알고 있기 때문에 경로를 계산하는 데 필요한 정보가 없습니다. 우리는 어떻게든 이러한 연결에 대한 정보를 모든 둥지에, 바람직하게는 둥지가 버려지거나 새 둥지를 지을 때 시간이 지남에 따라 변경될 수 있는 방식으로 전파해야 합니다.</p>

<p><a class="p_ident" id="p_NNmqy7WOzL" href="#p_NNmqy7WOzL" tabindex="-1" role="presentation"></a>플러딩을 다시 사용할 수 있지만 주어진 메시지가 이미 수신되었는지 확인하는 대신 이제 주어진 네스트에 대한 새로운 이웃 세트가 현재 가지고 있는 세트와 일치하는지 확인합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_pOL6/oUmtj" href="#c_pOL6/oUmtj" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;connections&quot;</span>, (<span class="cm-variable">nest</span>, {<span class="cm-property">name</span>, <span class="cm-property">neighbors</span>},
                            <span class="cm-variable">source</span>) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">let</span> <span class="cm-def">connections</span> <span class="cm-operator">=</span> <span class="cm-variable">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable">name</span>)) <span class="cm-operator">==</span>
      <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-variable">neighbors</span>)) <span class="cm-keyword">return</span>;
  <span class="cm-variable-2">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable">name</span>, <span class="cm-variable">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable">nest</span>, <span class="cm-variable">name</span>, <span class="cm-variable">source</span>);
});

<span class="cm-keyword">function</span> <span class="cm-def">broadcastConnections</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>, <span class="cm-def">exceptFor</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">neighbor</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">neighbor</span> <span class="cm-operator">==</span> <span class="cm-variable-2">exceptFor</span>) <span class="cm-keyword">continue</span>;
    <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">neighbor</span>, <span class="cm-string">&quot;connections&quot;</span>, {
      <span class="cm-property">name</span>,
      <span class="cm-property">neighbors</span>: <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">name</span>)
    });
  }
}

<span class="cm-variable">everywhere</span>(<span class="cm-def">nest</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Map</span>();
  <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">set</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>);
  <span class="cm-variable">broadcastConnections</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
});</pre>

<p><a class="p_ident" id="p_Dpash2ByBo" href="#p_Dpash2ByBo" tabindex="-1" role="presentation"></a>비교는 객체 또는 배열에 대해 <code>==</code>가 두 값이 정확히 동일한 경우에만 true를 반환하기 때문에 <code>JSON.stringify</code>를 사용합니다. 여기서는 필요하지 않습니다. JSON 문자열을 비교하는 것은 내용을 비교하는 조잡하지만 효과적인 방법입니다.</p>

<p><a class="p_ident" id="p_qfljgqkp+v" href="#p_qfljgqkp+v" tabindex="-1" role="presentation"></a>노드는 즉시 연결 브로드캐스팅을 시작하며, 일부 네스트에 완전히 도달할 수 없는 경우를 제외하고 모든 네스트에 현재 네트워크 그래프의 맵을 신속하게 제공해야 합니다.</p>

<p><a class="p_ident" id="p_hDQVurU6rz" href="#p_hDQVurU6rz" tabindex="-1" role="presentation"></a>그래프로 할 수 있는 일은 7장 에서 보았듯이 그래프에서 경로를 찾는 것 입니다. 메시지 목적지를 향한 경로가 있으면 메시지를 보낼 방향을 알고 있습니다.</p>

<p><a class="p_ident" id="p_nLh7irC9fa" href="#p_nLh7irC9fa" tabindex="-1" role="presentation"></a><code>findRoute</code>와 매우 유사한 이 함수는 네트워크에서 주어진 노드에 도달하는 방법을 검색합니다. 그러나 전체 경로를 반환하는 대신 다음 단계만 반환합니다. 다음 내부 프로그램은 네트워크에 대한 현재 정보를 사용하여 메시지를 보낼 위치를 스스로 결정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_BDriUx0MeG" href="#c_BDriUx0MeG" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">findRoute</span>(<span class="cm-def">from</span>, <span class="cm-def">to</span>, <span class="cm-def">connections</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">work</span> <span class="cm-operator">=</span> [{<span class="cm-property">at</span>: <span class="cm-variable-2">from</span>, <span class="cm-property">via</span>: <span class="cm-atom">null</span>}];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">work</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> {<span class="cm-def">at</span>, <span class="cm-def">via</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">work</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">next</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">connections</span>.<span class="cm-property">get</span>(<span class="cm-variable-2">at</span>) <span class="cm-operator">|</span><span class="cm-operator">|</span> []) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">next</span> <span class="cm-operator">==</span> <span class="cm-variable-2">to</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">via</span>;
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">work</span>.<span class="cm-property">some</span>(<span class="cm-def">w</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">w</span>.<span class="cm-property">at</span> <span class="cm-operator">==</span> <span class="cm-variable-2">next</span>)) {
        <span class="cm-variable-2">work</span>.<span class="cm-property">push</span>({<span class="cm-property">at</span>: <span class="cm-variable-2">next</span>, <span class="cm-property">via</span>: <span class="cm-variable-2">via</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable-2">next</span>});
      }
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
}</pre>

<p><a class="p_ident" id="p_khShpBYpjP" href="#p_khShpBYpjP" tabindex="-1" role="presentation"></a>이제 장거리 메시지를 보낼 수 있는 함수를 만들 수 있습니다. 메시지가 직접 이웃에게 전달되는 경우 평소와 같이 전달됩니다. 그렇지 않은 경우 객체에 패키징되어 <code>&quot;route&quot;</code> 요청 타입을 사용하여 대상에 더 가까운 이웃으로 전송되어 해당 이웃이 동일한 동작을 반복하도록 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qgwq/4PpOq" href="#c_qgwq/4PpOq" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">routeRequest</span>(<span class="cm-def">nest</span>, <span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">nest</span>.<span class="cm-property">neighbors</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">target</span>)) {
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">via</span> <span class="cm-operator">=</span> <span class="cm-variable">findRoute</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>, <span class="cm-variable-2">target</span>,
                        <span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>);
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">via</span>) <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string-2">`No route to ${</span><span class="cm-variable-2">target</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable">request</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">via</span>, <span class="cm-string">&quot;route&quot;</span>,
                   {<span class="cm-property">target</span>, <span class="cm-property">type</span>, <span class="cm-property">content</span>});
  }
}

<span class="cm-variable">requestType</span>(<span class="cm-string">&quot;route&quot;</span>, (<span class="cm-def">nest</span>, {<span class="cm-def">target</span>, <span class="cm-def">type</span>, <span class="cm-def">content</span>}) <span class="cm-operator">=&gt;</span> {
  <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">target</span>, <span class="cm-variable-2">type</span>, <span class="cm-variable-2">content</span>);
});</pre>

<p><a class="p_ident" id="p_2KFj5q8DUa" href="#p_2KFj5q8DUa" tabindex="-1" role="presentation"></a>이제 네 개의 네트워크 홉이 제거된 교회 탑의 둥지에 메시지를 보낼 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_S73i8jJBHA" href="#c_S73i8jJBHA" tabindex="-1" role="presentation"></a><span class="cm-variable">routeRequest</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;Church Tower&quot;</span>, <span class="cm-string">&quot;note&quot;</span>,
             <span class="cm-string">&quot;Incoming jackdaws!&quot;</span>);</pre>

<p><a class="p_ident" id="p_T0OvjpGy1d" href="#p_T0OvjpGy1d" tabindex="-1" role="presentation"></a>사용하기 편리하도록 기본 통신 시스템 위에 여러 계층의 기능을 구성했습니다. 이것은 실제 컴퓨터 네트워크가 작동하는 방식에 대한 단순화되었지만 좋은 모델입니다.</p>

<p><a class="p_ident" id="p_BCiG5DVrmR" href="#p_BCiG5DVrmR" tabindex="-1" role="presentation"></a>컴퓨터 네트워크의 특징은 신뢰할 수 없다는 것입니다. 네트워크 위에 구축된 추상화는 도움이 될 수 있지만 네트워크 장애를 추상화할 수는 없습니다. 따라서 네트워크 프로그래밍은 일반적으로 실패를 예상하고 처리하는 것과 관련이 있습니다.</p>

<h2><a class="h_ident" id="h_XvLsfAhtsE" href="#h_XvLsfAhtsE" tabindex="-1" role="presentation"></a>Async 함수들</h2>

<p><a class="p_ident" id="p_4FwmFfekYV" href="#p_4FwmFfekYV" tabindex="-1" role="presentation"></a>중요한 정보를 저장하기 위해 까마귀는 둥지 전체에 복제하는 것으로 알려져 있습니다. 그렇게 하면 매가 둥지를 파괴할 때 정보가 손실되지 않습니다.</p>

<p><a class="p_ident" id="p_QezI5I8rjm" href="#p_QezI5I8rjm" tabindex="-1" role="presentation"></a>자체 스토리지 전구에 없는 주어진 정보를 검색하기 위해 컴퓨터는 정보가 있는 둥지를 찾을 때까지 네트워크의 다른 둥지를 무작위로 참조할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_QLKv1tpg1i" href="#c_QLKv1tpg1i" tabindex="-1" role="presentation"></a><span class="cm-variable">requestType</span>(<span class="cm-string">&quot;storage&quot;</span>, (<span class="cm-def">nest</span>, <span class="cm-def">name</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>));

<span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>).<span class="cm-property">then</span>(<span class="cm-def">found</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">findInRemoteStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  });
}

<span class="cm-keyword">function</span> <span class="cm-def">network</span>(<span class="cm-def">nest</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Array</span>.<span class="cm-property">from</span>(<span class="cm-variable-2">nest</span>.<span class="cm-property">state</span>.<span class="cm-property">connections</span>.<span class="cm-property">keys</span>());
}

<span class="cm-keyword">function</span> <span class="cm-def">findInRemoteStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">next</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>));
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                      <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
      <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
      <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>)
        .<span class="cm-property">then</span>(<span class="cm-def">value</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">value</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">?</span> <span class="cm-variable-2">value</span> : <span class="cm-variable-2">next</span>(),
              <span class="cm-variable-2">next</span>);
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">next</span>();
}</pre>

<p><a class="p_ident" id="p_9ueI22bqmz" href="#p_9ueI22bqmz" tabindex="-1" role="presentation"></a><code>connections</code>이 <code>Map</code>이기 때문에, <code>Object.keys</code>는 작동하지 않습니다. <code>keys</code> <em>메서드</em>를 갖지만, 배열이 아닌 순회자를 반환합니다. 순회자는 <code>Array.from</code> 함수를 통해 배열로 전환될 수 있습니다.</p>

<p><a class="p_ident" id="p_1yDETF9zmK" href="#p_1yDETF9zmK" tabindex="-1" role="presentation"></a>약속이 있더라도 이것은 다소 어색한 코드입니다. 여러 비동기 작업이 명확하지 않은 방식으로 함께 연결됩니다. 중첩을 통한 반복을 모델링하려면 재귀 함수(<code>next</code>)가 다시 필요합니다.</p>

<p><a class="p_ident" id="p_ZdDrrtYpkB" href="#p_ZdDrrtYpkB" tabindex="-1" role="presentation"></a>코드가 실제로 하는 일은 완전히 선형적입니다. 즉, 다음 작업을 시작하기 전에 항상 이전 작업이 완료되기를 기다립니다. 동기식 프로그래밍 모델에서는 표현하기가 더 간단합니다.</p>

<p><a class="p_ident" id="p_YB91K5v8Ro" href="#p_YB91K5v8Ro" tabindex="-1" role="presentation"></a>좋은 소식은 JavaScript를 사용하면 의사 동기 코드를 작성하여 비동기 계산을 설명할 수 있다는 것입니다. <code>async</code> 함수는 암시적으로 몸체에 동기식으로 기타 promises을 대기하도록 하는 함수입니다.</p>

<p><a class="p_ident" id="p_+aWABbtzTM" href="#p_+aWABbtzTM" tabindex="-1" role="presentation"></a>다음과 같이 <code>findInStorage</code>를 다시 작성할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eDKVOF1oo/" href="#c_eDKVOF1oo/" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">findInStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">local</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">local</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">local</span>;

  <span class="cm-keyword">let</span> <span class="cm-def">sources</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">sources</span>.<span class="cm-property">length</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">source</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>[<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span>
                                    <span class="cm-variable-2">sources</span>.<span class="cm-property">length</span>)];
    <span class="cm-variable-2">sources</span> <span class="cm-operator">=</span> <span class="cm-variable-2">sources</span>.<span class="cm-property">filter</span>(<span class="cm-def">n</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">n</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">source</span>);
    <span class="cm-keyword">try</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">found</span> <span class="cm-operator">=</span> <span class="cm-keyword">await</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>,
                                     <span class="cm-variable-2">name</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">found</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">found</span>;
    } <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {}
  }
  <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Not found&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_yJ9vEuqhm9" href="#p_yJ9vEuqhm9" tabindex="-1" role="presentation"></a><code>async</code> 단어를 <code>function</code> 키워드에 붙입니다. 메서드들은 메서드 이름 앞에 <code>async</code>라는 단어를 비동기 메서드로 만들 수 있습니다. 이러한 함수나 메서드가 호출되면 약속을 반환합니다. 본문이 무언가를 반환하자마자 그 약속은 해결됩니다. 예외가 발생하면 약속이 거부됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_04MPwtOsw6" href="#c_04MPwtOsw6" tabindex="-1" role="presentation"></a><span class="cm-variable">findInStorage</span>(<span class="cm-variable">bigOak</span>, <span class="cm-string">&quot;events on 2017-12-21&quot;</span>)
  .<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p><a class="p_ident" id="p_0PWuoWXaWE" href="#p_0PWuoWXaWE" tabindex="-1" role="presentation"></a><code>async</code> 함수 내에 <code>await</code>라는 단어 사용은 약속이 해결될 때까지 기다렸다가 함수 실행을 계속할 수 있도록 합니다.</p>

<p><a class="p_ident" id="p_hTH03GxRLH" href="#p_hTH03GxRLH" tabindex="-1" role="presentation"></a>이러한 함수는 더 이상 일반 JavaScript 함수와 달리 처음부터 끝까지 한 번에 실행되지 않습니다. 대신, <code>await</code>가 있는 모든 지점에서 고정될 수 있으며 나중에 다시 시작할 수 있습니다.</p>

<p><a class="p_ident" id="p_6JNP8vemlA" href="#p_6JNP8vemlA" tabindex="-1" role="presentation"></a>중요한 비동기 코드의 경우 이 표기법은 일반적으로 직접 약속을 사용하는 것보다 더 편리합니다. 동시에 여러 작업을 수행하는 등 동기식 모델에 맞지 않는 작업을 수행해야 하는 경우에도 Promise를 직접 사용하여 <code>await</code>와 결합하기 쉽습니다.</p>

<h2><a class="h_ident" id="h_o+cFzGGhnz" href="#h_o+cFzGGhnz" tabindex="-1" role="presentation"></a>Generators</h2>

<p><a class="p_ident" id="p_zFhfm+tYq8" href="#p_zFhfm+tYq8" tabindex="-1" role="presentation"></a>일시 중지되었다가 다시 재개되는 이러한 기능은 <code>async</code> 함수에만 국한되지 않습니다. JavaScript에는 <em>generator</em>라는 함수도 있습니다. 이것들은 비슷하지만 약속이 없습니다.</p>

<p><a class="p_ident" id="p_+0474o2QAY" href="#p_+0474o2QAY" tabindex="-1" role="presentation"></a><code>function*</code>를 사용하여 함수를 정의하면(<code>function</code> 다음에 *표를 사용) generator가 됩니다. generator를 호출하면 순회자가 반환됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4ek89g871" href="#c_B4ek89g871" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span><span class="cm-keyword">*</span> <span class="cm-def">powers</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;; <span class="cm-variable-2">current</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">n</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-variable-2">current</span>;
  }
}

<span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">power</span> <span class="cm-keyword">of</span> <span class="cm-variable">powers</span>(<span class="cm-number">3</span>)) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">power</span> <span class="cm-operator">&gt;</span> <span class="cm-number">50</span>) <span class="cm-keyword">break</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>);
}
<span class="cm-comment">// → 3</span>
<span class="cm-comment">// → 9</span>
<span class="cm-comment">// → 27</span></pre>

<p><a class="p_ident" id="p_66VAHXEtbn" href="#p_66VAHXEtbn" tabindex="-1" role="presentation"></a>처음에 <code>powers</code>를 호출하면 함수가 시작될 때 고정됩니다. 순회자 상에서 <code>next</code>를 호출할 때마다 함수는 <code>yield</code> 표현식에 도달할 때까지 실행 되어 일시 중지되고 산출된 값이 반복자가 생성한 다음 값이 되도록 합니다. 함수가 반환되면(예는 반환하지 않는 경우) 순회자가 완료됩니다.</p>

<p><a class="p_ident" id="p_ck21A7VgZt" href="#p_ck21A7VgZt" tabindex="-1" role="presentation"></a>generator 함수를 사용하면 순회자 작성이 훨신 용이해집니다. <code>Group</code> 클래스에 관한 순회자는 (<a href="06_object.html#group_iterator">6장</a> 연습문제) 이러한 generator를 사용하여 작성될 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_C6OZWjI9EM" href="#c_C6OZWjI9EM" tabindex="-1" role="presentation"></a><span class="cm-variable">Group</span>.<span class="cm-property">prototype</span>[<span class="cm-variable">Symbol</span>.<span class="cm-property">iterator</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span><span class="cm-keyword">*</span>() {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">yield</span> <span class="cm-keyword">this</span>.<span class="cm-property">members</span>[<span class="cm-variable-2">i</span>];
  }
};</pre>

<p><a class="p_ident" id="p_oMZiyktu3O" href="#p_oMZiyktu3O" tabindex="-1" role="presentation"></a>더 이상 순회 상태를 유지하기 위해 객체를 생성할 필요가 없습니다. generator는 생성할 때마다 자동으로 로컬 상태를 저장합니다.</p>

<p><a class="p_ident" id="p_YCNJmBl4aF" href="#p_YCNJmBl4aF" tabindex="-1" role="presentation"></a>이러한 <code>yield</code> 식은 generator 함수 자체에서만 직접 발생할 수 있으며 내부에 정의한 내부 함수에서는 발생할 수 없습니다. generator가 양보할 때 저장하는 상태는 지역 환경과 양보한 위치 뿐입니다.</p>

<p><a class="p_ident" id="p_TnoowE9/OQ" href="#p_TnoowE9/OQ" tabindex="-1" role="presentation"></a><code>async</code> 함수는 generator의 특별한 유형입니다. 호출될 때 약속을 생성하고 반환(완료)될 때 해결되고 예외가 발생하면 거부됩니다. 프라미스를 산출(기다림)할 때마다 해당 프라미스의 결과(값 또는 던져진 예외)는 await 표현식의 결과입니다.</p>

<h2><a class="h_ident" id="h_GXDb0+eMId" href="#h_GXDb0+eMId" tabindex="-1" role="presentation"></a>이벤트 루프</h2>

<p><a class="p_ident" id="p_AfROx8LXEr" href="#p_AfROx8LXEr" tabindex="-1" role="presentation"></a>비동기 프로그램은 하나씩 실행됩니다. 각 부분은 일부 작업을 시작하고 작업이 완료되거나 실패할 때 실행할 코드를 예약할 수 있습니다. 이 부분들 사이에서 프로그램은 다음 동작을 기다리며 유휴 상태로 있습니다.</p>

<p><a class="p_ident" id="p_WG0CglTDJj" href="#p_WG0CglTDJj" tabindex="-1" role="presentation"></a>따라서 콜백은 그것을 예약한 코드에서 직접 호출되지 않습니다. <code>setTimeout</code>을 함수 내에서 호출하면 해당 함수는 콜백 함수가 호출될 때 반환됩니다. 그리고 콜백이 반환되면 제어는 이를 예약한 함수로 돌아가지 않습니다.</p>

<p><a class="p_ident" id="p_jb72lBvUWs" href="#p_jb72lBvUWs" tabindex="-1" role="presentation"></a>비동기 동작은 자체 빈 함수 호출 스택에서 발생합니다. 이것이 약속 없이 비동기 코드에서 예외를 관리하는 것이 어려운 이유 중 하나입니다. 각 콜백은 대부분 비어 있는 스택으로 시작하기 때문에 <code>catch</code> 처리기는 예외를던질 때 스택에 있지 않습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_UswfjtMHu4" href="#c_UswfjtMHu4" tabindex="-1" role="presentation"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">&quot;Woosh&quot;</span>);
  }, <span class="cm-number">20</span>);
} <span class="cm-keyword">catch</span> (<span class="cm-def">_</span>) {
  <span class="cm-comment">// This will not run</span>
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Caught!&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_SHy5RpBOP1" href="#p_SHy5RpBOP1" tabindex="-1" role="presentation"></a>시간 초과 또는 수신 요청과 같은 이벤트가 얼마나 밀접하게 발생하더라도 JavaScript 환경은 한 번에 하나의 프로그램만 실행합니다. 이벤트 루프라고 하는 프로그램 주위에서 큰 루프를 실행하는 것으로 생각할 수 있습니다. 수행할 작업이 없으면 해당 루프가 중지됩니다. 그러나 이벤트가 들어오면 대기열에 추가되고 해당 코드가 차례로 실행됩니다. 동시에 두 가지가 실행되지 않기 때문에 느리게 실행되는 코드는 다른 이벤트 처리를 지연시킬 수 있습니다.</p>

<p><a class="p_ident" id="p_o5sS+xwBLP" href="#p_o5sS+xwBLP" tabindex="-1" role="presentation"></a>다음 예는 시간 초과를 설정한 다음 시간 초과의 의도된 시점 이후까지 달리게 하여 시간 초과를 늦춥니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Xozg9CCvVZ" href="#c_Xozg9CCvVZ" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">start</span> <span class="cm-operator">=</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>();
<span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Timeout ran at&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
}, <span class="cm-number">20</span>);
<span class="cm-keyword">while</span> (<span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">&lt;</span> <span class="cm-variable">start</span> <span class="cm-operator">+</span> <span class="cm-number">50</span>) {}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Wasted time until&quot;</span>, <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-variable">start</span>);
<span class="cm-comment">// → Wasted time until 50</span>
<span class="cm-comment">// → Timeout ran at 55</span></pre>

<p><a class="p_ident" id="p_OZm6Yhq/Wa" href="#p_OZm6Yhq/Wa" tabindex="-1" role="presentation"></a>Promises는 항상 새로운 이벤트로 해결되거나 거부됩니다. 프라미스가 이미 해결된 경우에도 이를 기다리면 즉시가 아니라 현재 스크립트가 완료된 후 콜백이 실행됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_B4TYo0a2ol" href="#c_B4TYo0a2ol" tabindex="-1" role="presentation"></a><span class="cm-variable">Promise</span>.<span class="cm-property">resolve</span>(<span class="cm-string">&quot;Done&quot;</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Me first!&quot;</span>);
<span class="cm-comment">// → Me first!</span>
<span class="cm-comment">// → Done</span></pre>

<p><a class="p_ident" id="p_/AFx3XpMr1" href="#p_/AFx3XpMr1" tabindex="-1" role="presentation"></a>이후 장에서 이벤트 루프에서 실행되는 다양한 다른 타입의 이벤트를 살펴 볼 것입니다.</p>

<h2><a class="h_ident" id="h_FcctcOqtcF" href="#h_FcctcOqtcF" tabindex="-1" role="presentation"></a>비동기 버그</h2>

<p><a class="p_ident" id="p_7G3I/OEwrS" href="#p_7G3I/OEwrS" tabindex="-1" role="presentation"></a>프로그램이 동기적으로 실행될 때 한 번에 프로그램 자체가 만드는 것 외에는 상태 변경이 발생하지 않습니다. 비동기 프로그램의 경우 다른 코드가 실행될 수 있는 실행 간격이 있을 수 있습니다.</p>

<p><a class="p_ident" id="p_IHtlm+p6vM" href="#p_IHtlm+p6vM" tabindex="-1" role="presentation"></a>예를 들어, 까마귀의 취미 중 하나는 매년 마을 전체에서 부화하는 병아리의 수를 세는 것이라 하면, 둥지는 이 개수를 저장 전구에 저장합니다. 다음 코드는 주어진 연도의 모든 중첩에서 카운트를 열거하려고 시도합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_IMqeevTorV" href="#c_IMqeevTorV" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">anyStorage</span>(<span class="cm-def">nest</span>, <span class="cm-def">source</span>, <span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">source</span> <span class="cm-operator">==</span> <span class="cm-variable-2">nest</span>.<span class="cm-property">name</span>) <span class="cm-keyword">return</span> <span class="cm-variable">storage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable">routeRequest</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">source</span>, <span class="cm-string">&quot;storage&quot;</span>, <span class="cm-variable-2">name</span>);
}

<span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">list</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;&quot;</span>;
  <span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable-2">list</span> <span class="cm-operator">+=</span> <span class="cm-string-2">`${</span><span class="cm-variable-2">name</span><span class="cm-string-2">}</span><span class="cm-string-2">: ${</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>)
    <span class="cm-string-2">}</span><span class="cm-string-2">\n`</span>;
  }));
  <span class="cm-keyword">return</span> <span class="cm-variable-2">list</span>;
}</pre>

<p><a class="p_ident" id="p_0pgRtcGBdP" href="#p_0pgRtcGBdP" tabindex="-1" role="presentation"></a><code>async name =&gt;</code> 부분은 화살표 함수 또한 <code>async</code>로 만들 수 있음을 나타냅니다.</p>

<p><a class="p_ident" id="p_KHzN+dp1hs" href="#p_KHzN+dp1hs" tabindex="-1" role="presentation"></a>코드는 즉시 의심스러워 보이지 않습니다. <code>async</code> 화살표 함수를 내부 집합에 매핑하여 promise 배열을 만든 다음 <code>Promise.all</code>를 사용하여 구성한 리스트를 반환하기 전에 이 모든 항목을 기다립니다.</p>

<p><a class="p_ident" id="p_TdSgPYi+yD" href="#p_TdSgPYi+yD" tabindex="-1" role="presentation"></a>하지만 응답이 가장 느린 둥지를 나열하여 항상 한 줄의 출력만 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_GWIpudJZ4o" href="#c_GWIpudJZ4o" tabindex="-1" role="presentation"></a><span class="cm-variable">chicks</span>(<span class="cm-variable">bigOak</span>, <span class="cm-number">2017</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);</pre>

<p><a class="p_ident" id="p_vdkIPINyQy" href="#p_vdkIPINyQy" tabindex="-1" role="presentation"></a>문제는 명령문이 실행을 시작하는 시점에서 <code>list</code>의 현재 값을 취하고 나서 <code>await</code>가 종료될 때 <code>list</code>를 해당 값에 추가 문자열을 결합하는 <code>+=</code> 연산자에 있습니다.</p>

<p><a class="p_ident" id="p_faVxxgg3dQ" href="#p_faVxxgg3dQ" tabindex="-1" role="presentation"></a>그러나 명령문이 실행을 시작하는 시간과 완료되는 시간 사이에는 비동기식 간격이 있습니다. <code>map</code> 식은 리스트에 무엇인가 추가되기 전에 실행을 시작합니다. 따라서 각 <code>+=</code> 연산자는 빈 문자열로 사작해서 스토로지 검색이 종료될 때 리스트를 단일 라인으로 설정하기 때문에 라인 추가 결과는 빈 문자열이 됩니다.</p>

<p><a class="p_ident" id="p_WrnTDweOkP" href="#p_WrnTDweOkP" tabindex="-1" role="presentation"></a>이것은 바인딩을 변경하여 리스트를 작성하는 대신 매핑된 약속에서 행을 반환하고 <code>Promise.all</code>의 결과 상에서 <code>join</code>을 호출하여 쉽게 피할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gkD231Soao" href="#c_gkD231Soao" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">chicks</span>(<span class="cm-def">nest</span>, <span class="cm-def">year</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">lines</span> <span class="cm-operator">=</span> <span class="cm-variable">network</span>(<span class="cm-variable-2">nest</span>).<span class="cm-property">map</span>(<span class="cm-keyword">async</span> <span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">name</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;: &quot;</span> <span class="cm-operator">+</span>
      <span class="cm-keyword">await</span> <span class="cm-variable">anyStorage</span>(<span class="cm-variable-2">nest</span>, <span class="cm-variable-2">name</span>, <span class="cm-string-2">`chicks in ${</span><span class="cm-variable-2">year</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span>);
  });
  <span class="cm-keyword">return</span> (<span class="cm-keyword">await</span> <span class="cm-variable">Promise</span>.<span class="cm-property">all</span>(<span class="cm-variable-2">lines</span>)).<span class="cm-property">join</span>(<span class="cm-string">&quot;\n&quot;</span>);
}</pre>

<p><a class="p_ident" id="p_7XYZHth7ax" href="#p_7XYZHth7ax" tabindex="-1" role="presentation"></a>이와 같은 실수는 특히 <code>await</code>를 사용할 때 쉽게 저지를 수 있으며 코드에서 공백이 발생하는 위치를 알고 있어야 합니다. JavaScript의 명시적 비동기성(callbacks, promises 또는 <code>await</code>를 통한)의 장점은 이러한 갭을 찾는 것이 비교적 쉽다는 것입니다.</p>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_MoVe59fjo8" href="#p_MoVe59fjo8" tabindex="-1" role="presentation"></a>비동기 프로그래밍을 사용하면 작업 중에 프로그램을 정지하지 않고 장기 실행 작업을 기다릴 수 있습니다. JavaScript 환경은 일반적으로 작업이 완료될 때 호출되는 함수인 콜백을 사용하여 이러한 스타일의 프로그래밍을 구현합니다. 이벤트 루프는 실행이 겹치지 않도록 해당 콜백이 차례로 호출되도록 예약합니다.</p>

<p><a class="p_ident" id="p_8QVLsE1w4k" href="#p_8QVLsE1w4k" tabindex="-1" role="presentation"></a>비동기식 프로그래밍은 promises, 미래에 완료될 수 있는 작업을 나타내는 객체 및 <code>async</code>를 통해 마치 동기식인 것처럼 작성할 수 있습니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_UvyahfUnfl" href="#i_UvyahfUnfl" tabindex="-1" role="presentation"></a>scalpel 추적</h3>

<p><a class="p_ident" id="p_x4s0mGpqFW" href="#p_x4s0mGpqFW" tabindex="-1" role="presentation"></a>까마귀 마을은 특수 임무, 예를 들어 스크린 도어나 포장을 자르는데 가끔 사용하는 오래된 메스를 소유하고 있습니다. 신속하게 추적할 수 있도록 메스가 다른 둥지로 이동할 때마다 메스를 가지고 있던 둥지와 가져간 둥지 모두의 저장소에 항목이 <code>&quot;scalpel&quot;</code>이라는 이름으로 추가되고 새 위치는 값을 가집니다.</p>

<p><a class="p_ident" id="p_X85b03YAMx" href="#p_X85b03YAMx" tabindex="-1" role="presentation"></a>이것은 메스를 찾는 것이 둥지 자체를 가리키는 둥지를 찾을 때까지 스토리지 항목의 이동 경로를 따라가는 문제임을 의미합니다.</p>

<p><a class="p_ident" id="p_pGzF+NquWH" href="#p_pGzF+NquWH" tabindex="-1" role="presentation"></a>그것을 실행하는 둥지에서 시작해서 이러한 작업을 행하는 <code>async</code> 함수 <code>locateScalpel</code>을 작성합니다. 앞에 정의한 함수 <code>anyStorage</code>를 사용하여 임의의 둥지에 있는 저장소에 액세스 할 수 있습니다. scalpel은 모든 둥지의 데이터 저장소에 항목 <code>&quot;scalpel&quot;</code>이 있다고 가정할 수 있을 만큼 충분합니다.</p>

<p><a class="p_ident" id="p_kCIUGPuKAV" href="#p_kCIUGPuKAV" tabindex="-1" role="presentation"></a>그런 다음 <code>async</code> 및 <code>await</code>를 사용하지 않고 동일한 함수를 다시 작성합니다.</p>

<p><a class="p_ident" id="p_rIlnOS1Bz0" href="#p_rIlnOS1Bz0" tabindex="-1" role="presentation"></a>요청 실패가 두 버전 모두에서 반환된 약속의 거부로 올바르게 표시되는지 확인합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_YnFVXk9tRo" href="#c_YnFVXk9tRo" tabindex="-1" role="presentation"></a><span class="cm-keyword">async</span> <span class="cm-keyword">function</span> <span class="cm-def">locateScalpel</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// 여기에 코드 작성</span>
}

<span class="cm-keyword">function</span> <span class="cm-def">locateScalpel2</span>(<span class="cm-def">nest</span>) {
  <span class="cm-comment">// 여기에 코드 작성</span>
}

<span class="cm-variable">locateScalpel</span>(<span class="cm-variable">bigOak</span>).<span class="cm-property">then</span>(<span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → Butcher Shop</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_HBYJhQLRh0" href="#p_HBYJhQLRh0" tabindex="-1" role="presentation"></a>이것은 둥지를 검색하는 단일 루프로 수행할 수 있으며, 현재 둥지의 이름과 일치하지 않는 값을 찾으면 다음으로 이동하고 일치하는 값을 찾으면 이름을 반환합니다. <code>async</code> 함수에서 정규 <code>for</code> 또는 <code>while</code> 루프가 사용될 수 있습니다.</p>

<p><a class="p_ident" id="p_dvm1OVOM4s" href="#p_dvm1OVOM4s" tabindex="-1" role="presentation"></a>일반 함수에서 동일한 작업을 수행하려면 재귀 함수를 사용하여 루프를 빌드해야 합니다. 이를 수행하는 가장 쉬운 방법은 저장 값을 검색하는 프라미스상에서 <code>then</code>을 호출하여 해당 함수가 프라미스를 반환하도록 하는 것 입니다. 해당 값이 현재 중첩의 이름과 일치하는지 여부에 따라 핸들러는 해당 값 또는 루프 함수를 다시 호출하여 생성된 추가 프라미스를 반환합니다.</p>

<p><a class="p_ident" id="p_4zv80GXYD/" href="#p_4zv80GXYD/" tabindex="-1" role="presentation"></a>주 함수에서 재귀 함수를 한 번 호출하여 루프를 시작하는 것을 잊지 마십시오.</p>

<p><a class="p_ident" id="p_h9Yrbo5Eju" href="#p_h9Yrbo5Eju" tabindex="-1" role="presentation"></a><code>async</code> 함수에서 거절된 약속은 <code>await</code>에 의해 예외로 전환됩니다. <code>async</code> 함수가 예외를 던질 때, 약속은 기각됩니다.</p>

<p><a class="p_ident" id="p_GEDOzip0j2" href="#p_GEDOzip0j2" tabindex="-1" role="presentation"></a><code>async</code>가 아닌 함수로 수행되면, <code>then</code> 작업 방식은 반환된 약속이 실패로 끝나도록 합니다. 요청이 실패하면 <code>then</code>에 전달된 처리기가 호출되지 않고 반환되는 약속도 같은 이유로 거부됩니다.</p>

</div></div>

<h3><a class="i_ident" id="i_Ug+Dv9Mmsw" href="#i_Ug+Dv9Mmsw" tabindex="-1" role="presentation"></a>Promise.all 구축</h3>

<p><a class="p_ident" id="p_V49Fgs6t/I" href="#p_V49Fgs6t/I" tabindex="-1" role="presentation"></a>프라미스 배열이 주어지면 <code>Promise.all</code>은 배열의 모든 프라미스가 완료될 때까지 기다리는 프라미스를 반환합니다. 그런 다음 성공하여 결과 값 배열을 생성합니다. 배열의 프라미스가 실패하면 <code>all</code>에 의해 반환되는 프라미스도 실패하고 실패한 프라미스의 실패 이유도 함께 실패됩니다.</p>

<p><a class="p_ident" id="p_D4i3Qt21e7" href="#p_D4i3Qt21e7" tabindex="-1" role="presentation"></a><code>Promise_all</code>라는 일반 함수로 이와 같은 것을 직접 구현하십시오.</p>

<p><a class="p_ident" id="p_pUBmweFzla" href="#p_pUBmweFzla" tabindex="-1" role="presentation"></a>약속이 성공하거나 실패한 후에는 다시 성공하거나 실패할 수 없으며 이를 해결하는 함수에 대한 추가 호출은 무시됩니다. 이것은 약속의 실패를 처리하는 방법을 단순화할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_70Eq9i3rpH" href="#c_70Eq9i3rpH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">Promise_all</span>(<span class="cm-def">promises</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>((<span class="cm-def">resolve</span>, <span class="cm-def">reject</span>) <span class="cm-operator">=&gt;</span> {
    <span class="cm-comment">// Your code here.</span>
  });
}

<span class="cm-comment">// Test code.</span>
<span class="cm-variable">Promise_all</span>([]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be []:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-def">soon</span>(<span class="cm-def">val</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-def">resolve</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">setTimeout</span>(() <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">resolve</span>(<span class="cm-variable-2">val</span>), <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">500</span>);
  });
}
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">soon</span>(<span class="cm-number">2</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;This should be [1, 2, 3]:&quot;</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-variable">Promise_all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">Promise</span>.<span class="cm-property">reject</span>(<span class="cm-string">&quot;X&quot;</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)])
  .<span class="cm-property">then</span>(<span class="cm-def">array</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;We should not get here&quot;</span>);
  })
  .<span class="cm-property">catch</span>(<span class="cm-def">error</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;X&quot;</span>) {
      <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Unexpected failure:&quot;</span>, <span class="cm-variable-2">error</span>);
    }
  });</pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_zV4HNd52Ay" href="#p_zV4HNd52Ay" tabindex="-1" role="presentation"></a><code>Promise</code> 생성자에 전달된 함수는 주어진 배열의 각 약속 상에서 code>then</code>을 호출해야 합니다. 그 중 하나가 성공하면 두 가지 일이 발생해야 합니다. 결과 값은 결과 배열의 올바른 위치에 저장되어야 하며 이것이 마지막으로 보류 중인 약속인지 확인하고 그렇다면 우리 자신의 약속을 완료해야 합니다.</p>

<p><a class="p_ident" id="p_oMTLkDbIsp" href="#p_oMTLkDbIsp" tabindex="-1" role="presentation"></a>후자는 입력 배열의 길이로 초기화되고 약속이 성공할 때마다 1을 빼는 카운터로 수행할 수 있습니다. 0에 도달하면 완료됩니다. 입력 배열이 비어 있는 상황을 고려해야 합니다(따라서 약속이 해결되지 않음).</p>

<p><a class="p_ident" id="p_pVTKGiHusk" href="#p_pVTKGiHusk" tabindex="-1" role="presentation"></a>실패를 처리는 매우 간단합니다. 레핑 약속의 <code>reject</code> 함수를 <code>catch</code> 처리기로서 배열의 각 약속을 전달하거나 또는 두 번째 인수로 <code>then</code>을 그 중 하나에서 실패가 전체 래퍼 약속의 거부를 작동시킵니다.</p>

</div></div><nav><a href="10_modules.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="12_language.html" title="next chapter">▶</a></nav>
</article>