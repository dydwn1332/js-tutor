<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>데이터 구조: 객체와 배열</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 4;var sandboxLoadFiles = ["code/journal.js","code/chapter/04_data.js"];</script></head>

<article>
<nav><a href="03_functions.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="05_higher_order.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>4장</span>데이터 구조: 객체와 배열</h1>

<blockquote>

<p><a class="p_ident" id="p_3DGxnMhaad" href="#p_3DGxnMhaad" tabindex="-1" role="presentation"></a>우연히 두 번이나 저는 다음과 같은 질문을 받았습니다. '배비지 선생님, 기계에 잘못된 숫자를 입력하면 올바른 답이 나올까요?' [...] 나는 그러한 질문을 유발할 수 있는 개념의 혼란을 이해할 수가 없었습니다.</p>

<footer>Charles Babbage, <cite>철학자의 삶에서 나온 구절(1864)</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_4.jpg" alt="Picture of a weresquirrel"></figure>

<p><a class="p_ident" id="p_j/UjCN3npi" href="#p_j/UjCN3npi" tabindex="-1" role="presentation"></a>Numbers, Booleans 및 strings는 데이터 구조를 구성하는 원자입니다. 그러나 많은 유형의 정보에는 둘 이상의 원자가 필요합니다. <em>객체(Object)</em>들을 사용하면 다른 객체를 포함한 값을 그룹화하여 더 복잡한 구조를 만들 수 있습니다.</p>

<p><a class="p_ident" id="p_F4YgzUjHcT" href="#p_F4YgzUjHcT" tabindex="-1" role="presentation"></a>지금까지 만들어진 프로그램은 단순한 데이터 타입에서만 작동한다는 사실로 인해 제한을 받았습니다. 이 페이지에서는 기본 데이터 구조를 소개합니다. 이 과정이 끝나면 유용한 프로그램을 작성하기 시작할 만큼 충분히 알게 될 것입니다.</p>

<p><a class="p_ident" id="p_vL8agXHSiL" href="#p_vL8agXHSiL" tabindex="-1" role="presentation"></a>이 페이지에서는 필요한 문제에 적용되는 개념을 소개하면서 다소 현실적인 프로그래밍 예를 통해 작업합니다. 예 코드는 종종 함수와 바인딩을 바탕으로 소개될 것입니다.</p>

<h2><a class="h_ident" id="h_NvjtahQLlw" href="#h_NvjtahQLlw" tabindex="-1" role="presentation"></a>늑대 인간(Weresquirrel): 위협</h2>

<p><a class="p_ident" id="p_0aih0sjFrb" href="#p_0aih0sjFrb" tabindex="-1" role="presentation"></a>이따금, 보통 오후 8시에서 10시 사이에 Jacques는 덤불 같은 꼬리를 가진 작은 모피 설치류로 변신하는 자신을 발견합니다.</p>

<p><a class="p_ident" id="p_EIDMzKWaqr" href="#p_EIDMzKWaqr" tabindex="-1" role="presentation"></a>한편으로, Jacques는 그가 고전적인 라이칸스로피(자신이 동물로 변신되었다고 생각하는 특이한 망상)를 갖고 있지 않다는 것을 매우 기쁘게 생각합니다. 다람쥐로 변하는 것은 늑대로 변하는 것보다 문제가 덜 발생합니다. 실수로 이웃을 먹는 것에 대해 걱정할 필요가 없는 대신에 이웃의 고양이에게 먹히는 것에 대해 걱정합니다. 그는 두 번이나 참나무 면류관에 있는 위태롭게 가느다란 가지 위에서 벌거벗은 채 방향 감각을 잃은 채 깨어난 후, 밤에 자기 방의 문과 창문을 잠그고 위험을 감지하기 위해 바닥에 호두 몇 개를 깔았습니다.</p>

<p><a class="p_ident" id="p_ciZTylV1yl" href="#p_ciZTylV1yl" tabindex="-1" role="presentation"></a>그것은 고양이 문제를 해결합니다. 그렇지만 Jacques는 염려를 완전히 해결하기를 원합니다. 불규칙한 변형은 무엇인가에 의해 촉발된 것이라는 의심이 듭니다. 한동안은 그러한 일이 참나무 근처에 있었던 날에만 일어난다고 믿었습니다. 그런다고 그 나무를 피한다고 해서 문제가 종식되지는 않았습니다.</p>

<p><a class="p_ident" id="p_Xj6eprhXkS" href="#p_Xj6eprhXkS" tabindex="-1" role="presentation"></a>보다 과학적인 접근 방식으로 Jacques는 주어진 날에 하는 모든 일과 그가 변신했는지 여부를 매일 기록하기 시작했습니다. 그는 이러한 데이터를 통해 변환을 유발하는 조건을 좁힐 수 있기를 희망했습니다.</p>

<p><a class="p_ident" id="p_mcDf0Dxvcm" href="#p_mcDf0Dxvcm" tabindex="-1" role="presentation"></a>그에게 가장 먼저 필요한 것은 이 정보를 저장할 데이터 구조입니다.</p>

<h2><a class="h_ident" id="h_HjL/otjEJn" href="#h_HjL/otjEJn" tabindex="-1" role="presentation"></a>데이터 집합</h2>

<p><a class="p_ident" id="p_HFLfyQFSDp" href="#p_HFLfyQFSDp" tabindex="-1" role="presentation"></a>디지털 데이터 덩어리로 작업하려면 먼저 기계의 메모리에서 이를 표현할 방법을 찾아야 합니다. 예를 들어 숫자 2, 3, 5, 7, 11의 집합을 표현하고 싶다고 합시다.</p>

<p><a class="p_ident" id="p_cnzv4pg+Wz" href="#p_cnzv4pg+Wz" tabindex="-1" role="presentation"></a>문자열은 길이에 관계없이 사용할 수 있으므로 많은 데이터를 문자열에 넣을 수 있으며 이를 <code>&quot;2 3 5 7 11&quot;</code> 표현으로 사용할 수 있습니다. 그렇지만 어떻게 든 숫자를 추출하고 다시 숫자로 변환하여 접근할 필요가 있습니다.</p>

<p><a class="p_ident" id="p_/aFILq7bDn" href="#p_/aFILq7bDn" tabindex="-1" role="presentation"></a>JavaScript는 값 수열을 저장하기 위한 데이터 타입인 <em>array</em>을 제공합니다. 배열의 항목은 쉼표로 구분된 대괄호 사이에 값 리스트로 작성됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_05cIH1hy/D" href="#c_05cIH1hy/D" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">listOfNumbers</span> <span class="cm-operator">=</span> [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">7</span>, <span class="cm-number">11</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">2</span>]);
<span class="cm-comment">// → 5</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">0</span>]);
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]);
<span class="cm-comment">// → 3</span></pre>

<p><a class="p_ident" id="p_xu5bhsrvS2" href="#p_xu5bhsrvS2" tabindex="-1" role="presentation"></a>배열 내부의 요소를 가져오는 표기법도 대괄호를 사용합니다. 표현식 바로 뒤에 있는 한 쌍의 대괄호는 내부에 다른 표현식을 포함하고 있으며, 왼쪽 표현식에서 괄호 안의 표현식이 제공하는 <em>index</em>에 해당하는 요소를 찾습니다.</p>

<p id="array_indexing"><a class="p_ident" id="p_1+NmIJreij" href="#p_1+NmIJreij" tabindex="-1" role="presentation"></a>배열의 첫 번째 인덱스는 1이 아니라 0입니다. 따라서 첫 번째 요소는 <code>listOfNumbers[0]</code>로 검색됩니다. 인덱스를 배열의 시작 부분부터 계산하여 건너뛸 항목의 개수로 생각하십시오.</p>

<h2 id="properties"><a class="h_ident" id="h_vGyI2y8HA6" href="#h_vGyI2y8HA6" tabindex="-1" role="presentation"></a>속성(Properties)</h2>

<p><a class="p_ident" id="p_GC4++VF2pM" href="#p_GC4++VF2pM" tabindex="-1" role="presentation"></a>앞 페이지에서 문자열의 길이를 취하기 위해 <code>myString.length</code> 및 최댓값을 취하기 위해 <code>Math.max</code>와 같은 식을 사용했습니다. 이것은 일부 값의 <em>property</em>에 접근하는 식들입니다. 첫 번째 경우는 <code>myString</code>에서 값의 <code>length</code> 속성에 접근합니다. 두 번째는 <code>Math</code> 객체(수학 관련 상수 및 함수의 모음)에 <code>max</code>로 명명된 속성에 접근합니다.</p>

<p><a class="p_ident" id="p_dTOk+Nu/lR" href="#p_dTOk+Nu/lR" tabindex="-1" role="presentation"></a>거의 모든 JavaScript 값은 속성들을 가집니다. 예외는 <code>null</code> 및 <code>undefined</code>입니다. 이러한 값이 아닌 속성 중 하나에 접근하려고 하면 오류가 발생합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FNR95AymUx" href="#c_FNR95AymUx" tabindex="-1" role="presentation"></a><span class="cm-atom">null</span>.<span class="cm-property">length</span>;
<span class="cm-comment">// → TypeError: null has no properties</span></pre>

<p><a class="p_ident" id="p_wm1lZqKJ49" href="#p_wm1lZqKJ49" tabindex="-1" role="presentation"></a>JavaScript에서 속성에 접근하는 두 가지 주요 방식은 점과 대괄호를 사용하는 것입니다. <code>value.x</code>와 <code>value[x]</code>는 모두 <code>value</code>의 속성에 접근하지만, 반드시 동일한 속성은 아닙니다. <code>x</code>를 어떻게 해석 하느냐에 달려 있습니다. 대괄호를 사용할 때 괄호 사이의 식은 속성명을 취하기 위해 전개됩니다. 이에 반해 <code>value.x</code>는 "x"라는 이름의 속성을 가져옵니다. <code>value[x]</code>는 식 <code>x</code>을 평가하고 문자열로 변환된 결과를 속성 이름으로 사용합니다.</p>

<p><a class="p_ident" id="p_PeocsmCJ3P" href="#p_PeocsmCJ3P" tabindex="-1" role="presentation"></a>예를 들어, 관심 속성이 <em>color</em>인 경우에 <code>value.color</code>를 사용합니다. <code>i</code>로 결합되는 갓ㅂ에 의해 명명된 속성을 추출하고자 하면 <code>value[i]</code>와 같은 방식을 사용합니다. 속성 이름은 문자열입니다. 모든 문자열이 사용되지만, 점 표기법은 유효한 바인딩 이름처럼 보이는 이름에서만 작동합니다. 따라서 <em>2</em> 또는 <em>John Doe</em>라는 속성에 접근하려면 <code>value[2]</code> 또는 <code>value[&quot;John Doe&quot;]</code>를 사용해야 합니다.</p>

<p><a class="p_ident" id="p_v2+DwDjnmO" href="#p_v2+DwDjnmO" tabindex="-1" role="presentation"></a>배열의 요소는 숫자를 속성 이름으로 사용하여 배열의 속성으로 저장됩니다. 숫자와 함께 점 표기법을 사용할 수 없고 일반적으로 인덱스를 유지하는 바인딩을 사용하기를 원하기 때문에 대괄호 표기법을 사용해야 합니다.</p>

<p><a class="p_ident" id="p_Bcq+Q3kiI4" href="#p_Bcq+Q3kiI4" tabindex="-1" role="presentation"></a>배열의 <code>length</code> 속성은 배열에 몇 개의 요소가 있는지 알려줍니다. 이러한 속성명은 결합이 가능한 이름으로 미리 알고 있어야 합니다. 배열의 길이를 찾기 위해 <code>array.length</code>를 사용합니다(<code>array[&quot;length&quot;]</code>로 작성할 수도 있음).</p>

<h2 id="methods"><a class="h_ident" id="h_fkrGgDyRWc" href="#h_fkrGgDyRWc" tabindex="-1" role="presentation"></a>Methods</h2>

<p><a class="p_ident" id="p_t1dHhJEzat" href="#p_t1dHhJEzat" tabindex="-1" role="presentation"></a>문자열 및 배열 값은 <code>length</code> 속성 외에도 함수 값을 보유하는 여러 속성이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_prRDc5amqh" href="#c_prRDc5amqh" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">doh</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Doh&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>);
<span class="cm-comment">// → function</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>());
<span class="cm-comment">// → DOH</span></pre>

<p><a class="p_ident" id="p_TWVl3O+8/l" href="#p_TWVl3O+8/l" tabindex="-1" role="presentation"></a>모든 문자열은 <code>toUpperCase</code> 속성을 가집니다(대문자 변환). 소문자 변환에는 <code>toLowerCase</code>를 사용합니다.</p>

<p><a class="p_ident" id="p_ZYWrM09QFe" href="#p_ZYWrM09QFe" tabindex="-1" role="presentation"></a>흥미로운 점은 <code>toUpperCase</code>에 관한 호출에서 어떠한 인수들을 전달하지 않아도 어떻게든 문자열 <code>&quot;Doh&quot;</code>에 접근합니다. 이에 관한 사항은 <a href="06_object.html#obj_methods">6장</a>에서 설명하기로 합니다.</p>

<p><a class="p_ident" id="p_96KudJIN5i" href="#p_96KudJIN5i" tabindex="-1" role="presentation"></a>함수들을 포함하는 속성들은 일반적으로 그것들이 속하는 값의 <em>메서드</em>로 불립니다(<code>toUpperCase</code>가 문자열의 메서드인 것처럼).</p>

<p id="array_methods"><a class="p_ident" id="p_aAS6mUhzmc" href="#p_aAS6mUhzmc" tabindex="-1" role="presentation"></a>다음은 배열 처리하는 데에 사용되는 메서드들을 예시합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RiFZUNk6gr" href="#c_RiFZUNk6gr" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">sequence</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>];
<span class="cm-variable">sequence</span>.<span class="cm-property">push</span>(<span class="cm-number">4</span>);
<span class="cm-variable">sequence</span>.<span class="cm-property">push</span>(<span class="cm-number">5</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>);
<span class="cm-comment">// → [1, 2, 3, 4, 5]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>.<span class="cm-property">pop</span>());
<span class="cm-comment">// → 5</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sequence</span>);
<span class="cm-comment">// → [1, 2, 3, 4]</span></pre>

<p><a class="p_ident" id="p_6iATZ6SSgb" href="#p_6iATZ6SSgb" tabindex="-1" role="presentation"></a><code>push</code> 메서드는 배열의 끝에 값을 추가하고, <code>pop</code> 메서드는 배열의 마지막에 있는 값을 제거하고 반환합니다(스택 작업).</p>

<h2><a class="h_ident" id="h_cqg63Sxe3o" href="#h_cqg63Sxe3o" tabindex="-1" role="presentation"></a>Objects</h2>

<p><a class="p_ident" id="p_D8cm1kz0P8" href="#p_D8cm1kz0P8" tabindex="-1" role="presentation"></a>앞 늑대 인간에 관한 글로 돌아가서 일일 로그 항목 집합은 배열로 표시될 수 있습니다. 그러나 항목은 숫자나 문자열로 구성되지 않습니다. 각 항목은 활동 리스트와 Jacques가 다람쥐로 변했는지 여부를 나타내는 부울 값을 저장해야 합니다. 이상적으로는 이러한 값을 단일 값으로 그룹화한 다음 그룹화된 값을 로그 항목 배열에 넣는 것이 좋습니다.</p>

<p><a class="p_ident" id="p_amO+YCpNIz" href="#p_amO+YCpNIz" tabindex="-1" role="presentation"></a>타입 <em>object</em>의 값들은 임의의 속성 모음에 해당합니다. 객체를 생성하는 한 가지 방식은 중괄호 표현 식입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Y37a9WsXpl" href="#c_Y37a9WsXpl" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">day1</span> <span class="cm-operator">=</span> {
  <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
  <span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>]
};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">squirrel</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_hPPBEWYY/i" href="#p_hPPBEWYY/i" tabindex="-1" role="presentation"></a>중괄호 안에는 쉼표로 구분된 속성 리스트가 있습니다. 각 속성에는 이름 뒤에 콜론과 값이 있습니다. 객체가 여러 줄에 걸쳐 쓰여질 때 예와 같이 들여쓰기를 하면 가독성에 도움이 됩니다. 이름이 유효한 바인딩 이름이나 유효한 숫자가 아닌 속성은 인용해야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_n8ErtKNPW/" href="#c_n8ErtKNPW/" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">descriptions</span> <span class="cm-operator">=</span> {
  <span class="cm-property">work</span>: <span class="cm-string">&quot;Went to work&quot;</span>,
  <span class="cm-string cm-property">&quot;touched tree&quot;</span>: <span class="cm-string">&quot;Touched a tree&quot;</span>
};</pre>

<p><a class="p_ident" id="p_nZ3mgfn27O" href="#p_nZ3mgfn27O" tabindex="-1" role="presentation"></a>이것은 중괄호가 JavaScript에서 두 가지 의미를 갖는다는 것을 의미합니다. 명령문이 시작될 때 명령문 블록을 시작합니다. 다른 위치에서는 객체를 설명합니다. 다행스럽게도 중괄호로 묶인 객체로 문장을 시작하는 것은 거의 유용하지 않으므로 이 둘 사이의 모호성은 그다지 문제가 되지 않습니다.</p>

<p><a class="p_ident" id="p_lBjH6GtvXt" href="#p_lBjH6GtvXt" tabindex="-1" role="presentation"></a>존재하지 않는 속성을 읽으면 <code>undefined</code> 값이 나타납니다.</p>

<p><a class="p_ident" id="p_m1hLPDyHXE" href="#p_m1hLPDyHXE" tabindex="-1" role="presentation"></a><code>=</code> 연산자를 사용하여 속성 표현식에 값을 할당할 수 있습니다. 이것은 속성 값이 이미 존재하는 경우 해당 값을 대체하거나 존재하지 않는 경우 객체에 새 속성을 생성합니다.</p>

<p><a class="p_ident" id="p_2b9eQWe4l/" href="#p_2b9eQWe4l/" tabindex="-1" role="presentation"></a>객체들은 일련의 촉수들을 갖는 문어로 간주할 수 있는데 각 촉수의 이름은 문신으로 새겨져 있습니다. 촉수 결합 모델은 속성 결합과 유사한 방식을 사용합니다. 값을 파악하지만 다른 결합과 속성들이 포함되어 있을 수 있습니다.</p>

<p><a class="p_ident" id="p_nQBjCOh9nC" href="#p_nQBjCOh9nC" tabindex="-1" role="presentation"></a><code>delete</code> 연산자는 촉수를 제거합니다. 단항 연산자로 객체 속성에 적용되면 해당 이름의 속성이 객체에서 제거됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_66M3B1wG98" href="#c_66M3B1wG98" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">anObject</span> <span class="cm-operator">=</span> {<span class="cm-property">left</span>: <span class="cm-number">1</span>, <span class="cm-property">right</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-keyword">delete</span> <span class="cm-variable">anObject</span>.<span class="cm-property">left</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;left&quot;</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;right&quot;</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_vVEymXRSvR" href="#p_vVEymXRSvR" tabindex="-1" role="presentation"></a>이항 <code>in</code> 연산자를 문자열과 객체에 적용하면, 객체가 해당 이름의 속성을 갖는지 알 수 있습니다. <code>undefined</code>로 속성을 설정하는 것과 실제 그것을 제거하는 것 간에 차이와 관련하여 첫 번째 경우에서 객체는 여전히 속성을 갖는 것인데 반하여 두 번째 경우는 더 이상 속성이 존재하지 않기 때문에 <code>in</code>의 적용은 <code>false</code>를 반환합니다.</p>

<p><a class="p_ident" id="p_SvMW6lxfp+" href="#p_SvMW6lxfp+" tabindex="-1" role="presentation"></a>객체에 어떤 속성이 있는지 알아보기 위해 <code>Object.keys</code> 함수를 사용할 수 있습니다. 객체를 지정하면 객체의 속성 이름인 문자열 배열이 반환됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0oaalmpqn6" href="#c_0oaalmpqn6" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Object</span>.<span class="cm-property">keys</span>({<span class="cm-property">x</span>: <span class="cm-number">0</span>, <span class="cm-property">y</span>: <span class="cm-number">0</span>, <span class="cm-property">z</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span></pre>

<p><a class="p_ident" id="p_z4/OPZzTTK" href="#p_z4/OPZzTTK" tabindex="-1" role="presentation"></a><code>Object.assign</code>는 한 객체의 모든 속성을 다른 객체로 복사하는 함수입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ngXKayzwiT" href="#c_ngXKayzwiT" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">objectA</span> <span class="cm-operator">=</span> {<span class="cm-property">a</span>: <span class="cm-number">1</span>, <span class="cm-property">b</span>: <span class="cm-number">2</span>};
<span class="cm-variable">Object</span>.<span class="cm-property">assign</span>(<span class="cm-variable">objectA</span>, {<span class="cm-property">b</span>: <span class="cm-number">3</span>, <span class="cm-property">c</span>: <span class="cm-number">4</span>});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">objectA</span>);
<span class="cm-comment">// → {a: 1, b: 3, c: 4}</span></pre>

<p><a class="p_ident" id="p_Rl8msr9DUz" href="#p_Rl8msr9DUz" tabindex="-1" role="presentation"></a>배열은 일련의 객체를 저장하는데 특화된 일종의 객체일 뿐입니다. <code>typeof []</code>로 평가하면 <code>&quot;object&quot;</code>가 생성됩니다. 모든 촉수가 일렬로 정렬되어 있고 숫자로 표시된 길고 납작한 문어를 볼 수 있습니다.</p>

<p><a class="p_ident" id="p_d1H6/6O79A" href="#p_d1H6/6O79A" tabindex="-1" role="presentation"></a>Jacques가 보관하고 있는 일지를 객체 배열로 나타내면 다음과 같습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_H7Np/tieSQ" href="#c_H7Np/tieSQ" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">journal</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>,
            <span class="cm-string">&quot;running&quot;</span>, <span class="cm-string">&quot;television&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;ice cream&quot;</span>, <span class="cm-string">&quot;cauliflower&quot;</span>,
            <span class="cm-string">&quot;lasagna&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;brushed teeth&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">&quot;weekend&quot;</span>, <span class="cm-string">&quot;cycling&quot;</span>, <span class="cm-string">&quot;break&quot;</span>, <span class="cm-string">&quot;peanuts&quot;</span>,
            <span class="cm-string">&quot;beer&quot;</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">true</span>},
  <span class="cm-comment">/* and so on... */</span>
];</pre>

<h2><a class="h_ident" id="h_C3n45IkMhg" href="#h_C3n45IkMhg" tabindex="-1" role="presentation"></a>가변성(Mutability)</h2>

<p><a class="p_ident" id="p_ZAtU8veKBN" href="#p_ZAtU8veKBN" tabindex="-1" role="presentation"></a>객체 값은 변경될 수 있습니다. 숫자, 문자열 및 부울과 같은 타입은 모두 변경할 수 없습니다. 이러한 타입의 값을 변경하는 것은 불가능합니다. 이것들을 결합하고 새로운 값을 도출할 수 있지만 특정 문자열 값을 사용하면 해당 값은 항상 동일하게 유지됩니다. 그 안의 텍스트는 변경할 수 없습니다. <code>&quot;cat&quot;</code>가 포함된 문자열이 있는 경우 다른 코드에서 문자열의 문자를 변경하여 <code>&quot;rat&quot;</code>로 만들 수 없습니다.</p>

<p><a class="p_ident" id="p_0geJong3Bv" href="#p_0geJong3Bv" tabindex="-1" role="presentation"></a>객체는 다르게 작동합니다. 속성을 변경하여 단일 객체 값이 다른 시점에서 다른 내용을 갖도록 할 수 있습니다.</p>

<p><a class="p_ident" id="p_fVZ1xXAqW5" href="#p_fVZ1xXAqW5" tabindex="-1" role="presentation"></a>120과 120이라는 두 개의 숫자가 있는 경우 동일한 물리적 비트를 참조하는지 여부에 관계없이 정확히 동일한 숫자로 간주할 수 있습니다. 객체의 경우 동일한 객체에 대한 두 개의 참조가 있는 것과 동일한 속성을 포함하는 두 개의 다른 객체가 있는 것 사이에는 차이가 있습니다. 다음 코드를 고려하십시오.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_I1Dv6D46/p" href="#c_I1Dv6D46/p" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">object1</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};
<span class="cm-keyword">let</span> <span class="cm-def">object2</span> <span class="cm-operator">=</span> <span class="cm-variable">object1</span>;
<span class="cm-keyword">let</span> <span class="cm-def">object3</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object2</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object3</span>);
<span class="cm-comment">// → false</span>

<span class="cm-variable">object1</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-number">15</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object2</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 15</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object3</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 10</span></pre>

<p><a class="p_ident" id="p_LKrvBk0ldY" href="#p_LKrvBk0ldY" tabindex="-1" role="presentation"></a><code>object1</code>과 <code>object2</code> 바인딩은 같은 객체로 파악되기 때문에 <code>object1</code>의 변경은 <code>object2</code>의 값을 변경시킵니다. 그것들은 동일한 정체성을 갖는 것입니다. <code>object3</code> 바인딩은 상이한 객체를 가리킵니다. <code>object1</code>과 같은 속성들을 갖지만 별개의 생활을 하게 됩니다.</p>

<p><a class="p_ident" id="p_eic4GJbroA" href="#p_eic4GJbroA" tabindex="-1" role="presentation"></a>바인딩은 변경 가능하거나 상수일 수도 있지만 이는 해당 값이 작동하는 방식과 별개입니다. 숫자 값이 변경되지 않더라도 <code>let</code> 바인딩을 사용하여 바인딩이 가리키는 값을 변경하여 변경되는 숫자를 추적할 수 있습니다. 마찬가지로 <code>const</code> 객체에 대한 바인딩 자체는 변경할 수 없고 계속해서 동일한 개체를 가리키지만 해당 객체의 내용이 변경될 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_eOXMRndYxO" href="#c_eOXMRndYxO" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">score</span> <span class="cm-operator">=</span> {<span class="cm-property">visitors</span>: <span class="cm-number">0</span>, <span class="cm-property">home</span>: <span class="cm-number">0</span>};
<span class="cm-comment">// This is okay</span>
<span class="cm-variable">score</span>.<span class="cm-property">visitors</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-comment">// This isn't allowed</span>
<span class="cm-variable">score</span> <span class="cm-operator">=</span> {<span class="cm-property">visitors</span>: <span class="cm-number">1</span>, <span class="cm-property">home</span>: <span class="cm-number">1</span>};</pre>

<p><a class="p_ident" id="p_wD7jhXt+Tr" href="#p_wD7jhXt+Tr" tabindex="-1" role="presentation"></a>JavaScript의 == 연산자로 객체 비교는 두 객체가 정확히 동일한 값인 경우에만 <code>true</code>입니다. 서로 다른 객체를 비교하면 속성이 동일하더라도 <code>false</code>가 반환됩니다. 내용별로 객체를 비교하는 심층 비교 작업은 없지만 직접 작성하는 것은 가능합니다.</p>

<h2><a class="h_ident" id="h_qHGOoBxOeE" href="#h_qHGOoBxOeE" tabindex="-1" role="presentation"></a>lycanthrope 일지</h2>

<p><a class="p_ident" id="p_z1vPsL0dwv" href="#p_z1vPsL0dwv" tabindex="-1" role="presentation"></a>Jacques는 JavaScript 인터프리터를 시작하고 일기를 유지하는 데 필요한 환경을 설정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CI+dtzXW/x" href="#c_CI+dtzXW/x" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">journal</span> <span class="cm-operator">=</span> [];

<span class="cm-keyword">function</span> <span class="cm-def">addEntry</span>(<span class="cm-def">events</span>, <span class="cm-def">squirrel</span>) {
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>({<span class="cm-property">events</span>, <span class="cm-property">squirrel</span>});
}</pre>

<p><a class="p_ident" id="p_ljMiZolRIM" href="#p_ljMiZolRIM" tabindex="-1" role="presentation"></a>저널에 추가된 객체가 다소 이상합니다. <code>events: events</code>와 같은 속성을 선언하는 대신에 속성 이름만 제공합니다. 이것은 같은 것을 의미하는 속기입니다. 중괄호 표기법의 속성 이름 뒤에 값이 없으면 해당 값은 동일한 이름의 바인딩에서 가져옵니다.</p>

<p><a class="p_ident" id="p_cm0psWaVgC" href="#p_cm0psWaVgC" tabindex="-1" role="presentation"></a>매일 저녁 10시, 때로는 다음날 아침, 책장 맨 위 선반에서 내려와 Jacques는 하루를 기록합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_S+F+R2oIfR" href="#c_S+F+R2oIfR" tabindex="-1" role="presentation"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>,
          <span class="cm-string">&quot;television&quot;</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;ice cream&quot;</span>, <span class="cm-string">&quot;cauliflower&quot;</span>, <span class="cm-string">&quot;lasagna&quot;</span>,
          <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;brushed teeth&quot;</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">&quot;weekend&quot;</span>, <span class="cm-string">&quot;cycling&quot;</span>, <span class="cm-string">&quot;break&quot;</span>, <span class="cm-string">&quot;peanuts&quot;</span>,
          <span class="cm-string">&quot;beer&quot;</span>], <span class="cm-atom">true</span>);</pre>

<p><a class="p_ident" id="p_7VcOxe4CEu" href="#p_7VcOxe4CEu" tabindex="-1" role="presentation"></a>데이터가 충분하면 통계를 사용하여 이러한 이벤트 중 어느 것이 다람쥐와 관련될 수 있는지 알아내려고 합니다.</p>

<p><a class="p_ident" id="p_EedDVNQ30H" href="#p_EedDVNQ30H" tabindex="-1" role="presentation"></a><em>Correlation</em>은 통계적 변수 간의 의존성을 측정한 것입니다. 통계 변수는 프로그래밍 변수와 완전히 동일하지 않습니다. 통계에는 일반적으로 일련의 측정값이 있으며 각 변수는 모든 측정값에 대해 측정됩니다. 변수 간의 상관 관계는 일반적으로 -1에서 1 사이의 값으로 표현됩니다. 상관 관계가 0이라는 것은 변수가 관련이 없다는 것을 의미합니다. 하나의 상관 관계는 두 가지가 완벽하게 관련되어 있음을 나타냅니다. 하나를 알면 다른 것도 알 수 있습니다. 음수는 또한 변수가 완벽하게 관련되어 있지만 반대임을 의미합니다. 하나가 참이면 다른 하나는 거짓입니다.</p>

<p><a class="p_ident" id="p_mq//xARuKm" href="#p_mq//xARuKm" tabindex="-1" role="presentation"></a>두 Boolean 변수 간에 상관 관계를 측정하기 위해 <em>phi 계수</em> (<em>ϕ</em>)를 사용할 수 있습니다. 이것은 입력이 변수의 다른 조합이 관찰된 횟수를 포함하는 빈도 테이블 공식입니다. 공식의 출력은 상관 관계를 설명하는 -1과 1 사이의 숫자입니다.</p>

<p><a class="p_ident" id="p_enPDgop6ZQ" href="#p_enPDgop6ZQ" tabindex="-1" role="presentation"></a>피자를 먹는 이벤트를 다음과 같은 빈도 테이블에 넣을 수 있습니다. 여기서 각 숫자는 측정에서 조합이 발생한 횟수를 나타냅니다.</p><figure><img src="img/pizza-squirrel.svg" alt="Eating pizza versus turning into a squirrel"></figure>

<p><a class="p_ident" id="p_34XzN30BBH" href="#p_34XzN30BBH" tabindex="-1" role="presentation"></a>해당 테이블을 <em>n</em>이라 하면 다음 공식을 사용하여 <em>ϕ</em>를 계산할 수 있습니다.</p><div>
<table style="border-collapse: collapse; margin-left: 1em;"><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-left: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;"><em>n</em><sub>11</sub><em>n</em><sub>00</sub> −
      <em>n</em><sub>10</sub><em>n</em><sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px"><em>n</em><sub>1•</sub><em>n</em><sub>0•</sub><em>n</em><sub>•1</sub><em>n</em><sub>•0</sub></span>
    </span></div>
  </td>
</tr></table>
</div>

<p><a class="p_ident" id="p_6U87ck4G90" href="#p_6U87ck4G90" tabindex="-1" role="presentation"></a>여기서 <em>n</em><sub>01</sub>은 첫 번째 변수(squirrelness)가 false (0)이고 두 번째 변수(pizza)가 true (1)인 측정 횟수를 나타냅니다. pizza 테이블에서 <em>n</em><sub>01</sub>은 9입니다.</p>

<p><a class="p_ident" id="p_pweIXp0GRF" href="#p_pweIXp0GRF" tabindex="-1" role="presentation"></a>값 <em>n</em><sub>1•</sub>은 첫 번째 변수가 true인 모든 측정의 합을 나타내는데 예 테이블의 경우에 5입니다. 유사하게 <em>n</em><sub>•0</sub>은 두 번째 변수가 false인 측정값의 합을 나타냅니다.</p>

<p><a class="p_ident" id="p_ACMn7uvFzz" href="#p_ACMn7uvFzz" tabindex="-1" role="presentation"></a>따라서 피자 테이블의 경우에 나눗셈 선 위 부분은 1×76−4×9 = 40이고 아래 부분은 5×85×10×80의 제곱근 또는 √340000입니다. 이리하여 <em>ϕ</em> ≈ 0.069로 아주 작습니다. 피자를 먹는 것은 변형에 영향을 미치지 않는 것으로 보입니다.</p>

<h2><a class="h_ident" id="h_YwedOm6SqZ" href="#h_YwedOm6SqZ" tabindex="-1" role="presentation"></a>상관관계 계산</h2>

<p><a class="p_ident" id="p_jn2nhCXEpR" href="#p_jn2nhCXEpR" tabindex="-1" role="presentation"></a>4개 요소 배열(<code>[76, 9, 4, 1]</code>)을 사용하여 JavaScript에서 2x2 테이블을 나타낼 수 있습니다. 두 개의 요소를 가진 배열(<code>[[76, 9], [4, 1]]</code>)을 포함하는 배열이나 <code>&quot;11&quot;</code> 및 <code>&quot;01&quot;</code>와 같은 속성 이름을 가진 객체와 같은 다른 표현을 사용할 수도 있지만 평면 배열은 간단하고 테이블에 액세스하는 표현식을 즐겁게 짧게 만듭니다. 배열에 대한 인덱스를 2비트 이진수로 해석합니다. 여기서 가장 왼쪽(가장 중요한) 숫자는 squirrel 변수를 나타내고 가장 오른쪽(최하위) 숫자는 이벤트 변수를 나타냅니다. 예를 들어, 이진수 <code>10</code>는 Jacques가 다람쥐로 변했지만 이벤트(예: "피자")가 발생하지 않은 경우를 나타냅니다. 이런 일이 네 번 있었습니다. 바이너리 <code>10</code>은 10진수로 2이기 때문에 이 숫자를 배열의 인덱스 2에 저장합니다.</p>

<p id="phi_function"><a class="p_ident" id="p_h+u9TgFTTH" href="#p_h+u9TgFTTH" tabindex="-1" role="presentation"></a>다음은 이러한 배열에서 <em>ϕ</em> 계수를 계산하는 함수입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AnoNjFldkv" href="#c_AnoNjFldkv" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>([<span class="cm-number">76</span>, <span class="cm-number">9</span>, <span class="cm-number">4</span>, <span class="cm-number">1</span>]));
<span class="cm-comment">// → 0.068599434</span></pre>

<p><a class="p_ident" id="p_DPLO2QZk5F" href="#p_DPLO2QZk5F" tabindex="-1" role="presentation"></a><em>ϕ</em> 공식을 JavaScript로 직접 작성한 것입니다. <code>Math.sqrt</code>는 제곱근 함수로 표준 자바스크립트 환경에서 <code>Math</code> 객체로 제공됩니다. 행이나 열의 합이 데이터 구조에 직접 저장되지 않기 때문에 n<sub>1•</sub>과 같은 필드를 얻으려면 테이블에서 두 개의 필드를 추가해야 합니다.</p>

<p><a class="p_ident" id="p_GhEP5hEDnb" href="#p_GhEP5hEDnb" tabindex="-1" role="presentation"></a>Jacques는 3개월 동안 일기를 보관했습니다. 결과 데이터 세트는 바인딩 및 다운로드 가능한 <a href="https://eloquentjavascript.net/code/journal.js">file</a>과 <code>JOURNAL</code>에 저장되어 있기 때문에 이 페이지의 코딩 샌드박스에서 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_sM+4QT8FKs" href="#p_sM+4QT8FKs" tabindex="-1" role="presentation"></a>저널에서 특정 이벤트에 대한 2x2 테이블을 추출하려면 모든 항목을 반복하고 다람쥐 변환과 관련하여 이벤트가 발생한 횟수를 집계해야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rfea+FwMb5" href="#c_rfea+FwMb5" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">tableFor</span>(<span class="cm-def">event</span>, <span class="cm-def">journal</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> [<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">i</span>], <span class="cm-def">index</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">event</span>)) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">squirrel</span>) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">2</span>;
    <span class="cm-variable-2">table</span>[<span class="cm-variable-2">index</span>] <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [76, 9, 4, 1]</span></pre>

<p><a class="p_ident" id="p_1/7IsMpwdF" href="#p_1/7IsMpwdF" tabindex="-1" role="presentation"></a>배열에는 주어진 값이 배열에 존재하는지 확인하는 <code>includes</code> 메서드가 있습니다. 함수는 이를 사용하여 관심 있는 이벤트 이름이 주어진 날짜의 이벤트 목록에 포함되어 있는지 여부를 결정합니다.</p>

<p><a class="p_ident" id="p_2jmDtun7lQ" href="#p_2jmDtun7lQ" tabindex="-1" role="presentation"></a><code>tableFor</code>의 루프 본문은 항목에 관심 있는 특정 이벤트가 포함되어 있는지 여부와 이벤트가 다람쥐 사건과 함께 발생하는지 여부를 확인하여 각 저널 항목이 테이블의 어느 상자에 속하는지 파악합니다. 그런 다음 루프는 테이블의 올바른 상자에 하나를 추가합니다.</p>

<p><a class="p_ident" id="p_f0iI+VuF1R" href="#p_f0iI+VuF1R" tabindex="-1" role="presentation"></a>이제 개별 상관 관계를 계산하는 데 필요한 도구가 준비되었습니다. 남은 단계는 기록된 모든 유형의 이벤트에 대한 상관 관계를 찾고 눈에 띄는 것이 있는지 확인하는 것입니다.</p>

<h2 id="for_of_loop"><a class="h_ident" id="h_4WwZLib71C" href="#h_4WwZLib71C" tabindex="-1" role="presentation"></a>배열 루프</h2>

<p><a class="p_ident" id="p_NcUX4h3Azc" href="#p_NcUX4h3Azc" tabindex="-1" role="presentation"></a><code>tableFor</code> 함수에는 다음과 같은 루프가 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_pE7VRrRQir" href="#c_pE7VRrRQir" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">JOURNAL</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable">JOURNAL</span>[<span class="cm-variable">i</span>];
  <span class="cm-comment">// Do something with entry</span>
}</pre>

<p><a class="p_ident" id="p_bofXG4HkzH" href="#p_bofXG4HkzH" tabindex="-1" role="presentation"></a>이러한 종류의 루프는 고전적인 JavaScript에서 일반적입니다. 한 번에 한 요소씩 배열을 살펴보는 것은 많이 발생하는 일이며, 그렇게 하려면 배열의 길이에 대해 카운터를 실행하고 각 요소를 차례로 선택해야 합니다.</p>

<p><a class="p_ident" id="p_Xl/M0+NR/e" href="#p_Xl/M0+NR/e" tabindex="-1" role="presentation"></a>최신 JavaScript에서는 이러한 루프를 작성하는 더 간단한 방법이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_OXsCQPvDE1" href="#c_OXsCQPvDE1" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable">JOURNAL</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string-2">`${</span><span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">length</span><span class="cm-string-2">}</span> <span class="cm-string-2">events.`</span>);
}</pre>

<p><a class="p_ident" id="p_LDkHv2luaA" href="#p_LDkHv2luaA" tabindex="-1" role="presentation"></a>변수 정의 뒤에 <code>of</code> 단어가 있는 <code>for</code> 루프 사용은 <code>of</code> 뒤에 주어진 값의 요소에 대해 루프를 돌게 됩니다. 이것은 배열뿐만 아니라 문자열 및 기타 데이터 구조에서도 작동합니다.</p>

<h2 id="analysis"><a class="h_ident" id="h_Lg5n7mjqw/" href="#h_Lg5n7mjqw/" tabindex="-1" role="presentation"></a>최종 분석</h2>

<p><a class="p_ident" id="p_LI+01yIQON" href="#p_LI+01yIQON" tabindex="-1" role="presentation"></a>데이터 집합에서 발생하는 모든 타입의 이벤트에 대한 상관 관계를 계산하기 위해서는 먼저 모든 타입의 이벤트를 찾아야 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_P6cqJZBL1M" href="#c_P6cqJZBL1M" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">journalEvents</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">journal</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">events</span>.<span class="cm-property">includes</span>(<span class="cm-variable-2">event</span>)) {
        <span class="cm-variable-2">events</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">event</span>);
      }
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">events</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [&quot;carrot&quot;, &quot;exercise&quot;, &quot;weekend&quot;, &quot;bread&quot;, …]</span></pre>

<p><a class="p_ident" id="p_vBsW+TJrFo" href="#p_vBsW+TJrFo" tabindex="-1" role="presentation"></a>모든 이벤트를 살펴보고 <code>events</code> 배열에 아직 없는 이벤트를 배열에 추가함으로써 함수는 모든 유형의 이벤트를 수집합니다.</p>

<p><a class="p_ident" id="p_HohHy+JZoP" href="#p_HohHy+JZoP" tabindex="-1" role="presentation"></a>이를 사용하여 모든 상관 관계를 볼 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_7ws9oWaneM" href="#c_7ws9oWaneM" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>)) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;:&quot;</span>, <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable">event</span>, <span class="cm-variable">JOURNAL</span>)));
}
<span class="cm-comment">// → carrot:   0.0140970969</span>
<span class="cm-comment">// → exercise: 0.0685994341</span>
<span class="cm-comment">// → weekend:  0.1371988681</span>
<span class="cm-comment">// → bread:   -0.0757554019</span>
<span class="cm-comment">// → pudding: -0.0648203724</span>
<span class="cm-comment">// and so on...</span></pre>

<p><a class="p_ident" id="p_TiI6dIjE18" href="#p_TiI6dIjE18" tabindex="-1" role="presentation"></a>대부분의 상관관계는 0에 가깝습니다. 당근, 빵 또는 푸딩을 먹는다고 해서 다람쥐 라이칸트로피가 촉발되지는 않습니다. 주말에 좀 더 자주 발생하는 것으로 보입니다. 결과를 필터링하여 0.1보다 크거나 -0.1보다 작은 상관 관계만 표시해 보겠습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_hBXzmb7hPU" href="#c_hBXzmb7hPU" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">event</span> <span class="cm-keyword">of</span> <span class="cm-variable">journalEvents</span>(<span class="cm-variable">JOURNAL</span>)) {
  <span class="cm-keyword">let</span> <span class="cm-def">correlation</span> <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable">event</span>, <span class="cm-variable">JOURNAL</span>));
  <span class="cm-keyword">if</span> (<span class="cm-variable">correlation</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0.1</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-variable">correlation</span> <span class="cm-operator">&lt;</span> <span class="cm-operator">-</span><span class="cm-number">0.1</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;:&quot;</span>, <span class="cm-variable">correlation</span>);
  }
}
<span class="cm-comment">// → weekend:        0.1371988681</span>
<span class="cm-comment">// → brushed teeth: -0.3805211953</span>
<span class="cm-comment">// → candy:          0.1296407447</span>
<span class="cm-comment">// → work:          -0.1371988681</span>
<span class="cm-comment">// → spaghetti:      0.2425356250</span>
<span class="cm-comment">// → reading:        0.1106828054</span>
<span class="cm-comment">// → peanuts:        0.5902679812</span></pre>

<p><a class="p_ident" id="p_SmM3fqump2" href="#p_SmM3fqump2" tabindex="-1" role="presentation"></a>다른 것보다 분명히 더 강한 상관 관계를 가진 두 가지 요인이 있습니다. 땅콩을 먹는 것은 다람쥐로 변할 가능성에 강한 긍정적인 영향을 미치는 반면, 이를 닦는 것은 상당한 부정적인 영향을 미칩니다.</p>

<p><a class="p_ident" id="p_CGdrhu89cM" href="#p_CGdrhu89cM" tabindex="-1" role="presentation"></a>흥미로운 무엇인가를 시도해 보기로 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_x7WUJStSIp" href="#c_x7WUJStSIp" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">entry</span> <span class="cm-keyword">of</span> <span class="cm-variable">JOURNAL</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-string">&quot;peanuts&quot;</span>) <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
     <span class="cm-operator">!</span><span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">includes</span>(<span class="cm-string">&quot;brushed teeth&quot;</span>)) {
    <span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;peanut teeth&quot;</span>);
  }
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">&quot;peanut teeth&quot;</span>, <span class="cm-variable">JOURNAL</span>)));
<span class="cm-comment">// → 1</span></pre>

<p><a class="p_ident" id="p_Ji3VLlNJjI" href="#p_Ji3VLlNJjI" tabindex="-1" role="presentation"></a>이러한 현상은 Jacques가 땅콩을 먹고 이를 닦지 않을 때 정확하게 발생합니다. 그가 치과 위생에 대해 그렇게 멍청하지 않았다면 그는 자신의 고통을 전혀 눈치 채지 못했을 것입니다.</p>

<p><a class="p_ident" id="p_CLBAQ41EVq" href="#p_CLBAQ41EVq" tabindex="-1" role="presentation"></a>이를 알게 된 자크는 땅콩을 아예 먹지 않고 자신의 변신이 돌아오지 않는다는 사실을 알게 됩니다.</p>

<p><a class="p_ident" id="p_IMX7LE4P7A" href="#p_IMX7LE4P7A" tabindex="-1" role="presentation"></a>몇 년 동안은 Jacques에게 좋은 일이 생겼습니다. 하지만 어느 순간 직장을 잃습니다. 직업이 없다는 것은 의료 서비스도 제공되지 않는 열악한 나라에 살고 있기 때문에 어쩔 수 없이 서커스에 취직해야 하는 그는 공연이 시작되기 전에 땅콩 버터를 입에 채우는 인크레더블 다람쥐로 공연합니다.</p>

<p><a class="p_ident" id="p_SK7dEwTJMB" href="#p_SK7dEwTJMB" tabindex="-1" role="presentation"></a>어느 날 이 불쌍한 존재에 싫증이 난 자크는 인간의 모습으로 돌아가지 못하고 서커스 텐트의 틈으로 뛰어들어 숲 속으로 사라지고, 그는 다시는 볼 수 없습니다.</p>

<h2><a class="h_ident" id="h_GFaxee4PuU" href="#h_GFaxee4PuU" tabindex="-1" role="presentation"></a>배열에 관한 추가 사항</h2>

<p><a class="p_ident" id="p_Px7nduaW01" href="#p_Px7nduaW01" tabindex="-1" role="presentation"></a>배열의 끝에 원소를 추가하고 삭제하는 <code>push</code> 및 <code>pop</code> 메서드 이외에 배열의 시작 부분에 원소 추가 및 제거를 위해 <code>unshift</code>와 <code>shift</code>를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Vq1IBpy+hP" href="#c_Vq1IBpy+hP" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">todoList</span> <span class="cm-operator">=</span> [];
<span class="cm-keyword">function</span> <span class="cm-def">remember</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">task</span>);
}
<span class="cm-keyword">function</span> <span class="cm-def">getTask</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">todoList</span>.<span class="cm-property">shift</span>();
}
<span class="cm-keyword">function</span> <span class="cm-def">rememberUrgently</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">unshift</span>(<span class="cm-variable-2">task</span>);
}</pre>

<p><a class="p_ident" id="p_Z35J/zKDAQ" href="#p_Z35J/zKDAQ" tabindex="-1" role="presentation"></a>해당 프로그램은 큐를 관리합니다. <code>remember(&quot;groceries&quot;)</code>를 호출하여 큐 끝에 항목을 추가하고, 무언가를 할 준비가 되면 큐의 맨 앞 항목을 가져오거나 제거하기 위해 <code>getTask()</code>를 호출합니다. <code>rememberUrgently</code> 함수는 또한 항목을 추가하지만 큐의 뒤쪽 대신 앞쪽에 추가합니다.</p>

<p><a class="p_ident" id="p_7VffwcInkI" href="#p_7VffwcInkI" tabindex="-1" role="presentation"></a>특정 값을 검색하기 위해 배열은 <code>indexOf</code> 메서드를 제공합니다. 이 메서드는 배열을 처음부터 끝까지 검색하고 요청된 값이 발견된 인덱스를 반환하거나 찾지 못한 경우 -1을 반환합니다. 시작 대신 끝에서 검색하려면 <code>lastIndexOf</code>라는 유사한 메서드를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_N+G0EtTfto" href="#c_N+G0EtTfto" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">indexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">lastIndexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 3</span></pre>

<p><a class="p_ident" id="p_zErdHcwkcD" href="#p_zErdHcwkcD" tabindex="-1" role="presentation"></a><code>indexOf</code>와 <code>lastIndexOf</code>는 모두 검색을 시작하는 위치를 나타내는 선택적인 두 번째 인수를 사용합니다.</p>

<p><a class="p_ident" id="p_xl0kBHXnu2" href="#p_xl0kBHXnu2" tabindex="-1" role="presentation"></a>또 다른 기본 배열 메서드로 <code>slice</code>는 시작 및 끝 인덱스를 취하고 사이의 원소들을 갖는 배열을 반환합니다. 시작 인덱스는 포함되고 마지막 인덱스는 포함되지 않습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_zCBzPnMpIk" href="#c_zCBzPnMpIk" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>, <span class="cm-number">4</span>));
<span class="cm-comment">// → [2, 3]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → [2, 3, 4]</span></pre>

<p><a class="p_ident" id="p_Y6nY8puZtN" href="#p_Y6nY8puZtN" tabindex="-1" role="presentation"></a>끝 인덱스가 지정되지 않은 <code>slice</code> 경우 시작 인덱스 이후의 모든 요소를 사용합니다. 시작 인덱스를 생략하여 전체 배열을 복사할 수도 있습니다.</p>

<p><a class="p_ident" id="p_QNFIcCtVLd" href="#p_QNFIcCtVLd" tabindex="-1" role="presentation"></a><code>concat</code> 메서드는 <code>+</code> 연산자가 문자열에 대해 수행하는 것과 유사하게 배열을 함께 연결하여 새 배열을 만드는 데 사용할 수 있습니다.</p>

<p><a class="p_ident" id="p_x8OwNmbLzo" href="#p_x8OwNmbLzo" tabindex="-1" role="presentation"></a>다음 예는 <code>concat</code>와 <code>slice</code> 작동을 나타냅니다. 배열과 인덱스를 사용하고 주어진 인덱스의 요소가 제거된 원래 배열의 복사본인 새 배열을 반환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_q+NBMNgFFy" href="#c_q+NBMNgFFy" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">remove</span>(<span class="cm-def">array</span>, <span class="cm-def">index</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">index</span>)
    .<span class="cm-property">concat</span>(<span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">index</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">remove</span>([<span class="cm-string">&quot;a&quot;</span>, <span class="cm-string">&quot;b&quot;</span>, <span class="cm-string">&quot;c&quot;</span>, <span class="cm-string">&quot;d&quot;</span>, <span class="cm-string">&quot;e&quot;</span>], <span class="cm-number">2</span>));
<span class="cm-comment">// → [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;]</span></pre>

<p><a class="p_ident" id="p_RxH5uQN5Uq" href="#p_RxH5uQN5Uq" tabindex="-1" role="presentation"></a>배열이 아닌 인수를 <code>concat</code>로 전달하면 해당 값은 요소가 하나인 배열인 것처럼 새 배열에 추가됩니다.</p>

<h2><a class="h_ident" id="h_mT4YQfwHp6" href="#h_mT4YQfwHp6" tabindex="-1" role="presentation"></a>문자열과 속성</h2>

<p><a class="p_ident" id="p_sp+O+Km+2n" href="#p_sp+O+Km+2n" tabindex="-1" role="presentation"></a><code>length</code>와 <code>toUpperCase</code>와 같은 속성들을 문자열 값으로 읽을 수 있지만, 새로운 속성 추가는 허용되지 않습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xvzL9wErq7" href="#c_xvzL9wErq7" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">kim</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Kim&quot;</span>;
<span class="cm-variable">kim</span>.<span class="cm-property">age</span> <span class="cm-operator">=</span> <span class="cm-number">88</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">kim</span>.<span class="cm-property">age</span>);
<span class="cm-comment">// → undefined</span></pre>

<p><a class="p_ident" id="p_B+oSPYAIbV" href="#p_B+oSPYAIbV" tabindex="-1" role="presentation"></a>string, number 및 Boolean 타입의 값들은 객체가 아니고 그것들에 새로운 속성을 추가해도 문제가 되지 않지만, 실제적으로는 이러한 속성들을 저장하지 않습니다. 이러한 값들은 불변으로 변경되지 않습니다.</p>

<p><a class="p_ident" id="p_8L2ib2beYN" href="#p_8L2ib2beYN" tabindex="-1" role="presentation"></a>그러나 이러한 타입에는 기본 제공 속성이 있습니다. 모든 문자열 값에는 여러 메서드가 있습니다. 몇 가지 매우 유용한 것들은 같은 이름의 배열 메소드와 유사한 <code>slice</code> 및 <code>indexOf</code>입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/Tmq1doYeG" href="#c_/Tmq1doYeG" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;coconuts&quot;</span>.<span class="cm-property">slice</span>(<span class="cm-number">4</span>, <span class="cm-number">7</span>));
<span class="cm-comment">// → nut</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;coconut&quot;</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">&quot;u&quot;</span>));
<span class="cm-comment">// → 5</span></pre>

<p><a class="p_ident" id="p_RUd6q+Q4dc" href="#p_RUd6q+Q4dc" tabindex="-1" role="presentation"></a>한 가지 차이점은 문자열의 <code>indexOf</code>는 문자열이 둘 이상의 문자를 포함하는 문자열을 검색할 수 있는 반면 해당 배열 메서드는 단일 요소만 찾습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xM5/GBnZVG" href="#c_xM5/GBnZVG" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;one two three&quot;</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">&quot;ee&quot;</span>));
<span class="cm-comment">// → 11</span></pre>

<p><a class="p_ident" id="p_USclxilOGS" href="#p_USclxilOGS" tabindex="-1" role="presentation"></a><code>trim</code> 메서드는 문자열의 시작과 끝에서 공백(공백, 줄 바꿈, 탭 및 유사한 문자)을 제거합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0AfLRWyjq0" href="#c_0AfLRWyjq0" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;  okay \n &quot;</span>.<span class="cm-property">trim</span>());
<span class="cm-comment">// → okay</span></pre>

<p><a class="p_ident" id="p_pSkK9k9R0g" href="#p_pSkK9k9R0g" tabindex="-1" role="presentation"></a>3장의 <code>zeroPad</code> 함수 또한 메서드로 사용할 수 있는데, <code>padStart</code>로 불리며 원하는 길이를 취해 인수로 문자를 삽입할 수 있도록 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SJbD9MiYu+" href="#c_SJbD9MiYu+" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">String</span>(<span class="cm-number">6</span>).<span class="cm-property">padStart</span>(<span class="cm-number">3</span>, <span class="cm-string">&quot;0&quot;</span>));
<span class="cm-comment">// → 006</span></pre>

<p id="split"><a class="p_ident" id="p_/nMvmESoIj" href="#p_/nMvmESoIj" tabindex="-1" role="presentation"></a><code>split</code>를 사용하여 다른 문자열이 나타날 때마다 문자열을 분할하고 <code>join</code>을 사용하여 다시 결합할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/rV2Ed5e8V" href="#c_/rV2Ed5e8V" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">sentence</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;Secretarybirds specialize in stomping&quot;</span>;
<span class="cm-keyword">let</span> <span class="cm-def">words</span> <span class="cm-operator">=</span> <span class="cm-variable">sentence</span>.<span class="cm-property">split</span>(<span class="cm-string">&quot; &quot;</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">words</span>);
<span class="cm-comment">// → [&quot;Secretarybirds&quot;, &quot;specialize&quot;, &quot;in&quot;, &quot;stomping&quot;]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">words</span>.<span class="cm-property">join</span>(<span class="cm-string">&quot;. &quot;</span>));
<span class="cm-comment">// → Secretarybirds. specialize. in. stomping</span></pre>

<p><a class="p_ident" id="p_EKC26dOCjK" href="#p_EKC26dOCjK" tabindex="-1" role="presentation"></a>문자열은 원래 문자열의 여러 복사본을 포함하는 새 문자열을 만드는 <code>repeat</code> 메서드로 반복할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_70WotkNADb" href="#c_70WotkNADb" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;LA&quot;</span>.<span class="cm-property">repeat</span>(<span class="cm-number">3</span>));
<span class="cm-comment">// → LALALA</span></pre>

<p><a class="p_ident" id="p_JoGJxr+Ofe" href="#p_JoGJxr+Ofe" tabindex="-1" role="presentation"></a>문자열 타입의 <code>length</code> 속성처럼 문자열의 개별 문자에 접근하는 것은 배열 요소에 접근하는 것처럼 보입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Aeop9AuKAb" href="#c_Aeop9AuKAb" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-string">&quot;abc&quot;</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → b</span></pre>

<h2 id="rest_parameters"><a class="h_ident" id="h_hX9DkIBp9y" href="#h_hX9DkIBp9y" tabindex="-1" role="presentation"></a>여러 매개 변수들</h2>

<p><a class="p_ident" id="p_4Vr2QMYcHp" href="#p_4Vr2QMYcHp" tabindex="-1" role="presentation"></a>함수가 여러 인수를 허용하는 것이 유용할 수 있습니다. 예를 들어, <code>Math.max</code>는 주어진 모든 인수의 최대값을 계산합니다.</p>

<p><a class="p_ident" id="p_eWuSc6aG2b" href="#p_eWuSc6aG2b" tabindex="-1" role="presentation"></a>이러한 함수를 작성하려면 다음과 같이 함수의 마지막 매개변수 앞에 세 개의 점을 넣습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_UXPbyGFVIB" href="#c_UXPbyGFVIB" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">max</span>(<span class="cm-meta">...</span><span class="cm-def">numbers</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-atom">Infinity</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">number</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">numbers</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">number</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">result</span>) <span class="cm-variable-2">result</span> <span class="cm-operator">=</span> <span class="cm-variable-2">number</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">max</span>(<span class="cm-number">4</span>, <span class="cm-number">1</span>, <span class="cm-number">9</span>, <span class="cm-operator">-</span><span class="cm-number">2</span>));
<span class="cm-comment">// → 9</span></pre>

<p><a class="p_ident" id="p_rGoFNpUuEy" href="#p_rGoFNpUuEy" tabindex="-1" role="presentation"></a>이러한 함수가 호출되면 나머지 매개변수는 모든 추가 인수를 포함하는 배열에 바인딩됩니다. 그 앞에 다른 매개변수가 있는 경우 해당 값은 해당 배열의 일부가 아닙니다. <code>max</code>에서와 같이 유일한 매개변수인 경우 모든 인수를 보유합니다.</p>

<p><a class="p_ident" id="p_ZVL6nOj2oy" href="#p_ZVL6nOj2oy" tabindex="-1" role="presentation"></a>유사하게 3점 표기법을 사용하여 인수 배열이 있는 함수를 호출할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_h9hmTe3vix" href="#c_h9hmTe3vix" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">numbers</span> <span class="cm-operator">=</span> [<span class="cm-number">5</span>, <span class="cm-number">1</span>, <span class="cm-number">7</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">max</span>(<span class="cm-meta">...</span><span class="cm-variable">numbers</span>));
<span class="cm-comment">// → 7</span></pre>

<p><a class="p_ident" id="p_Q6Tzyy9eaj" href="#p_Q6Tzyy9eaj" tabindex="-1" role="presentation"></a>이것은 배열을 함수 호출로 확산하여 요소를 별도의 인수로 전달합니다. <code>max(9, .<wbr>.<wbr>.<wbr>numbers, 2)</code>에서와 같이 다른 인수와 함께 이와 같은 배열을 포함할 수 있습니다.</p>

<p><a class="p_ident" id="p_/SfVO/tjcB" href="#p_/SfVO/tjcB" tabindex="-1" role="presentation"></a>대괄호 배열 표기법은 유사하게 3중 점 연산자가 다른 배열을 새 배열로 퍼뜨릴 수 있도록 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4t+LJt3Kyo" href="#c_4t+LJt3Kyo" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">words</span> <span class="cm-operator">=</span> [<span class="cm-string">&quot;never&quot;</span>, <span class="cm-string">&quot;fully&quot;</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-string">&quot;will&quot;</span>, <span class="cm-meta">...</span><span class="cm-variable">words</span>, <span class="cm-string">&quot;understand&quot;</span>]);
<span class="cm-comment">// → [&quot;will&quot;, &quot;never&quot;, &quot;fully&quot;, &quot;understand&quot;]</span></pre>

<h2><a class="h_ident" id="h_C51DnYk8WZ" href="#h_C51DnYk8WZ" tabindex="-1" role="presentation"></a>Math 객체</h2>

<p><a class="p_ident" id="p_h3aa0itA5J" href="#p_h3aa0itA5J" tabindex="-1" role="presentation"></a><code>Math</code>는 <code>Math.max</code> (maximum), <code>Math.min</code> (minimum) 및 <code>Math.sqrt</code> (square root)와 같은 숫자 관련 유틸리티 함수의 가방입니다.</p>

<p id="namespace_pollution"><a class="p_ident" id="p_Sae3fXYP2/" href="#p_Sae3fXYP2/" tabindex="-1" role="presentation"></a><code>Math</code> 객체는 관련 기능들을 그룹화 시키기 위한 컨테이너로 사용됩니다. <code>Math</code> 객체는 하나뿐이며 값으로 거의 유용하지 않습니다. 오히려 이러한 모든 기능과 값이 전역 바인딩일 필요가 없도록 <em>namespace</em>를 제공합니다.</p>

<p><a class="p_ident" id="p_fGEMziAXhp" href="#p_fGEMziAXhp" tabindex="-1" role="presentation"></a>전역 바인딩이 너무 많으면 네임스페이스가 오염됩니다. 더 많은 이름을 사용할수록 일부 기존 바인딩 값을 실수로 덮어쓸 가능성이 커집니다.</p>

<p><a class="p_ident" id="p_zWXQRNgLI/" href="#p_zWXQRNgLI/" tabindex="-1" role="presentation"></a><code>Math</code> 객체로 돌아가서 삼각법을 수행해야 하는 경우 <code>Math</code>는 도움이 될 수 있습니다. 여기에는 <code>cos</code> (cosine), <code>sin</code> (sine) 및 <code>tan</code> (tangent) 뿐만 아니라 그것의 역 함수인 <code>acos</code>, <code>asin</code> 및 <code>atan</code>가 있습니다. 숫자 π(pi)는 <code>Math.PI</code>로 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_54zxf+2nsU" href="#c_54zxf+2nsU" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">randomPointOnCircle</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable-2">angle</span>),
          <span class="cm-property">y</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable-2">angle</span>)};
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">randomPointOnCircle</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → {x: 0.3667, y: 1.966}</span></pre>

<p><a class="p_ident" id="p_a6xMq73yCc" href="#p_a6xMq73yCc" tabindex="-1" role="presentation"></a><code>Math.random</code>은 호출할 때마다 0과 1 사이의 새로운 의사 난수를 반환하는 함수입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_+gqW4B1qk1" href="#c_+gqW4B1qk1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.36993729369714856</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.727367032552138</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.40180766698904335</span></pre>

<p><a class="p_ident" id="p_wukRTlH+QE" href="#p_wukRTlH+QE" tabindex="-1" role="presentation"></a>컴퓨터는 결정론적 기계이지만 동일한 입력이 주어지면 항상 같은 방식으로 반응합니다. 무작위로 나타나는 숫자를 생성하도록 할 수 있습니다. 이를 위해 기계는 숨겨진 값을 유지하고 새로운 난수를 요청할 때마다 이 숨겨진 값에 대해 복잡한 계산을 수행하여 새 값을 생성합니다. 새 값을 저장하고 이 값에서 파생된 일부 숫자를 반환합니다. 그렇게 하면 무작위로 보이는 방식으로 새롭고 예측하기 어려운 숫자를 생성할 수 있습니다.</p>

<p><a class="p_ident" id="p_2guGKjrtTY" href="#p_2guGKjrtTY" tabindex="-1" role="presentation"></a><code>Math.floor</code>는 가장 가까운 정수로 반올림합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_LlfOX4tbSH" href="#c_LlfOX4tbSH" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → 2</span></pre>

<p><a class="p_ident" id="p_qcgl/8YUFj" href="#p_qcgl/8YUFj" tabindex="-1" role="presentation"></a>난수에 10을 곱하면 0보다 크거나 같고 10보다 작은 숫자가 나옵니다. <code>Math.floor</code>은 반올림 하기 때문에 이 표현식은 0에서 9까지의 숫자를 동일한 확률로 생성합니다.</p>

<p><a class="p_ident" id="p_4Vo+PhEiYY" href="#p_4Vo+PhEiYY" tabindex="-1" role="presentation"></a><code>Math.ceil</code>은 가장 가까운 정수를 출력하고, <code>Math.round</code>는 반올림, <code>Math.abs</code>는 절댓값을 제공합니다.</p>

<h2><a class="h_ident" id="h_B372u36cp6" href="#h_B372u36cp6" tabindex="-1" role="presentation"></a>Destructuring</h2>

<p><a class="p_ident" id="p_YaENzwA635" href="#p_YaENzwA635" tabindex="-1" role="presentation"></a>잠시 <code>phi</code> 함수를 살펴보기로 합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_8p90ivE8ZI" href="#c_8p90ivE8ZI" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}</pre>

<p><a class="p_ident" id="p_KYh2WplVnQ" href="#p_KYh2WplVnQ" tabindex="-1" role="presentation"></a>이 함수가 읽기 어려운 이유 중 하나는 배열을 가리키는 바인딩이 있지만 배열의 요소, 즉 <code>let n00 = table[0]</code> 등에 대한 바인딩을 훨씬 선호하기 때문입니다. 다행히 JavaScript에서 이를 수행하는 간결한 방법이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_z2cboTL/zX" href="#c_z2cboTL/zX" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">phi</span>([<span class="cm-def">n00</span>, <span class="cm-def">n01</span>, <span class="cm-def">n10</span>, <span class="cm-def">n11</span>]) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">n11</span> <span class="cm-operator">*</span> <span class="cm-variable-2">n00</span> <span class="cm-operator">-</span> <span class="cm-variable-2">n10</span> <span class="cm-operator">*</span> <span class="cm-variable-2">n01</span>) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">n10</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n11</span>) <span class="cm-operator">*</span> (<span class="cm-variable-2">n00</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n01</span>) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">n01</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n11</span>) <span class="cm-operator">*</span> (<span class="cm-variable-2">n00</span> <span class="cm-operator">+</span> <span class="cm-variable-2">n10</span>));
}</pre>

<p><a class="p_ident" id="p_kBO/cFWeM1" href="#p_kBO/cFWeM1" tabindex="-1" role="presentation"></a>이것은 또한 <code>let</code>, <code>var</code> 또는 <code>const</code>로 만든 바인딩에 관해 작동합니다. 결합되는 값이 배열이라는 것을 알고 있다면 대괄호를 사용하여 값의 내부를 살펴보고 내용을 바인딩할 수 있습니다.</p>

<p><a class="p_ident" id="p_Zr6hFslmUP" href="#p_Zr6hFslmUP" tabindex="-1" role="presentation"></a>대괄호 대신 중괄호를 사용하여 유사한 트릭이 객체에 대해 작동합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ZXEdn9Xbfc" href="#c_ZXEdn9Xbfc" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> {<span class="cm-def">name</span>} <span class="cm-operator">=</span> {<span class="cm-property">name</span>: <span class="cm-string">&quot;Faraji&quot;</span>, <span class="cm-property">age</span>: <span class="cm-number">23</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">name</span>);
<span class="cm-comment">// → Faraji</span></pre>

<p><a class="p_ident" id="p_1RhWeB9//B" href="#p_1RhWeB9//B" tabindex="-1" role="presentation"></a><code>null</code> 또는 <code>undefined</code>로 구조화 하려고 하면 해당 값의 속성에 직접 접근하려고 하는 것과 마찬가지로 오류가 발생합니다.</p>

<h2><a class="h_ident" id="h_AxpOdvCznQ" href="#h_AxpOdvCznQ" tabindex="-1" role="presentation"></a>JSON</h2>

<p><a class="p_ident" id="p_7o8VSa4Rvc" href="#p_7o8VSa4Rvc" tabindex="-1" role="presentation"></a>속성은 값을 포함하지 않고 파악하기만 하기 때문에 객체와 배열은 해당 내용의 주소(메모리의 위치)를 보유하는 비트 수열로 컴퓨터의 메모리에 저장됩니다. 따라서 내부에 다른 배열이 있는 배열은 내부 배열에 대한 하나의 메모리 영역과 내부 배열의 위치를 나타내는 이진수를 포함하는 외부 배열에 대한 다른 메모리 영역으로 구성됩니다.</p>

<p><a class="p_ident" id="p_aF+08iJEQw" href="#p_aF+08iJEQw" tabindex="-1" role="presentation"></a>나중에 데이터를 파일에 저장하거나 네트워크를 통해 다른 컴퓨터로 보내려면 이러한 얽힌 메모리 주소를 저장하거나 보낼 수 있는 설명으로 변환해야 합니다. 관심 있는 값의 주소와 함께 전체 컴퓨터 메모리를 보낼 수는 있지만 가장 좋은 방법은 아닌 것 같습니다.</p>

<p><a class="p_ident" id="p_ZM103Qyv6l" href="#p_ZM103Qyv6l" tabindex="-1" role="presentation"></a>할 수 있는 것은 데이터를 <em>serialize</em>하는 것입니다. 즉, 평면 설명으로의 변환입니다. 널리 사용되는 직렬화 형식을 <em>JSON</em>이라 하며 JavaScript 이외의 언어에서도 웹에서 데이터 저장 및 통신 형식으로 널리 사용됩니다.</p>

<p><a class="p_ident" id="p_IMEKAvSfAI" href="#p_IMEKAvSfAI" tabindex="-1" role="presentation"></a>JSON은 몇 가지 제한 사항이 있지만 JavaScript의 배열 및 객체 작성 방식과 유사합니다. 모든 속성 이름은 큰따옴표로 묶어야 하며 단순한 데이터 표현식만 허용됩니다. 함수 호출, 바인딩 또는 실제 계산과 관련된 어떤 것도 허용되지 않습니다. JSON에서는 주석이 허용되지 않습니다.</p>

<p><a class="p_ident" id="p_9DCLKzKNiz" href="#p_9DCLKzKNiz" tabindex="-1" role="presentation"></a>앞 예의 저널 항목은 JSON 데이터로 표시될 때 다음과 같을 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="application/json" ><a class="c_ident" id="c_A3jdCqz1Q6" href="#c_A3jdCqz1Q6" tabindex="-1" role="presentation"></a>{
  <span class="cm-string cm-property">&quot;squirrel&quot;</span>: <span class="cm-atom">false</span>,
  <span class="cm-string cm-property">&quot;events&quot;</span>: [<span class="cm-string">&quot;work&quot;</span>, <span class="cm-string">&quot;touched tree&quot;</span>, <span class="cm-string">&quot;pizza&quot;</span>, <span class="cm-string">&quot;running&quot;</span>]
}</pre>

<p><a class="p_ident" id="p_1IU60Zh2Af" href="#p_1IU60Zh2Af" tabindex="-1" role="presentation"></a>자바 스크립트는 <code>JSON.stringify</code> 및 <code>JSON.parse</code>와 같은 함수를 통해 이러한 형식의 데이터 변환을 가능하도록 합니다. 첫 번째는 JavaScript 값을 가져와 JSON으로 인코딩된 문자열을 반환합니다. 두 번째는 이러한 문자열을 가져와서 인코딩한 값으로 변환합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HYCgCsK7z1" href="#c_HYCgCsK7z1" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
                             <span class="cm-property">events</span>: [<span class="cm-string">&quot;weekend&quot;</span>]});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>);
<span class="cm-comment">// → {&quot;squirrel&quot;:false,&quot;events&quot;:[&quot;weekend&quot;]}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">string</span>).<span class="cm-property">events</span>);
<span class="cm-comment">// → [&quot;weekend&quot;]</span></pre>

<h2><a class="h_ident" id="h_ErccPg/l98" href="#h_ErccPg/l98" tabindex="-1" role="presentation"></a>요약</h2>

<p><a class="p_ident" id="p_78ZfHX5x1B" href="#p_78ZfHX5x1B" tabindex="-1" role="presentation"></a>객체와 배열(특정 종류의 객체)은 여러 값을 단일 값으로 그룹화하는 방법을 제공합니다. 개념적으로 이것은 개별 사물을 팔로 감싸서 따로따로 잡으려고 하는 대신 가방에 관련된 많은 것을 넣고 가방을 가지고 돌아다닐 수 있도록 합니다.</p>

<p><a class="p_ident" id="p_ayhyxvWlMH" href="#p_ayhyxvWlMH" tabindex="-1" role="presentation"></a>JavaScript의 대부분의 값에는 속성이 있으며 예외는 <code>null</code>과 <code>undefined</code>입니다. 속성은 <code>value.prop</code> 또는 <code>value[&quot;prop&quot;]</code>를 사용하여 접근할 수 있습니다. 객체는 속성에 이름을 사용하고 고정된 집합을 저장하는 경향이 있습니다. 반면에 배열은 일반적으로 개념적으로 동일한 값을 다양하게 포함하며 속성 이름으로 숫자(0부터 시작)를 사용합니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<h3><a class="i_ident" id="i_8ZspxiCEC/" href="#i_8ZspxiCEC/" tabindex="-1" role="presentation"></a>범위 합</h3>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_KTbQMmMCli" href="#c_KTbQMmMCli" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>

<p><a class="p_ident" id="p_uTMnVb6I1m" href="#p_uTMnVb6I1m" tabindex="-1" role="presentation"></a>두 인수 <code>start</code>와 <code>end</code>을 받아 <code>start</code>에서 <code>end</code>에 이르는 모든 수들을 포함하는 배열을 반환하는 <code>range</code>를 작성하라.</p>

<p><a class="p_ident" id="p_0GiJNcBSop" href="#p_0GiJNcBSop" tabindex="-1" role="presentation"></a>다음으로, 숫자 배열을 취하여 이 숫자의 합을 반환하는 함수 <code>sum</code>을 작성하라. 예 프로그램을 실행하고 실제로 55를 반환하는지 확인하십시오.</p>

<p><a class="p_ident" id="p_1Uvf7bfQT8" href="#p_1Uvf7bfQT8" tabindex="-1" role="presentation"></a>배열을 빌드할 때 사용되는 "단계" 값을 나타내는 선택적인 세 번째 인수를 사용하도록 <code>range</code> 함수를 수정합니다. 단계가 지정되지 않은 경우 요소는 이전 동작에 따라 하나씩 증가합니다. 함수 호출 <code>range(1, 10, 2)</code>은 <code>[1, 3, 5, 7, 9]</code>를 반환해야 합니다. <code>range(5, 2, -1)</code>가 <code>[5, 4, 3, 2]</code>를 생성하도록 음수 단계 값에서도 작동하는지 확인하십시오.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_gV3XCKJAqj" href="#c_gV3XCKJAqj" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">5</span>, <span class="cm-number">2</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → [5, 4, 3, 2]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));
<span class="cm-comment">// → 55</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_AzWVqPrlre" href="#p_AzWVqPrlre" tabindex="-1" role="presentation"></a>배열을 구축하는 것은 먼저 <code>[]</code>로 (새롭고 빈 배열) 결합시켜 초기화하고 반복적으로 <code>push</code> 메서드를 호출하여 값을 추가하는 방식으로 가장 쉽게 수행됩니다. 함수 끝에 배열을 반환하는 것을 잊지 마십시오.</p>

<p><a class="p_ident" id="p_eu6MUPwjEb" href="#p_eu6MUPwjEb" tabindex="-1" role="presentation"></a>끝 경계가 포함 되므로 루프의 끝을 확인하는데 <code>&lt;</code> 대신에 연산자 <code>&lt;=</code>를 사용해야 합니다.</p>

<p><a class="p_ident" id="p_kvr5NnqBEW" href="#p_kvr5NnqBEW" tabindex="-1" role="presentation"></a>step 매개변수는 기본값(<code>=</code> 연산자를 사용하여)이 1인 선택적 매개변수일 수 있습니다.</p>

<p><a class="p_ident" id="p_zih2wFkrk5" href="#p_zih2wFkrk5" tabindex="-1" role="presentation"></a>음수 단계는 두 개의 개별 루프를 작성하여 가장 잘 수행할 수 있습니다. 하나는 카운트 업용이고 다른 하나는 카운트 다운용입니다. 루프가 완료되었는지 확인하는 비교는 <code>&lt;=</code> 대신에 <code>&gt;=</code>를 사용합니다.</p>

<p><a class="p_ident" id="p_d7Vi2uDSps" href="#p_d7Vi2uDSps" tabindex="-1" role="presentation"></a>범위의 끝이 시작보다 작은 경우 다른 기본 단계, 즉 -1을 사용하는 것도 좋습니다. 그렇게 하면 <code>range(5, 2)</code>는 무한 루프에 빠지지 않고 의미 있는 것을 반환합니다. 매개변수의 기본값에서 이전 매개변수를 참조할 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_6xTmjj4Rf5" href="#i_6xTmjj4Rf5" tabindex="-1" role="presentation"></a>배열 반전</h3>

<p><a class="p_ident" id="p_+SVCOC/qcN" href="#p_+SVCOC/qcN" tabindex="-1" role="presentation"></a>배열 원소들을 역으로 출력하기 위해서는 <code>reverse</code> 메서드를 사용할 수 있습니다. 이를 위해서 두 가지 함수 <code>reverseArray</code>와 <code>reverseArrayInPlace</code>를 작성해야 합니다. 첫 번째 <code>reverseArray</code>는 인수로 배열을 취하고 역 순서로 같은 원소들을 갖는 새로운 배열을 생성하도록 합니다. 두 번째로 <code>reverseArrayInPlace</code>는 <code>reverse</code> 메서드가 해야 하는 것을 나타냅니다. 원소들을 반전시키는 방식으로 인수로 주어진 배열을 변경시킵니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_sghv5avX0H" href="#c_sghv5avX0H" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverseArray</span>([<span class="cm-string">&quot;A&quot;</span>, <span class="cm-string">&quot;B&quot;</span>, <span class="cm-string">&quot;C&quot;</span>]));
<span class="cm-comment">// → [&quot;C&quot;, &quot;B&quot;, &quot;A&quot;];</span>
<span class="cm-keyword">let</span> <span class="cm-def">arrayValue</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>];
<span class="cm-variable">reverseArrayInPlace</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-comment">// → [5, 4, 3, 2, 1]</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_bJlW8Cyw1e" href="#p_bJlW8Cyw1e" tabindex="-1" role="presentation"></a><code>reverseArray</code>를 구현하는 두 가지 방식이 있는데, 첫 번째는 단순히 앞에서 뒤로 입력 배열을 진행하면서 start에 각 원소 삽입을 위해 <code>unshift</code>를 사용하는 것입니다. 두 번째는 역 방향으로 입력 배열을 순회하면서 <code>push</code> 메서드를 사용하는 것입니다. 역 방향 배열 순회는 (somewhat awkward) <code>for</code> 사용을 필요로 합니다(<code>(let i = array.<wbr>length - 1; i &gt;= 0; i--)</code>처럼).</p>

<p><a class="p_ident" id="p_Y08sN3Yej5" href="#p_Y08sN3Yej5" tabindex="-1" role="presentation"></a>제자리에서 배열 반전은 보금 더 복잡합니다. 나중에 필요할 요소를 덮어쓰지 않도록 주의해야 합니다. <code>reverseArray</code>를 사용하거나 또는 전체 배열 복사는(<code>array.slice(0)</code>는 배열 복사의 좋은 방식) 작동하지만 일종의 트릭입니다.</p>

<p><a class="p_ident" id="p_hzYSkS4zzl" href="#p_hzYSkS4zzl" tabindex="-1" role="presentation"></a>첫 번째 요소와 마지막 요소를 바꾸는 방식의 트릭을 사용할 수도 있습니다. 배열의 절반 길이에 걸쳐 반복하여 이 작업을 수행할 수 있습니다.</p>

</div></div>

<h3 id="list"><a class="i_ident" id="i_nSTX34CM1M" href="#i_nSTX34CM1M" tabindex="-1" role="presentation"></a>리스트</h3>

<p><a class="p_ident" id="p_7AnSuS26HF" href="#p_7AnSuS26HF" tabindex="-1" role="presentation"></a>값의 일반적인 얼룩이라 할 수 있는 객체는 모든 종류의 데이터 구조를 구축하는 데 사용할 수 있습니다. 일반적인 데이터 구조는 <em>list</em>입니다(배열과 혼동하지 마십시오). 리스트는 중첩된 객체 집합으로, 첫 번째 객체는 두 번째 객체에 대한 참조를, 두 번째 객체는 세 번째 객체에 대한 참조를 보유하는 식입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kYAco70aHD" href="#c_kYAco70aHD" tabindex="-1" role="presentation"></a><span class="cm-keyword">let</span> <span class="cm-def">list</span> <span class="cm-operator">=</span> {
  <span class="cm-property">value</span>: <span class="cm-number">1</span>,
  <span class="cm-property">rest</span>: {
    <span class="cm-property">value</span>: <span class="cm-number">2</span>,
    <span class="cm-property">rest</span>: {
      <span class="cm-property">value</span>: <span class="cm-number">3</span>,
      <span class="cm-property">rest</span>: <span class="cm-atom">null</span>
    }
  }
};</pre>

<p><a class="p_ident" id="p_2un5u6U14Q" href="#p_2un5u6U14Q" tabindex="-1" role="presentation"></a>결과 객체는 다음과 같이 체인을 형성합니다.</p><figure><img src="img/linked-list.svg" alt="A linked list"></figure>

<p><a class="p_ident" id="p_NaI0fhp38z" href="#p_NaI0fhp38z" tabindex="-1" role="presentation"></a>리스트의 좋은 점은 구조의 일부를 공유할 수 있다는 것입니다. 예를 들어 두 개의 새 값을 <code>{value: 0, rest: list}</code>와 <code>{value: -1, rest: list}</code>로 생성하면(앞서 정의한 바인딩을 참조하는 <code>list</code>를 갖는), 두 값은 모두 독립적인 리스트이지만 마지막 세 요소를 구성하는 구조를 공유합니다. 원래 리스트도 여전히 유효한 3개 요소 리스트입니다.</p>

<p><a class="p_ident" id="p_iPlgVCeZGh" href="#p_iPlgVCeZGh" tabindex="-1" role="presentation"></a>인수로 <code>[1, 2, 3]</code>이 주어졌을 때 보이는 것과 같은 리스트 구조를 만드는 함수 <code>arrayToList</code>를 작성합니다. 또한 리스트에서 배열을 생성하는 <code>listToArray</code> 함수를 작성합니다. 그런 다음 요소와 리스트를 가져와서 입력 리스트의 앞에 요소를 추가하여 새 리스트를 만드는 도우미 함수 <code>prepend</code>를 추가하고 리스트와 숫자를 가져와 리스트의 지정된 위치에 요소를 반환하거나(첫 번째 요소를 참조하는 0을 갖는) 그러한 요소가 없을 때 <code>undefined</code>를 반환하는 <code>nth</code> 함수를 만듭니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_rufmukl+AQ" href="#c_rufmukl+AQ" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>]));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listToArray</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>])));
<span class="cm-comment">// → [10, 20, 30]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">prepend</span>(<span class="cm-number">10</span>, <span class="cm-variable">prepend</span>(<span class="cm-number">20</span>, <span class="cm-atom">null</span>)));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">nth</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>]), <span class="cm-number">1</span>));
<span class="cm-comment">// → 20</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_gUGYq9Tjlx" href="#p_gUGYq9Tjlx" tabindex="-1" role="presentation"></a>리스트 작성은 뒤에서 앞으로 수행할 때 더 쉽습니다. 따라서 <code>arrayToList</code>는 배열을 역방향으로 반복하고 각 요소에 대해 리스트에 객체를 추가할 수 있습니다. 로컬 바인딩을 사용하여 지금까지 작성된 리스트 일부를 보유하고 요소를 추가 하기 위해 <code>list = {value: X, rest: list}</code>와 같은 배정을 사용합니다.</p>

<p><a class="p_ident" id="p_+rJULr60CD" href="#p_+rJULr60CD" tabindex="-1" role="presentation"></a>리스트 실행과 관련하여(<code>listToArray</code> 및 <code>nth</code>에서), 다음과 같은 <code>for</code> 루프를 사용할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HLrOQGihFR" href="#c_HLrOQGihFR" tabindex="-1" role="presentation"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">list</span>; <span class="cm-variable">node</span>; <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">node</span>.<span class="cm-property">rest</span>) {}</pre>

<p><a class="p_ident" id="p_ASUOjWBRh5" href="#p_ASUOjWBRh5" tabindex="-1" role="presentation"></a><code>n번째</code> 순환은 유사하게 리스트 끝의 보다 작은 부분을 살피게 되고 동시에 0에 도달할 때까지 카운트 다운 되어 조사 중인 노드의 <code>value</code> 속성을 반환합니다. 리스트의 0번째 원소를 취하기 위해서는 단순히 헤드 노드의 <code>value</code> 속성을 취하면 됩니다. <em>N</em>+1번째 원소를 취하기 위해서는 현재 리스트의 <code>rest</code> 속성에 있는 리스트의 <em>N</em>t번째 원소를 취합니다.</p>

</div></div>

<h3 id="exercise_deep_compare"><a class="i_ident" id="i_IJBU+aXOIC" href="#i_IJBU+aXOIC" tabindex="-1" role="presentation"></a>심층 비교</h3>

<p><a class="p_ident" id="p_xTwbRlqHNJ" href="#p_xTwbRlqHNJ" tabindex="-1" role="presentation"></a><code>==</code> 연산자는 identity를 통해 객체를 비교하지만 때로는 실제 속성의 값을 비교하고 싶을 때가 있습니다.</p>

<p><a class="p_ident" id="p_DwdnLiD0pC" href="#p_DwdnLiD0pC" tabindex="-1" role="presentation"></a>두 값을 취해 같은 값이 있거나 또는 같은 속성들을 갖는 객체가 있으면 true를 반환하는 <code>deepEqual</code> 함수를 작성합니다. 여기서 속성의 값들은 <code>deepEqual</code>의 순환 호출로 비교됩니다.</p>

<p><a class="p_ident" id="p_Znb46HKrMg" href="#p_Znb46HKrMg" tabindex="-1" role="presentation"></a>값을 직접 비교해야 하는지(<code>===</code> 연산자 사용) 또는 해당 속성을 비교해야 하는지 알아보려면 <code>typeof</code> 연산자를 사용할 수 있습니다. 두 값 모두에 대해 <code>&quot;object&quot;</code>를 생성하는 경우 심층 비교를 수행해야 합니다. 그러나 한 가지 예외를 고려해야 합니다. <code>typeof null</code> 또한 <code>&quot;object&quot;</code>을 생성합니다.</p>

<p><a class="p_ident" id="p_n9AoXEbeFg" href="#p_n9AoXEbeFg" tabindex="-1" role="presentation"></a><code>Object.keys</code> 함수는 비교를 위해 객체 속성들에 관해 진행할 때 유용합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kWPN5i/Y3x" href="#c_kWPN5i/Y3x" tabindex="-1" role="presentation"></a><span class="cm-comment">// 여기에 코드 작성</span>

<span class="cm-keyword">let</span> <span class="cm-def">obj</span> <span class="cm-operator">=</span> {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">&quot;an&quot;</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, <span class="cm-variable">obj</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: <span class="cm-number">1</span>, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">&quot;an&quot;</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → true</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_t3z+oosxP9" href="#p_t3z+oosxP9" tabindex="-1" role="presentation"></a>실제 개체를 다루고 있는지 여부에 대한 테스트로 <code>typeof x == &quot;object&quot; &amp;&amp; x != null</code>와 같은 것을 볼 수 있을 것입니다. 두 인수가 모두 객체인 경우에만 속성을 비교하도록 주의하십시오. 다른 모든 경우에는 <code>===</code>의 적용 결과를 즉시 반환할 수 있습니다.</p>

<p><a class="p_ident" id="p_csfrgdVrEd" href="#p_csfrgdVrEd" tabindex="-1" role="presentation"></a><code>Object.keys</code> 속성을 통해 이동합니다. 두 객체에 동일한 속성 이름 집합이 있는지 여부와 해당 속성에 동일한 값이 있는지 여부를 테스트 해야 합니다. 그렇게 하는 한 가지 방법은 두 객체가 동일한 수의 속성을 갖도록 하는 것입니다(속성 리스트 길이가 동일함). 그런 다음 객체의 속성 중 하나를 반복하여 비교할 때 항상 먼저 다른 객체에 실제로 해당 이름의 속성이 있는지 확인하십시오. 동일한 수의 속성이 있고 한 속성의 모든 속성이 다른 속성에도 존재하는 경우 속성 이름 집합이 동일합니다.</p>

<p><a class="p_ident" id="p_ECXa1sWg6+" href="#p_ECXa1sWg6+" tabindex="-1" role="presentation"></a>함수에서 올바른 값을 반환하는 것은 불일치가 발견되면 즉시 false를 반환하고 함수가 끝날 때 true를 반환하는 경우입니다.</p>

</div></div><nav><a href="03_functions.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="05_higher_order.html" title="next chapter">▶</a></nav>
</article>
