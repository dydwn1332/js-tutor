<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>픽셀 아트 편집기</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 19;var sandboxLoadFiles = ["code/chapter/19_paint.js"];</script></head>

<article>
<nav><a href="18_http.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="20_node.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>19</span>픽셀 아트 편집기</h1>

<blockquote>

<p><a class="p_ident" id="p_S+jzRBETBQ" href="#p_S+jzRBETBQ" tabindex="-1" role="presentation"></a>나는 내 앞에 있는 많은 색을 본다. 나는 내 빈 캔버스를 본다. 그런 다음 음악을 형성하는 음표처럼 시를 형성하는 단어와 같은 색상을 적용하려고 합니다.</p>

<footer>Joan Miro</footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_19.jpg" alt="Picture of a tiled mosaic"></figure>

<p><a class="p_ident" id="p_1emWaHj7VO" href="#p_1emWaHj7VO" tabindex="-1" role="presentation"></a>여기에서 소개되는 응용 프로그램은 픽셀 그리기 프로그램입니다. 여기에서 색상이 지정된 사각형의 격자로 표시된 확대 보기를 조작하여 그림을 픽셀 단위로 수정할 수 있습니다. 프로그램을 사용하여 이미지 파일을 열고 마우스나 다른 포인터 장치로 이미지 파일에 낙서를 하고 저장할 수 있습니다. 다음과 같이 표시됩니다.</p><figure><img src="img/pixel_editor.png" alt="The pixel editor interface, with colored pixels at the top and a number of controls below that"></figure>

<p><a class="p_ident" id="p_oDwL9FxPW8" href="#p_oDwL9FxPW8" tabindex="-1" role="presentation"></a>컴퓨터로 그림을 그리는 것은 훌륭합니다. 재료, 기술 또는 재능에 대해 걱정할 필요가 없습니다. 바르기 시작하면 됩니다.</p>

<h2><a class="h_ident" id="h_kolHPu7a7g" href="#h_kolHPu7a7g" tabindex="-1" role="presentation"></a>구성 요소</h2>

<p><a class="p_ident" id="p_FdzFEXmy5/" href="#p_FdzFEXmy5/" tabindex="-1" role="presentation"></a>응용 프로그램의 인터페이스는 맨 위에 큰 <code>&lt;canvas&gt;</code> 요소를 표시하고 그 아래에 여러 양식 필드를 표시합니다. 사용자는 <code>&lt;select&gt;</code> 필드에서 도구를 선택한 다음 캔버스를 클릭, 터치 또는 드래그 하여 그림을 그립니다. 단일 픽셀 또는 직사각형을 그리고 영역을 채우고 그림에서 색상을 선택하는 도구가 있습니다.</p>

<p><a class="p_ident" id="p_NhRI/7J4/9" href="#p_NhRI/7J4/9" tabindex="-1" role="presentation"></a>DOM의 부분 관련 책임이 있고 그것들 내에 다른 구성 요소들을 포함하는 객체들인 <em>components</em>의 넘버로 편집기 인터페이스를 구성할 것입니다.</p>

<p><a class="p_ident" id="p_fkKmP4oVNw" href="#p_fkKmP4oVNw" tabindex="-1" role="presentation"></a>응용 프로그램의 상태는 현재 그림, 선택한 도구 및 선택한 색상으로 구성됩니다. 상태가 단일 값에 있고 인터페이스 구성 요소가 항상 현재 상태를 기준으로 표시되도록 설정할 것입니다.</p>

<p><a class="p_ident" id="p_vdd3n7kKQ+" href="#p_vdd3n7kKQ+" tabindex="-1" role="presentation"></a>이것이 왜 중요한지 알아보기 위해 인터페이스 전체에 상태 조각을 배포하는 대안을 고려해 보겠습니다. 특정 시점까지는 프로그래밍하기가 더 쉽습니다. 현재 색상을 알아야 할 때 색상 필드를 입력하고 값을 읽을 수 있습니다.</p>

<p><a class="p_ident" id="p_DT4dS+wk+p" href="#p_DT4dS+wk+p" tabindex="-1" role="presentation"></a>그런 다음 색상 선택 도구를 추가합니다. 이 도구를 사용하면 사진을 클릭하여 주어진 픽셀의 색상을 선택할 수 있습니다. 올바른 색상을 표시하는 색상 필드를 유지하려면 해당 도구는 색상 필드가 존재함을 알고 새 색상을 선택할 때마다 업데이트해야 합니다. 색상을 보이게 하는 다른 위치를 추가한 경우(마우스 커서가 색상을 표시할 수 있음) 동기화된 상태를 유지하려면 색상 변경 코드를 업데이트해야 합니다.</p>

<p><a class="p_ident" id="p_V/rEZY0rXG" href="#p_V/rEZY0rXG" tabindex="-1" role="presentation"></a>실제로 이것은 인터페이스의 각 부분이 모듈화되지 않은 다른 모든 부분에 대해 알아야 하는 문제를 만듭니다. 이 장의 것과 같은 작은 응용 프로그램의 경우 문제가 되지 않을 수 있습니다. 더 큰 프로젝트의 경우 실제 악몽으로 바뀔 수 있습니다.</p>

<p><a class="p_ident" id="p_g1VVb9/ySC" href="#p_g1VVb9/ySC" tabindex="-1" role="presentation"></a>원칙적으로 이러한 악몽을 피하기 위해 <em>data flow</em>에 대해 엄격할 것입니다. 상태가 있고 그 상태에 따라 인터페이스가 그려집니다. 인터페이스 구성 요소는 상태를 업데이트하여 사용자 작업에 응답할 수 있습니다. 이 시점에서 구성 요소는 이 새로운 상태와 동기화할 기회를 얻습니다.</p>

<p><a class="p_ident" id="p_snbNYCWNLn" href="#p_snbNYCWNLn" tabindex="-1" role="presentation"></a>실제로 각 구성 요소는 새 상태가 지정되면 업데이트해야 하는 한 자식 구성 요소에도 알리도록 설정됩니다. 이것을 설정하는 것은 약간의 번거로움입니다. 이것을 더 편리하게 만드는 것은 많은 브라우저 프로그래밍 라이브러리의 주요 판매 포인트입니다. 그러나 이와 같은 소규모 응용 프로그램의 경우 이러한 인프라 없이 할 수 있습니다.</p>

<p><a class="p_ident" id="p_lPz3O+BIo4" href="#p_lPz3O+BIo4" tabindex="-1" role="presentation"></a>상태에 대한 업데이트는 객체로 표시되며 이를 <em>actions</em>라 합니다. 구성 요소는 작업을 생성하고 <em>dispatch</em> 할 수 있습니다. 이 함수는 다음 상태를 계산한 후 인터페이스 구성 요소가 이 새로운 상태로 업데이트됩니다.</p>

<p><a class="p_ident" id="p_5gofo0W3xD" href="#p_5gofo0W3xD" tabindex="-1" role="presentation"></a>사용자 인터페이스를 실행하고 그것에 일부 구조를 적용하는 지저분한 작업을 수행하고 있습니다. DOM 관련 부분은 여전히 부작용으로 가득 차 있지만 개념적으로 간단한 백본인 상태 업데이트 주기에 의해 유지됩니다. 상태는 DOM의 모양을 결정하며 DOM 이벤트가 상태를 변경할 수 있는 유일한 방법은 상태에 작업을 전달하는 것입니다.</p>

<p><a class="p_ident" id="p_/EcvUcHPZo" href="#p_/EcvUcHPZo" tabindex="-1" role="presentation"></a>이 접근 방식에는 여러 가지 변형이 있으며 각각 고유한 이점과 문제가 있지만 핵심 아이디어는 동일합니다. 상태 변경은 모든 곳에서 발생하는 것이 아니라 잘 정의된 단일 채널을 통해 이루어져야 합니다.</p>

<p><a class="p_ident" id="p_x8WZeXxSe3" href="#p_x8WZeXxSe3" tabindex="-1" role="presentation"></a>구성 요소는 인터페이스를 준수하는 클래스가 될 것입니다. 생성자는 상태를 (전체 애플리케이션 상태일 수 있거나 모든 것에 액세스할 필요가 없는 경우 더 작은 값일 수 있음) 제공하고 이를 사용하여 <code>dom</code> 속성을 구축합니다. 구성 요소를 나타내는 DOM 요소입니다. 대부분의 생성자는 작업을 전달하는 데 사용할 수 있는 함수와 같이 시간이 지남에 따라 변경되지 않는 다른 값도 사용합니다.</p>

<p><a class="p_ident" id="p_//+fikMSC2" href="#p_//+fikMSC2" tabindex="-1" role="presentation"></a>각 구성 요소는 새 상태 값과 동기화하는 데 사용되는 <code>syncState</code> 메서드가 있습니다. 이 메서드는 생성자에 대한 첫 번째 인수와 동일한 타입인 상태라는 하나의 인수를 사용합니다.</p>

<h2><a class="h_ident" id="h_ftf/mS/U0E" href="#h_ftf/mS/U0E" tabindex="-1" role="presentation"></a>상태</h2>

<p><a class="p_ident" id="p_bfnMVWQbM8" href="#p_bfnMVWQbM8" tabindex="-1" role="presentation"></a>응용 프로그램 상태는 <code>picture</code>, <code>tool</code> 및 <code>color</code> 속성들을 갖는 객체입니다. 픽셀은 6장의 행렬 클래스와 같은 방식으로 배열에 저장됩니다. 즉, 위에서 아래로 행 단위로 저장됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_FaXS4E1Q9/" href="#c_FaXS4E1Q9/" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">Picture</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">width</span>, <span class="cm-def">height</span>, <span class="cm-def">pixels</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">height</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">pixels</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pixels</span>;
  }
  <span class="cm-keyword">static</span> <span class="cm-property">empty</span>(<span class="cm-def">width</span>, <span class="cm-def">height</span>, <span class="cm-def">color</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">pixels</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Array</span>(<span class="cm-variable-2">width</span> <span class="cm-operator">*</span> <span class="cm-variable-2">height</span>).<span class="cm-property">fill</span>(<span class="cm-variable-2">color</span>);
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Picture</span>(<span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>, <span class="cm-variable-2">pixels</span>);
  }
  <span class="cm-property">pixel</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
    <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">pixels</span>[<span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span>];
  }
  <span class="cm-property">draw</span>(<span class="cm-def">pixels</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">copy</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pixels</span>.<span class="cm-property">slice</span>();
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> {<span class="cm-def">x</span>, <span class="cm-def">y</span>, <span class="cm-def">color</span>} <span class="cm-keyword">of</span> <span class="cm-variable-2">pixels</span>) {
      <span class="cm-variable-2">copy</span>[<span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    }
    <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Picture</span>(<span class="cm-keyword">this</span>.<span class="cm-property">width</span>, <span class="cm-keyword">this</span>.<span class="cm-property">height</span>, <span class="cm-variable-2">copy</span>);
  }
}</pre>

<p><a class="p_ident" id="p_gEQNun84hI" href="#p_gEQNun84hI" tabindex="-1" role="presentation"></a>그림을 변경할 수 없는 값으로 취급할 수 있기를 원합니다. 이유는 이 장의 뒷부분에서 다시 다룰 것입니다. 그러나 때로는 한 번에 전체 픽셀을 업데이트해야 합니다. 그렇게 할 수 있도록 클래스에는 업데이트된 픽셀의 배열을 (<code>x</code>, <code>y</code> 및 <code>color</code>) 예상하고 해당 픽셀을 덮어쓰는 새 그림을 만드는 <code>draw</code> 메서드가 있습니다. 이 메서드는 인수 없이 <code>slice</code>를 사용하여 전체 픽셀 배열을 복사합니다. 슬라이스의 시작은 기본적으로 0이고 끝은 기본적으로 배열의 길이입니다.</p>

<p><a class="p_ident" id="p_WuI3QLNiPA" href="#p_WuI3QLNiPA" tabindex="-1" role="presentation"></a><code>empty</code> 메서드는 이전에 본 적이 없는 두 가지 배열 함수를 사용합니다. <code>Array</code> 생성자는 주어진 길이의 빈 배열을 생성하기 위해 넘버로 호출할 수 있습니다. <code>fill</code> 메서드는 주어진 값으로 배열을 채우기 위해 사용될 수 있습니다. 이것들은 모든 픽셀이 동일한 색상을 갖는 배열을 만드는 데 사용됩니다.</p>

<p><a class="p_ident" id="p_06+YtnEEH5" href="#p_06+YtnEEH5" tabindex="-1" role="presentation"></a>색상은 해시 기호(<code>#</code>) 다음에 6개의 16진수 숫자로 구성된 기존 CSS 색상 코드를 포함하는 문자열로 저장됩니다. 2개는 빨간색 구성요소, 2개는 녹색 구성요소, 2개는 파란색 구성요소입니다. 색상을 작성하는 다소 애매하고 불편한 방법이지만 HTML 색상 입력 필드가 사용하는 형식이며 캔버스 그리기 컨텍스트의 속성 <code>fillStyle</code>에서 사용할 수 있으므로 이 프로그램에서 색상을 사용하는 방법에 대해 충분히 실용적입니다.</p>

<p><a class="p_ident" id="p_EsZKxAfcSW" href="#p_EsZKxAfcSW" tabindex="-1" role="presentation"></a>모든 요소가 0인 검정은 <code>&quot;#000000&quot;</code>로 작성되고, 밝은 핑크 색은 <code>&quot;#ff00ff&quot;</code>입니다. 여기서 red와 blue 구성 요소는 255의 최대 값을 가지며 16진수 <code>ff</code>를 사용합니다.</p>

<p><a class="p_ident" id="p_gcI/Yem+Yv" href="#p_gcI/Yem+Yv" tabindex="-1" role="presentation"></a>인터페이스가 이전 상태의 속성을 덮어쓰는 속성을 가진 객체로 작업을 전달하도록 허용합니다. 색상 필드는 사용자가 변경할 때 이러한 업데이트 함수가 새 상태를 계산할 수 있는 <code>{color: field.<wbr>value}</code>와 같은 객체를 전달할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_0xovfSx+PU" href="#c_0xovfSx+PU" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">updateState</span>(<span class="cm-def">state</span>, <span class="cm-def">action</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>({}, <span class="cm-variable-2">state</span>, <span class="cm-variable-2">action</span>);
}</pre>

<p><a class="p_ident" id="p_nJ9Pa/72hN" href="#p_nJ9Pa/72hN" tabindex="-1" role="presentation"></a>먼저 <code>state</code> 속성에 빈 객체를 추가한 다음 <code>action</code>의 속성으로 일부를 덮어쓰는데 <code>Object.assign</code>이 사용됩니다. 다소 번거로운 이러한 패턴은 변경할 수 없는 객체를 사용하는 JavaScript 코드에서 일반적입니다. 이에 대한 보다 편리한 표기법은 삼중점 연산자를 사용하여 다른 객체의 모든 속성을 객체 표현식에 포함하는 것으로 최종 표준화 단계에 있습니다. 그러한 추가와 함께 <code>{.<wbr>.<wbr>.<wbr>state, .<wbr>.<wbr>.<wbr>action}</code>를 쓸 수 있습니다.</p>

<h2><a class="h_ident" id="h_sNxHTHiM3l" href="#h_sNxHTHiM3l" tabindex="-1" role="presentation"></a>DOM 구축</h2>

<p><a class="p_ident" id="p_pW7WuvagbQ" href="#p_pW7WuvagbQ" tabindex="-1" role="presentation"></a>인터페이스 구성 요소가 하는 주요 작업 중 하나는 DOM 구조를 만드는 것입니다. 이를 위해 장황한 DOM 메서드를 직접 사용하고 싶지 않으므로 여기에 <code>elt</code> 함수의 약간 확장된 버전이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bpc/osm9kD" href="#c_bpc/osm9kD" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">elt</span>(<span class="cm-def">type</span>, <span class="cm-def">props</span>, <span class="cm-meta">...</span><span class="cm-def">children</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">type</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">props</span>) <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>(<span class="cm-variable-2">dom</span>, <span class="cm-variable-2">props</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">child</span> <span class="cm-keyword">of</span> <span class="cm-variable-2">children</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;string&quot;</span>) <span class="cm-variable-2">dom</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
    <span class="cm-keyword">else</span> <span class="cm-variable-2">dom</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>));
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">dom</span>;
}</pre>

<p><a class="p_ident" id="p_BpQHRZu5+n" href="#p_BpQHRZu5+n" tabindex="-1" role="presentation"></a>이러한 버전과 16장에서 사용된 버전과의 하나의 주요 차이점은 DOM 노드들에 <em>attributes</em>가 아닌 <em>properties</em>를 할당한다는 것입니다. 이것은 임의의 속성들을 설정하는데 사용할 수는 없지만, <code>onclick</code>과 같이 값이 문자열이 아닌 속성들을 설정할 수 있다는 것입니다.</p>

<p><a class="p_ident" id="p_ZshAZr+fAT" href="#p_ZshAZr+fAT" tabindex="-1" role="presentation"></a>이를 통해 다음과 같은 이벤트 처리기를 등록할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_UrXW9qBNM+" href="#c_UrXW9qBNM+" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">&quot;button&quot;</span>, {
      <span class="cm-property">onclick</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;click&quot;</span>)
    }, <span class="cm-string">&quot;The button&quot;</span>));
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_amGIg81orI" href="#h_amGIg81orI" tabindex="-1" role="presentation"></a>canvas</h2>

<p><a class="p_ident" id="p_BmCCXvkmPk" href="#p_BmCCXvkmPk" tabindex="-1" role="presentation"></a>정의할 첫 번째 구성 요소는 그림을 색상 상자의 격자로 표시하는 인터페이스 부분입니다. 이 구성 요소는 그림을 표시하고 해당 그림에 대한 포인터 이벤트를 나머지 응용 프로그램에 전달하는 두 가지 작업을 담당합니다.</p>

<p><a class="p_ident" id="p_A/ZPezFryZ" href="#p_A/ZPezFryZ" tabindex="-1" role="presentation"></a>따라서 전체 응용 프로그램 상태가 아닌 현재 그림만 아는 구성 요소로 정의할 수 있습니다. 애플리케이션 전체가 어떻게 작동하는지 모르기 때문에 액션을 직접 전달할 수 없습니다. 오히려 포인터 이벤트에 응답할 때 이를 생성한 코드에서 제공하는 콜백 함수를 호출하여 애플리케이션별 부분을 처리합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_uknkIx/3Hs" href="#c_uknkIx/3Hs" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">scale</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;

<span class="cm-keyword">class</span> <span class="cm-def">PictureCanvas</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">picture</span>, <span class="cm-def">pointerDown</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;canvas&quot;</span>, {
      <span class="cm-property">onmousedown</span>: <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">mouse</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">pointerDown</span>),
      <span class="cm-property">ontouchstart</span>: <span class="cm-def">event</span> <span class="cm-operator">=&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">touch</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">pointerDown</span>)
    });
    <span class="cm-keyword">this</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">picture</span>);
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">picture</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">==</span> <span class="cm-variable-2">picture</span>) <span class="cm-keyword">return</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>;
    <span class="cm-variable">drawPicture</span>(<span class="cm-keyword">this</span>.<span class="cm-property">picture</span>, <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>, <span class="cm-variable">scale</span>);
  }
}</pre>

<p><a class="p_ident" id="p_GUKkdM8Vr3" href="#p_GUKkdM8Vr3" tabindex="-1" role="presentation"></a><code>scale</code> 상수에 의해 결정된 대로 각 픽셀을 10x10 정사각형으로 그립니다. 불필요한 작업을 피하기 위해 구성 요소는 현재 그림을 추적하고 <code>syncState</code>가 새 그림을 제공할 때만 다시 그리기를 수행합니다.</p>

<p><a class="p_ident" id="p_+vW5Ci/vvJ" href="#p_+vW5Ci/vvJ" tabindex="-1" role="presentation"></a>실제 그리기 함수는 배율과 그림 크기를 기반으로 캔버스의 크기를 설정하고 각 픽셀에 하나씩 일련의 사각형으로 채웁니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_kMF9hx2xSw" href="#c_kMF9hx2xSw" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">drawPicture</span>(<span class="cm-def">picture</span>, <span class="cm-def">canvas</span>, <span class="cm-def">scale</span>) {
  <span class="cm-variable-2">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>;
  <span class="cm-variable-2">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">height</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">&quot;2d&quot;</span>);

  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">height</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">width</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">pixel</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>);
      <span class="cm-variable-2">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">scale</span>);
    }
  }
}</pre>

<p><a class="p_ident" id="p_wPTPY1JmU4" href="#p_wPTPY1JmU4" tabindex="-1" role="presentation"></a>마우스가 그림 캔버스 위에 있는 동안 왼쪽 마우스 버튼을 누르면 구성 요소가 <code>pointerDown</code> 콜백을 호출하여 클릭한 픽셀의 위치(그림 좌표)를 제공합니다. 이것은 그림과의 마우스 상호 작용을 구현하는 데 사용됩니다. 콜백은 버튼을 누르고 있는 동안 포인터가 다른 픽셀로 이동할 때 알림을 받을 다른 콜백 함수를 반환할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_G1LWj2jAqP" href="#c_G1LWj2jAqP" tabindex="-1" role="presentation"></a><span class="cm-variable">PictureCanvas</span>.<span class="cm-property">prototype</span>.<span class="cm-property">mouse</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">downEvent</span>, <span class="cm-def">onDown</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">downEvent</span>.<span class="cm-property">button</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">pointerPosition</span>(<span class="cm-variable-2">downEvent</span>, <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">onMove</span> <span class="cm-operator">=</span> <span class="cm-variable-2">onDown</span>(<span class="cm-variable-2">pos</span>);
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">onMove</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">move</span> <span class="cm-operator">=</span> <span class="cm-def">moveEvent</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">moveEvent</span>.<span class="cm-property">buttons</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {
      <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">&quot;mousemove&quot;</span>, <span class="cm-variable-2">move</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-variable">pointerPosition</span>(<span class="cm-variable-2">moveEvent</span>, <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">newPos</span>.<span class="cm-property">x</span> <span class="cm-operator">==</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">newPos</span>.<span class="cm-property">y</span> <span class="cm-operator">==</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>) <span class="cm-keyword">return</span>;
      <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
      <span class="cm-variable-2">onMove</span>(<span class="cm-variable-2">newPos</span>);
    }
  };
  <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;mousemove&quot;</span>, <span class="cm-variable-2">move</span>);
};

<span class="cm-keyword">function</span> <span class="cm-def">pointerPosition</span>(<span class="cm-def">pos</span>, <span class="cm-def">domNode</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">domNode</span>.<span class="cm-property">getBoundingClientRect</span>();
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>((<span class="cm-variable-2">pos</span>.<span class="cm-property">clientX</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">left</span>) <span class="cm-operator">/</span> <span class="cm-variable">scale</span>),
          <span class="cm-property">y</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>((<span class="cm-variable-2">pos</span>.<span class="cm-property">clientY</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">top</span>) <span class="cm-operator">/</span> <span class="cm-variable">scale</span>)};
}</pre>

<p><a class="p_ident" id="p_B/cdI1TfFV" href="#p_B/cdI1TfFV" tabindex="-1" role="presentation"></a>픽셀의 크기를 알고 화면에서 캔버스의 위치를 찾는데 <code>getBoundingClientRect</code>를 사용할 수 있으므로 마우스 이벤트 좌표(<code>clientX</code>와 <code>clientY</code>)에서 그림 좌표로 이동할 수 있습니다. 특정 픽셀을 참조하도록 항상 반올림됩니다.</p>

<p><a class="p_ident" id="p_iTkf+HH3B/" href="#p_iTkf+HH3B/" tabindex="-1" role="presentation"></a>터치 이벤트와 유사하지만, 서로 다른 이벤트를 사용해서 패닝을 방지하기 위해 <code>&quot;touchstart&quot;</code> 이벤트 상에서 <code>preventDefault</code>를 호출할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_HUiWca6Gb7" href="#c_HUiWca6Gb7" tabindex="-1" role="presentation"></a><span class="cm-variable">PictureCanvas</span>.<span class="cm-property">prototype</span>.<span class="cm-property">touch</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">startEvent</span>,
                                         <span class="cm-def">onDown</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">pointerPosition</span>(<span class="cm-variable-2">startEvent</span>.<span class="cm-property">touches</span>[<span class="cm-number">0</span>], <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">onMove</span> <span class="cm-operator">=</span> <span class="cm-variable-2">onDown</span>(<span class="cm-variable-2">pos</span>);
  <span class="cm-variable-2">startEvent</span>.<span class="cm-property">preventDefault</span>();
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">onMove</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">move</span> <span class="cm-operator">=</span> <span class="cm-def">moveEvent</span> <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-variable">pointerPosition</span>(<span class="cm-variable-2">moveEvent</span>.<span class="cm-property">touches</span>[<span class="cm-number">0</span>],
                                 <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">newPos</span>.<span class="cm-property">x</span> <span class="cm-operator">==</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">newPos</span>.<span class="cm-property">y</span> <span class="cm-operator">==</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>) <span class="cm-keyword">return</span>;
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
    <span class="cm-variable-2">onMove</span>(<span class="cm-variable-2">newPos</span>);
  };
  <span class="cm-keyword">let</span> <span class="cm-def">end</span> <span class="cm-operator">=</span> () <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">&quot;touchmove&quot;</span>, <span class="cm-variable-2">move</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">removeEventListener</span>(<span class="cm-string">&quot;touchend&quot;</span>, <span class="cm-variable-2">end</span>);
  };
  <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;touchmove&quot;</span>, <span class="cm-variable-2">move</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;touchend&quot;</span>, <span class="cm-variable-2">end</span>);
};</pre>

<p><a class="p_ident" id="p_oah1AjpovX" href="#p_oah1AjpovX" tabindex="-1" role="presentation"></a>터치 이벤트의 경우에 <code>clientX</code>와 <code>clientY</code>는 이벤트 객체에서 직접 사용할 수 없지만, <code>touches</code> 속성에서 첫 번째 터치 객체의 좌표를 사용할 수 있습니다.</p>

<h2><a class="h_ident" id="h_bxOeMBlEZu" href="#h_bxOeMBlEZu" tabindex="-1" role="presentation"></a>응용 프로그램</h2>

<p><a class="p_ident" id="p_oKqyuCaaPg" href="#p_oKqyuCaaPg" tabindex="-1" role="presentation"></a>응용 프로그램을 하나씩 빌드할 수 있도록 하기 위해 기본 구성 요소를 그림 캔버스 주위의 셸로 구현하고 해당 생성자에 전달하는 도구 및 컨트롤의 동적 집합을 구현합니다.</p>

<p><a class="p_ident" id="p_2fnd7WZs8N" href="#p_2fnd7WZs8N" tabindex="-1" role="presentation"></a><em>controls</em>는 사진 아래에 표시 인터페이스 요소입니다. 구성 요소 생성자의 배열로 제공됩니다.</p>

<p><a class="p_ident" id="p_67YdeRoZl7" href="#p_67YdeRoZl7" tabindex="-1" role="presentation"></a><em>tools</em>는 픽셀을 그리거나 영역을 채우는 것과 같은 작업을 수행합니다. 응용 프로그램은 <code>&lt;select&gt;</code> 필드로 사용 가능한 도구 세트를 표시합니다. 현재 선택된 도구는 사용자가 포인터 장치로 그림과 상호 작용할 때 어떤 일이 발생하는지 결정합니다. 사용 가능한 도구 세트는 드롭다운 필드에 나타나는 이름을 도구를 구현하는 기능에 매핑하는 객체로 제공됩니다. 이러한 함수는 그림 위치, 현재 응용 프로그램 상태 및 <code>dispatch</code> 함수를 인수로 가져옵니다. 포인터가 다른 픽셀로 이동할 때 새 위치와 현재 상태로 호출되는 이동 처리기 함수를 반환할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bksTXX2fO6" href="#c_bksTXX2fO6" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">PixelEditor</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">state</span>, <span class="cm-def">config</span>) {
    <span class="cm-keyword">let</span> {<span class="cm-def">tools</span>, <span class="cm-def">controls</span>, <span class="cm-def">dispatch</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">config</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>;

    <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PictureCanvas</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>, <span class="cm-def">pos</span> <span class="cm-operator">=&gt;</span> {
      <span class="cm-keyword">let</span> <span class="cm-def">tool</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tools</span>[<span class="cm-keyword">this</span>.<span class="cm-property">state</span>.<span class="cm-property">tool</span>];
      <span class="cm-keyword">let</span> <span class="cm-def">onMove</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tool</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">state</span>, <span class="cm-variable-2">dispatch</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">onMove</span>) <span class="cm-keyword">return</span> <span class="cm-def">pos</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">onMove</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">state</span>);
    });
    <span class="cm-keyword">this</span>.<span class="cm-property">controls</span> <span class="cm-operator">=</span> <span class="cm-variable-2">controls</span>.<span class="cm-property">map</span>(
      <span class="cm-def">Control</span> <span class="cm-operator">=&gt;</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Control</span>(<span class="cm-variable-2">state</span>, <span class="cm-variable-2">config</span>));
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;div&quot;</span>, {}, <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">dom</span>, <span class="cm-variable">elt</span>(<span class="cm-string">&quot;br&quot;</span>),
                   <span class="cm-meta">...</span><span class="cm-keyword">this</span>.<span class="cm-property">controls</span>.<span class="cm-property">reduce</span>(
                     (<span class="cm-def">a</span>, <span class="cm-def">c</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span>.<span class="cm-property">concat</span>(<span class="cm-string">&quot; &quot;</span>, <span class="cm-variable-2">c</span>.<span class="cm-property">dom</span>), []));
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">ctrl</span> <span class="cm-keyword">of</span> <span class="cm-keyword">this</span>.<span class="cm-property">controls</span>) <span class="cm-variable-2">ctrl</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>);
  }
}</pre>

<p><a class="p_ident" id="p_5ni0DeofjL" href="#p_5ni0DeofjL" tabindex="-1" role="presentation"></a><code>PictureCanvas</code>로 주어지는 포인터 처리기는 적절한 인수를 사용하여 현재 선택된 도구를 호출하고, 이동 처리기를 반환하는 경우 상태를 수신하도록 조정합니다.</p>

<p><a class="p_ident" id="p_gOumsrO7+U" href="#p_gOumsrO7+U" tabindex="-1" role="presentation"></a>모든 컨트롤은 응용 프로그램 상태가 변경될 때 업데이트될 수 있도록 <code>this.controls</code>에 구성 및 저장됩니다. <code>reduce</code>에 대한 호출은 컨트롤의 DOM 요소 사이에 공백을 도입합니다. 그렇게 하면 서로 너무 밀착되어 보이지 않습니다.</p>

<p><a class="p_ident" id="p_KM7knGXuoO" href="#p_KM7knGXuoO" tabindex="-1" role="presentation"></a>첫 번째 컨트롤은 도구 선택 메뉴입니다. 각 도구에 대한 옵션이 있는 <code>&lt;select&gt;</code> 요소를 만들고 사용자가 다른 도구를 선택할 때 응용 프로그램 상태를 업데이트 하는 <code>&quot;change&quot;</code> 이벤트 처리기를 설정합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ErM/S5/GMa" href="#c_ErM/S5/GMa" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">ToolSelect</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">state</span>, {<span class="cm-def">tools</span>, <span class="cm-def">dispatch</span>}) {
    <span class="cm-keyword">this</span>.<span class="cm-property">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;select&quot;</span>, {
      <span class="cm-property">onchange</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">dispatch</span>({<span class="cm-property">tool</span>: <span class="cm-keyword">this</span>.<span class="cm-property">select</span>.<span class="cm-property">value</span>})
    }, <span class="cm-meta">...</span><span class="cm-variable">Object</span>.<span class="cm-property">keys</span>(<span class="cm-variable-2">tools</span>).<span class="cm-property">map</span>(<span class="cm-def">name</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;option&quot;</span>, {
      <span class="cm-property">selected</span>: <span class="cm-variable-2">name</span> <span class="cm-operator">==</span> <span class="cm-variable-2">state</span>.<span class="cm-property">tool</span>
    }, <span class="cm-variable-2">name</span>)));
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;label&quot;</span>, <span class="cm-atom">null</span>, <span class="cm-string">&quot;🖌 Tool: &quot;</span>, <span class="cm-keyword">this</span>.<span class="cm-property">select</span>);
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">select</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">tool</span>; }
}</pre>

<p><a class="p_ident" id="p_7EVkxldvIa" href="#p_7EVkxldvIa" tabindex="-1" role="presentation"></a><code>&lt;label&gt;</code> 요소의 텍스트 라벨과 필드를 래핑하여 라벨이 해당 필드에 속해 있음을 브라우저에 알립니다. 예를 들어 레이블을 클릭하여 필드에 초점을 맞출 수 있습니다.</p>

<p><a class="p_ident" id="p_avuZ1LKe/u" href="#p_avuZ1LKe/u" tabindex="-1" role="presentation"></a>또한 색상을 변경할 수 있어야 하므로 이에 대한 컨트롤을 추가해 보겠습니다. <code>color</code>의 <code>type</code> 속성을 갖는 HTML <code>&lt;input&gt;</code> 요소는 색상 선택에 특화된 양식 필드를 제공합니다. 이러한 필드의 값은 항상 <code>&quot;#RRGGBB&quot;</code> 형식의 CSS 색상 코드입니다(빨간색, 녹색 및 파란색 구성 요소, 색상당 두 디지트). 브라우저는 사용자가 상호 작용할 때 색상 선택기 인터페이스를 표시합니다.</p>

<p><a class="p_ident" id="p_mUiMIeOUud" href="#p_mUiMIeOUud" tabindex="-1" role="presentation"></a>다음 컨트롤은 이러한 필드를 만들고 응용 프로그램 상태의 <code>color</code> 속성과 동기화된 상태를 유지하도록 연결합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CNKBIFujc0" href="#c_CNKBIFujc0" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">ColorSelect</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">state</span>, {<span class="cm-def">dispatch</span>}) {
    <span class="cm-keyword">this</span>.<span class="cm-property">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;input&quot;</span>, {
      <span class="cm-property">type</span>: <span class="cm-string">&quot;color&quot;</span>,
      <span class="cm-property">value</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>,
      <span class="cm-property">onchange</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">dispatch</span>({<span class="cm-property">color</span>: <span class="cm-keyword">this</span>.<span class="cm-property">input</span>.<span class="cm-property">value</span>})
    });
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;label&quot;</span>, <span class="cm-atom">null</span>, <span class="cm-string">&quot;🎨 Color: &quot;</span>, <span class="cm-keyword">this</span>.<span class="cm-property">input</span>);
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">input</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>; }
}</pre>

<h2><a class="h_ident" id="h_dRTuNLyniP" href="#h_dRTuNLyniP" tabindex="-1" role="presentation"></a>그리기 도구</h2>

<p><a class="p_ident" id="p_zMXAaVz6Dy" href="#p_zMXAaVz6Dy" tabindex="-1" role="presentation"></a>무엇이든 그리기 전에 캔버스에서 마우스 또는 터치 이벤트의 기능을 제어하는 도구를 구현해야 합니다.</p>

<p><a class="p_ident" id="p_km565kqis+" href="#p_km565kqis+" tabindex="-1" role="presentation"></a>가장 기본적인 도구는 클릭하거나 탭하는 픽셀을 현재 선택한 색상으로 변경하는 그리기 도구입니다. 가리키는 픽셀에 현재 선택한 색상이 지정된 버전으로 그림을 업데이트하는 작업을 전달합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_CZoPfAkoSo" href="#c_CZoPfAkoSo" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">draw</span>(<span class="cm-def">pos</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">drawPixel</span>({<span class="cm-def">x</span>, <span class="cm-def">y</span>}, <span class="cm-def">state</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">drawn</span> <span class="cm-operator">=</span> {<span class="cm-property">x</span>, <span class="cm-property">y</span>, <span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>};
    <span class="cm-variable-2">dispatch</span>({<span class="cm-property">picture</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">draw</span>([<span class="cm-variable-2">drawn</span>])});
  }
  <span class="cm-variable-2">drawPixel</span>(<span class="cm-variable-2">pos</span>, <span class="cm-variable-2">state</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">drawPixel</span>;
}</pre>

<p><a class="p_ident" id="p_NV0WFpOefQ" href="#p_NV0WFpOefQ" tabindex="-1" role="presentation"></a>함수는 즉시 <code>drawPixel</code> 함수를 호출하지만 사용자가 그림을 드래그하거나 스와이프할 때 새로 터치한 픽셀에 대해 다시 호출되도록 함수를 반환합니다.</p>

<p><a class="p_ident" id="p_zzmdcb6+s1" href="#p_zzmdcb6+s1" tabindex="-1" role="presentation"></a>더 큰 모양을 그리려면 직사각형을 빠르게 만드는 것이 유용할 수 있습니다. <code>rectangle</code> 도구를 사용하면 드래그 시작 지점과 당신이 드래그하는 시점 사이에 사각형을 그립니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_cHtZqBzkqi" href="#c_cHtZqBzkqi" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">rectangle</span>(<span class="cm-def">start</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">drawRectangle</span>(<span class="cm-def">pos</span>) {
    <span class="cm-keyword">let</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">start</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">start</span>.<span class="cm-property">y</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">start</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">start</span>.<span class="cm-property">y</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">drawn</span> <span class="cm-operator">=</span> [];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
        <span class="cm-variable-2">drawn</span>.<span class="cm-property">push</span>({<span class="cm-property">x</span>, <span class="cm-property">y</span>, <span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>});
      }
    }
    <span class="cm-variable-2">dispatch</span>({<span class="cm-property">picture</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">draw</span>(<span class="cm-variable-2">drawn</span>)});
  }
  <span class="cm-variable-2">drawRectangle</span>(<span class="cm-variable-2">start</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">drawRectangle</span>;
}</pre>

<p><a class="p_ident" id="p_Fdi8lpCnu5" href="#p_Fdi8lpCnu5" tabindex="-1" role="presentation"></a>이 구현에서 중요한 세부 사항은 끌 때 사각형이 원래 상태에서 그림에 다시 그려집니다. 이렇게 하면 최종 그림에서 중간 직사각형이 달라붙지 않고 직사각형을 만드는 동안 다시 더 크게 만들 수 있습니다. 이것이 불변 그림 객체가 유용한 이유 중 하나입니다. 나중에 또 다른 이유를 살펴보겠습니다.</p>

<p><a class="p_ident" id="p_IN3YD5TiR4" href="#p_IN3YD5TiR4" tabindex="-1" role="presentation"></a>flood 채우기 구현은 다소 더 복잡합니다. 포인터 아래의 픽셀과 동일한 색상을 가진 모든 인접 픽셀을 채우는 도구입니다. "인접"은 대각선이 아닌 수평 또는 수직으로 직접 인접한 것을 의미합니다. 이 그림은 표시된 픽셀에서 플러드 채우기 도구를 사용할 때 색상이 지정된 픽셀 세트를 보여줍니다.</p>

<figure><img src="img/flood-grid.svg" alt="A pixel grid showing the area filled by a flood fill operation"></figure>

<p><a class="p_ident" id="p_g4IQdiCX9d" href="#p_g4IQdiCX9d" tabindex="-1" role="presentation"></a>흥미롭게도 이 작업을 수행하는 방법은 7장의 경로 찾기 코드와 약간 비슷합니다 . 이 코드는 경로를 찾기 위해 그래프를 통해 검색한 반면, 이 코드는 그리드를 검색하여 모든 "연결된" 픽셀을 찾습니다. 가능한 경로의 분기 집합을 추적하는 문제도 비슷합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_mkCcD637J8" href="#c_mkCcD637J8" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">around</span> <span class="cm-operator">=</span> [{<span class="cm-property">dx</span>: <span class="cm-operator">-</span><span class="cm-number">1</span>, <span class="cm-property">dy</span>: <span class="cm-number">0</span>}, {<span class="cm-property">dx</span>: <span class="cm-number">1</span>, <span class="cm-property">dy</span>: <span class="cm-number">0</span>},
                {<span class="cm-property">dx</span>: <span class="cm-number">0</span>, <span class="cm-property">dy</span>: <span class="cm-operator">-</span><span class="cm-number">1</span>}, {<span class="cm-property">dx</span>: <span class="cm-number">0</span>, <span class="cm-property">dy</span>: <span class="cm-number">1</span>}];

<span class="cm-keyword">function</span> <span class="cm-def">fill</span>({<span class="cm-def">x</span>, <span class="cm-def">y</span>}, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">targetColor</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">pixel</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">drawn</span> <span class="cm-operator">=</span> [{<span class="cm-property">x</span>, <span class="cm-property">y</span>, <span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>}];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">done</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">done</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">drawn</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">done</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> {<span class="cm-def">dx</span>, <span class="cm-def">dy</span>} <span class="cm-keyword">of</span> <span class="cm-variable">around</span>) {
      <span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">drawn</span>[<span class="cm-variable-2">done</span>].<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">dx</span>, <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">drawn</span>[<span class="cm-variable-2">done</span>].<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">dy</span>;
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">&gt;=</span> <span class="cm-number">0</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">width</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
          <span class="cm-variable-2">y</span> <span class="cm-operator">&gt;=</span> <span class="cm-number">0</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">height</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
          <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">pixel</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>) <span class="cm-operator">==</span> <span class="cm-variable-2">targetColor</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
          <span class="cm-operator">!</span><span class="cm-variable-2">drawn</span>.<span class="cm-property">some</span>(<span class="cm-def">p</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">p</span>.<span class="cm-property">x</span> <span class="cm-operator">==</span> <span class="cm-variable-2">x</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-variable-2">p</span>.<span class="cm-property">y</span> <span class="cm-operator">==</span> <span class="cm-variable-2">y</span>)) {
        <span class="cm-variable-2">drawn</span>.<span class="cm-property">push</span>({<span class="cm-property">x</span>, <span class="cm-property">y</span>, <span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>});
      }
    }
  }
  <span class="cm-variable-2">dispatch</span>({<span class="cm-property">picture</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">draw</span>(<span class="cm-variable-2">drawn</span>)});
}</pre>

<p><a class="p_ident" id="p_h2+e0trcAB" href="#p_h2+e0trcAB" tabindex="-1" role="presentation"></a>그려진 픽셀의 배열은 함수의 작업 목록으로 두 배가 됩니다. 도달한 각 픽셀에 대해 인접한 픽셀이 동일한 색상을 가지고 있고 이미 칠해지지 않았는지 확인해야 합니다. 루프 카운터는 새 픽셀이 추가될 때 배열 <code>drawn</code>의 길이보다 뒤쳐집니다. 그 앞에 있는 모든 픽셀은 여전히 탐색해야 합니다. 길이를 따라잡으면 탐색되지 않은 픽셀이 남지 않고 함수가 완료됩니다.</p>

<p><a class="p_ident" id="p_ExOoxU8nGm" href="#p_ExOoxU8nGm" tabindex="-1" role="presentation"></a>마지막 도구는 현재 그리기 색상으로 사용하기 위해 그림의 색상을 가리킬 수 있는 색상 선택기입니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_JK2K2M0XJH" href="#c_JK2K2M0XJH" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">pick</span>(<span class="cm-def">pos</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
  <span class="cm-variable-2">dispatch</span>({<span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">pixel</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>)});
}</pre>

<p><a class="p_ident" id="p_JOsrRsRZs3" href="#p_JOsrRsRZs3" tabindex="-1" role="presentation"></a>이제 애플리케이션을 테스트할 수 있습니다!</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_OAsV4NrCrn" href="#c_OAsV4NrCrn" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">let</span> <span class="cm-def">state</span> <span class="cm-operator">=</span> {
    <span class="cm-property">tool</span>: <span class="cm-string">&quot;draw&quot;</span>,
    <span class="cm-property">color</span>: <span class="cm-string">&quot;#000000&quot;</span>,
    <span class="cm-property">picture</span>: <span class="cm-variable">Picture</span>.<span class="cm-property">empty</span>(<span class="cm-number">60</span>, <span class="cm-number">30</span>, <span class="cm-string">&quot;#f0f0f0&quot;</span>)
  };
  <span class="cm-keyword">let</span> <span class="cm-def">app</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PixelEditor</span>(<span class="cm-variable">state</span>, {
    <span class="cm-property">tools</span>: {<span class="cm-property">draw</span>, <span class="cm-property">fill</span>, <span class="cm-property">rectangle</span>, <span class="cm-property">pick</span>},
    <span class="cm-property">controls</span>: [<span class="cm-variable">ToolSelect</span>, <span class="cm-variable">ColorSelect</span>],
    <span class="cm-property">dispatch</span>(<span class="cm-def">action</span>) {
      <span class="cm-variable">state</span> <span class="cm-operator">=</span> <span class="cm-variable">updateState</span>(<span class="cm-variable">state</span>, <span class="cm-variable-2">action</span>);
      <span class="cm-variable">app</span>.<span class="cm-property">syncState</span>(<span class="cm-variable">state</span>);
    }
  });
  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>).<span class="cm-property">appendChild</span>(<span class="cm-variable">app</span>.<span class="cm-property">dom</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_7eec4RKHJi" href="#h_7eec4RKHJi" tabindex="-1" role="presentation"></a>저장 및 로드</h2>

<p><a class="p_ident" id="p_apCzJ1aUDN" href="#p_apCzJ1aUDN" tabindex="-1" role="presentation"></a>그리고 나면 저장하기를 원할 것입니다. 현재 사진을 이미지 파일로 다운로드할 수 있는 버튼을 추가해야 합니다. 다음 컨트롤은 해당 버튼을 제공합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_4+FAPgY7mH" href="#c_4+FAPgY7mH" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">SaveButton</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">state</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;button&quot;</span>, {
      <span class="cm-property">onclick</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">save</span>()
    }, <span class="cm-string">&quot;💾 Save&quot;</span>);
  }
  <span class="cm-property">save</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;canvas&quot;</span>);
    <span class="cm-variable">drawPicture</span>(<span class="cm-keyword">this</span>.<span class="cm-property">picture</span>, <span class="cm-variable-2">canvas</span>, <span class="cm-number">1</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;a&quot;</span>, {
      <span class="cm-property">href</span>: <span class="cm-variable-2">canvas</span>.<span class="cm-property">toDataURL</span>(),
      <span class="cm-property">download</span>: <span class="cm-string">&quot;pixelart.png&quot;</span>
    });
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">link</span>);
    <span class="cm-variable-2">link</span>.<span class="cm-property">click</span>();
    <span class="cm-variable-2">link</span>.<span class="cm-property">remove</span>();
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) { <span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>; }
}</pre>

<p><a class="p_ident" id="p_pdnEnbG3o4" href="#p_pdnEnbG3o4" tabindex="-1" role="presentation"></a>구성 요소는 저장할 때 액세스할 수 있도록 현재 사진을 추적합니다. 이미지 파일을 생성하기 위해 그림을 그리는 <code>&lt;canvas&gt;</code> 요소를 사용합니다(픽셀당 1픽셀의 비율).</p>

<p><a class="p_ident" id="p_diweiWpe1X" href="#p_diweiWpe1X" tabindex="-1" role="presentation"></a>캔버스 요소의 <code>toDataURL</code> 메서드는 <code>data:</code>로 시작하는 URL을 생성합니다. <code>http:</code> 및 <code>https:</code>와 달리 데이터 URL은 URL에 전체 리소스를 포함합니다. 일반적으로 매우 길지만 브라우저에서 임의의 사진에 대한 작업 링크를 만들 수 있습니다.</p>

<p><a class="p_ident" id="p_k7Z8mWz3Zb" href="#p_k7Z8mWz3Zb" tabindex="-1" role="presentation"></a>실제로 브라우저에서 그림을 다운로드 하도록 하려면 URL을 가리키고 <code>download</code> 속성이 있는 링크 요소를 만듭니다. 이러한 링크를 클릭하면 브라우저에 파일 저장 대화 상자가 표시됩니다. 해당 링크를 문서에 추가하고 클릭을 시뮬레이션한 다음 다시 제거합니다.</p>

<p><a class="p_ident" id="p_hjRrUluZwC" href="#p_hjRrUluZwC" tabindex="-1" role="presentation"></a>브라우저 기술로 많은 일을 할 수 있지만 때로는 그 방법이 다소 이상할 수 있습니다.</p>

<p><a class="p_ident" id="p_U1MnOnU4AK" href="#p_U1MnOnU4AK" tabindex="-1" role="presentation"></a>버튼 구성 요소를 다시 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_6tKjwwpwls" href="#c_6tKjwwpwls" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">LoadButton</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">_</span>, {<span class="cm-def">dispatch</span>}) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;button&quot;</span>, {
      <span class="cm-property">onclick</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable">startLoad</span>(<span class="cm-variable-2">dispatch</span>)
    }, <span class="cm-string">&quot;📁 Load&quot;</span>);
  }
  <span class="cm-property">syncState</span>() {}
}

<span class="cm-keyword">function</span> <span class="cm-def">startLoad</span>(<span class="cm-def">dispatch</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;input&quot;</span>, {
    <span class="cm-property">type</span>: <span class="cm-string">&quot;file&quot;</span>,
    <span class="cm-property">onchange</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable">finishLoad</span>(<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>[<span class="cm-number">0</span>], <span class="cm-variable-2">dispatch</span>)
  });
  <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">input</span>);
  <span class="cm-variable-2">input</span>.<span class="cm-property">click</span>();
  <span class="cm-variable-2">input</span>.<span class="cm-property">remove</span>();
}</pre>

<p><a class="p_ident" id="p_iIAN+CV0z5" href="#p_iIAN+CV0z5" tabindex="-1" role="presentation"></a>사용자의 컴퓨터에 있는 파일에 액세스하려면 사용자가 파일 입력 필드를 통해 파일을 선택해야 합니다. 그러나 로드 버튼이 파일 입력 필드처럼 보이는 것을 원하지 않으므로 버튼을 클릭할 때 파일 입력을 생성한 다음 이 파일 입력 자체를 클릭한 척합니다.</p>

<p><a class="p_ident" id="p_YHZXdzuhWI" href="#p_YHZXdzuhWI" tabindex="-1" role="presentation"></a>사용자가 파일을 선택하면 다시 데이터 URL로 파일 내용에 액세스하는 데 <code>FileReader</code>를 사용할 수 있습니다. 해당 URL을 사용하여 <code>&lt;img&gt;</code> 요소를 만들 수 있지만 이러한 이미지의 픽셀에 직접 액세스할 수 없기 때문에 해당 이미지에서 <code>Picture</code> 객체를 만들 수 없습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bRy4XNFu3R" href="#c_bRy4XNFu3R" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">finishLoad</span>(<span class="cm-def">file</span>, <span class="cm-def">dispatch</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">file</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) <span class="cm-keyword">return</span>;
  <span class="cm-keyword">let</span> <span class="cm-def">reader</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">FileReader</span>();
  <span class="cm-variable-2">reader</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">&quot;load&quot;</span>, () <span class="cm-operator">=&gt;</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;img&quot;</span>, {
      <span class="cm-property">onload</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">dispatch</span>({
        <span class="cm-property">picture</span>: <span class="cm-variable">pictureFromImage</span>(<span class="cm-variable-2">image</span>)
      }),
      <span class="cm-property">src</span>: <span class="cm-variable-2">reader</span>.<span class="cm-property">result</span>
    });
  });
  <span class="cm-variable-2">reader</span>.<span class="cm-property">readAsDataURL</span>(<span class="cm-variable-2">file</span>);
}</pre>

<p><a class="p_ident" id="p_GCbWh2o/H9" href="#p_GCbWh2o/H9" tabindex="-1" role="presentation"></a>픽셀에 액세스하려면 먼저 <code>&lt;canvas&gt;</code> 요소에 그림을 그려야 합니다. 캔버스 컨텍스트는 스크립트가 픽셀을 읽을 수 있도록 하는 <code>getImageData</code> 메서드가 있습니다. 따라서 그림이 캔버스에 있으면 액세스하여 <code>Picture</code> 객체를 구성할 수 있습니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bHE23Qbgos" href="#c_bHE23Qbgos" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">pictureFromImage</span>(<span class="cm-def">image</span>) {
  <span class="cm-keyword">let</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">100</span>, <span class="cm-variable-2">image</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">100</span>, <span class="cm-variable-2">image</span>.<span class="cm-property">height</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;canvas&quot;</span>, {<span class="cm-property">width</span>, <span class="cm-property">height</span>});
  <span class="cm-keyword">let</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">&quot;2d&quot;</span>);
  <span class="cm-variable-2">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable-2">image</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">let</span> <span class="cm-def">pixels</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">let</span> {<span class="cm-def">data</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">getImageData</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);

  <span class="cm-keyword">function</span> <span class="cm-def">hex</span>(<span class="cm-def">n</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">n</span>.<span class="cm-property">toString</span>(<span class="cm-number">16</span>).<span class="cm-property">padStart</span>(<span class="cm-number">2</span>, <span class="cm-string">&quot;0&quot;</span>);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">data</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">+=</span> <span class="cm-number">4</span>) {
    <span class="cm-keyword">let</span> [<span class="cm-def">r</span>, <span class="cm-def">g</span>, <span class="cm-def">b</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">data</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">i</span>, <span class="cm-variable-2">i</span> <span class="cm-operator">+</span> <span class="cm-number">3</span>);
    <span class="cm-variable-2">pixels</span>.<span class="cm-property">push</span>(<span class="cm-string">&quot;#&quot;</span> <span class="cm-operator">+</span> <span class="cm-variable-2">hex</span>(<span class="cm-variable-2">r</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">hex</span>(<span class="cm-variable-2">g</span>) <span class="cm-operator">+</span> <span class="cm-variable-2">hex</span>(<span class="cm-variable-2">b</span>));
  }
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Picture</span>(<span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>, <span class="cm-variable-2">pixels</span>);
}</pre>

<p><a class="p_ident" id="p_AYkCLiGt6h" href="#p_AYkCLiGt6h" tabindex="-1" role="presentation"></a>더 큰 것은 디스플레이에서 거대하게 보이기 때문에 100x100 픽셀로 이미지의 크기를 제한할 수 있습니다.</p>

<p><a class="p_ident" id="p_9BhQWl518s" href="#p_9BhQWl518s" tabindex="-1" role="presentation"></a><code>getImageData</code>에 의해 반환된 객체의 <code>data</code> 속성은 색상 구성 요소의 배열입니다. 인수들로 지정된 직사각형 내에 각 픽셀에 관해 픽셀 색상의 red, green, blue 및 <em>alpha</em> 성분을 나타내는 4개 값들이 존재합니다(0과 255 사이의 수). alpha는 불투명으로 0의 값은 완전 투명이고 255의 값은 완전 불투명입니다. 현재는 무시하기로 합니다.</p>

<p><a class="p_ident" id="p_ISSui65mS1" href="#p_ISSui65mS1" tabindex="-1" role="presentation"></a>색상 표기법에 사용된 구성 요소당 2개의 16진수 숫자는 0에서 255 사이의 범위에 정확히 대응합니다. 16진수 두 자리는 16<sup>2</sup> = 256개의 다른 숫자를 표현할 수 있습니다. 숫자 관련 <code>toString</code> 메서드는 16진수의 문자열 표현을 생성합니다. 따라서 <code>n.toString(16)</code>은 16진수 문자열 표현을 생성합니다. 각 숫자가 두 자리를 차지하고 있는지 확인해야 합니다. <code>hex</code> 도우미 함수는 <code>padStart</code>을 호출하여 필요한 경우 앞에 0을 추가할 수 있습니다.</p>

<h2><a class="h_ident" id="h_6z5Bscg+0R" href="#h_6z5Bscg+0R" tabindex="-1" role="presentation"></a>실행 취소(Undo) 기록</h2>

<p><a class="p_ident" id="p_9BV8ZF7PJo" href="#p_9BV8ZF7PJo" tabindex="-1" role="presentation"></a>편집 과정의 절반은 약간의 실수를 하고 수정하는 것입니다. 따라서 그리기 프로그램에서 중요한 기능은 실행 취소 이력입니다.</p>

<p><a class="p_ident" id="p_Gnol1X09SZ" href="#p_Gnol1X09SZ" tabindex="-1" role="presentation"></a>변경 사항을 취소하려면 이전 버전의 그림을 저장해야 합니다. 불변 값이기 때문에 쉽습니다. 그러나 응용 프로그램 상태에서 추가 필드가 필요합니다.</p>

<p><a class="p_ident" id="p_ylDRpE2dGz" href="#p_ylDRpE2dGz" tabindex="-1" role="presentation"></a>그림의 이전 버전을 유지하기 위해 <code>done</code> 배열을 추가합니다. 이 속성을 유지하려면 배열에 그림을 추가하는 더 복잡한 상태 업데이트 함수가 필요합니다.</p>

<p><a class="p_ident" id="p_Rjg7sBJ+/e" href="#p_Rjg7sBJ+/e" tabindex="-1" role="presentation"></a>그러나 모든 변경 사항을 저장하고 싶지 않고 일정 시간 간격으로 변경 사항만 저장 합니다. 그렇게 하려면 두 번째 속성 <code>doneAt</code>가 필요합니다. 이 속성은 사진을 기록에 마지막으로 저장한 시간을 추적합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_xx2001jEVe" href="#c_xx2001jEVe" tabindex="-1" role="presentation"></a><span class="cm-keyword">function</span> <span class="cm-def">historyUpdateState</span>(<span class="cm-def">state</span>, <span class="cm-def">action</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">action</span>.<span class="cm-property">undo</span> <span class="cm-operator">==</span> <span class="cm-atom">true</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">state</span>.<span class="cm-property">done</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">state</span>;
    <span class="cm-keyword">return</span> <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>({}, <span class="cm-variable-2">state</span>, {
      <span class="cm-property">picture</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">done</span>[<span class="cm-number">0</span>],
      <span class="cm-property">done</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">done</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>),
      <span class="cm-property">doneAt</span>: <span class="cm-number">0</span>
    });
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">action</span>.<span class="cm-property">picture</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span>
             <span class="cm-variable-2">state</span>.<span class="cm-property">doneAt</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">Date</span>.<span class="cm-property">now</span>() <span class="cm-operator">-</span> <span class="cm-number">1000</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>({}, <span class="cm-variable-2">state</span>, <span class="cm-variable-2">action</span>, {
      <span class="cm-property">done</span>: [<span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>, <span class="cm-meta">...</span><span class="cm-variable-2">state</span>.<span class="cm-property">done</span>],
      <span class="cm-property">doneAt</span>: <span class="cm-variable">Date</span>.<span class="cm-property">now</span>()
    });
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">return</span> <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>({}, <span class="cm-variable-2">state</span>, <span class="cm-variable-2">action</span>);
  }
}</pre>

<p><a class="p_ident" id="p_CU+yNT8jA+" href="#p_CU+yNT8jA+" tabindex="-1" role="presentation"></a>작업이 undo인 경우 함수는 히스토리에서 가장 최근 사진을 가져와 현재 사진으로 만듭니다. <code>doneAt</code>을 0으로 설정하여 다음 변경 시 사진을 기록에 다시 저장하여 원하는 경우 다른 시간으로 되돌릴 수 있습니다.</p>

<p><a class="p_ident" id="p_R91Icq4lrz" href="#p_R91Icq4lrz" tabindex="-1" role="presentation"></a>그렇지 않고 작업에 새 그림이 포함되어 있고 마지막으로 무언가를 저장한 시간이 1초(1000밀리초) 이상 지난 경우 <code>done</code> 및 <code>doneAt</code> 속성은 이전 그림을 저장하도록 업데이트 됩니다.</p>

<p><a class="p_ident" id="p_hl3atayXAC" href="#p_hl3atayXAC" tabindex="-1" role="presentation"></a>undo 버튼 구성 요소는 많은 작업을 수행하지 않습니다. 클릭하면 실행 취소 작업을 전달하고 실행 취소할 항목이 없으면 자체적으로 비활성화됩니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_V5SwZIdQv8" href="#c_V5SwZIdQv8" tabindex="-1" role="presentation"></a><span class="cm-keyword">class</span> <span class="cm-def">UndoButton</span> {
  <span class="cm-property">constructor</span>(<span class="cm-def">state</span>, {<span class="cm-def">dispatch</span>}) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;button&quot;</span>, {
      <span class="cm-property">onclick</span>: () <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">dispatch</span>({<span class="cm-property">undo</span>: <span class="cm-atom">true</span>}),
      <span class="cm-property">disabled</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">done</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>
    }, <span class="cm-string">&quot;⮪ Undo&quot;</span>);
  }
  <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>.<span class="cm-property">disabled</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>.<span class="cm-property">done</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>;
  }
}</pre>

<h2><a class="h_ident" id="h_rUniBhw5Qd" href="#h_rUniBhw5Qd" tabindex="-1" role="presentation"></a>그리기</h2>

<p><a class="p_ident" id="p_jIw4zXAanZ" href="#p_jIw4zXAanZ" tabindex="-1" role="presentation"></a>응용 프로그램을 설정하려면 상태, 도구 집합, 컨트롤 집합 및 디스패치 함수를 만들어야 합니다. 기본 구성 요소를 생성하기 위해 <code>PixelEditor</code> 생성자에 전달할 수 있습니다. 연습 문제에서 여러 편집기를 만들어야 하므로 먼저 몇 가지 바인딩을 정의합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_PyNgZwUySd" href="#c_PyNgZwUySd" tabindex="-1" role="presentation"></a><span class="cm-keyword">const</span> <span class="cm-def">startState</span> <span class="cm-operator">=</span> {
  <span class="cm-property">tool</span>: <span class="cm-string">&quot;draw&quot;</span>,
  <span class="cm-property">color</span>: <span class="cm-string">&quot;#000000&quot;</span>,
  <span class="cm-property">picture</span>: <span class="cm-variable">Picture</span>.<span class="cm-property">empty</span>(<span class="cm-number">60</span>, <span class="cm-number">30</span>, <span class="cm-string">&quot;#f0f0f0&quot;</span>),
  <span class="cm-property">done</span>: [],
  <span class="cm-property">doneAt</span>: <span class="cm-number">0</span>
};

<span class="cm-keyword">const</span> <span class="cm-def">baseTools</span> <span class="cm-operator">=</span> {<span class="cm-property">draw</span>, <span class="cm-property">fill</span>, <span class="cm-property">rectangle</span>, <span class="cm-property">pick</span>};

<span class="cm-keyword">const</span> <span class="cm-def">baseControls</span> <span class="cm-operator">=</span> [
  <span class="cm-variable">ToolSelect</span>, <span class="cm-variable">ColorSelect</span>, <span class="cm-variable">SaveButton</span>, <span class="cm-variable">LoadButton</span>, <span class="cm-variable">UndoButton</span>
];

<span class="cm-keyword">function</span> <span class="cm-def">startPixelEditor</span>({<span class="cm-def">state</span> <span class="cm-operator">=</span> <span class="cm-variable">startState</span>,
                           <span class="cm-def">tools</span> <span class="cm-operator">=</span> <span class="cm-variable">baseTools</span>,
                           <span class="cm-def">controls</span> <span class="cm-operator">=</span> <span class="cm-variable">baseControls</span>}) {
  <span class="cm-keyword">let</span> <span class="cm-def">app</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PixelEditor</span>(<span class="cm-variable-2">state</span>, {
    <span class="cm-property">tools</span>,
    <span class="cm-property">controls</span>,
    <span class="cm-property">dispatch</span>(<span class="cm-def">action</span>) {
      <span class="cm-variable-2">state</span> <span class="cm-operator">=</span> <span class="cm-variable">historyUpdateState</span>(<span class="cm-variable-2">state</span>, <span class="cm-variable-2">action</span>);
      <span class="cm-variable-2">app</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>);
    }
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">app</span>.<span class="cm-property">dom</span>;
}</pre>

<p><a class="p_ident" id="p_mvhc46WKC4" href="#p_mvhc46WKC4" tabindex="-1" role="presentation"></a>객체 또는 배열을 구조화할 때 바인딩 이름 뒤에 <code>=</code>를 사용하여 바인딩에 기본값을 제공할 수 있습니다. 이 값은 속성이 없거나 <code>undefined</code>를 포함할 때 사용됩니다. <code>startPixelEditor</code> 함수는 이를 사용하여 여러 선택적 속성이 있는 객체를 인수로 수락합니다. 예를 들어, <code>tools</code> 속성을 제공하지 않으면 <code>tools</code>는 <code>baseTools</code>로 바인딩됩니다.</p>

<p><a class="p_ident" id="p_rZawaYRcqb" href="#p_rZawaYRcqb" tabindex="-1" role="presentation"></a>다음은 화면에 실제 편집기를 얻는 방법입니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_eYhWs5adxG" href="#c_eYhWs5adxG" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>)
    .<span class="cm-property">appendChild</span>(<span class="cm-variable">startPixelEditor</span>({}));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<h2><a class="h_ident" id="h_0bgBxHHAl2" href="#h_0bgBxHHAl2" tabindex="-1" role="presentation"></a>왜 어려운가?</h2>

<p><a class="p_ident" id="p_PmpoI92nJu" href="#p_PmpoI92nJu" tabindex="-1" role="presentation"></a>브라우저 기술은 놀랍습니다. 강력한 인터페이스 빌딩 블록 세트, 스타일 지정 및 조작 방법, 애플리케이션 검사 및 디버그 도구를 제공합니다. 브라우저용으로 작성한 소프트웨어는 지구상의 거의 모든 컴퓨터와 전화기에서 실행할 수 있습니다.</p>

<p><a class="p_ident" id="p_uqWgH1U6Ki" href="#p_uqWgH1U6Ki" tabindex="-1" role="presentation"></a>동시에 브라우저 기술은 우스꽝스럽습니다. 이를 이해하려면 많은 트릭과 모호한 사실을 배워야 하며, 제공하는 기본 프로그래밍 모델은 너무 문제가 많아서 대부분의 프로그래머는 직접 다루기보다 여러 추상화 계층에서 다루는 것을 선호합니다.</p>

<p><a class="p_ident" id="p_AyiKfJ46L7" href="#p_AyiKfJ46L7" tabindex="-1" role="presentation"></a>상황이 확실히 개선되고 있지만 대부분 단점을 해결하기 위해 더 많은 요소가 추가되는 형태로 개선되어 훨씬 더 복잡해집니다. 수백만 개의 웹사이트에서 사용하는 기능은 실제로 대체할 수 없습니다. 가능하더라도 무엇으로 교체해야 할지 결정하기 어려울 것입니다.</p>

<h2><a class="h_ident" id="h_TcUD2vzyMe" href="#h_TcUD2vzyMe" tabindex="-1" role="presentation"></a>연습 문제</h2>

<p><a class="p_ident" id="p_We+KsAI00v" href="#p_We+KsAI00v" tabindex="-1" role="presentation"></a>이 페이지에서 소개된 프로그램에는 아직 개선의 여지가 있습니다. 연습으로 몇 가지 기능을 더 추가해 보겠습니다.</p>

<h3><a class="i_ident" id="i_BUum8+bZXE" href="#i_BUum8+bZXE" tabindex="-1" role="presentation"></a>Keyboard 결합</h3>

<p><a class="p_ident" id="p_FuGqJ+Eqr8" href="#p_FuGqJ+Eqr8" tabindex="-1" role="presentation"></a>응용 프로그램에 키보드 단축키를 추가합니다. 도구 이름의 첫 글자는 도구를 선택하고, <span class="keyname">control</span>-Z 또는 <span class="keyname">command</span>-Z는 undo를 활성화합니다.</p>

<p><a class="p_ident" id="p_Gnz9yDs2sE" href="#p_Gnz9yDs2sE" tabindex="-1" role="presentation"></a><code>PixelEditor</code> 구성 요소를 수정하여 이 작업을 수행합니다. 키보드 포커스를 받을 수 있도록 <code>&lt;div&gt;</code> 요소에 0의 <code>tabIndex</code> 속성을 추가합니다. <code>tabindex</code> 속성에 대응하는 <em>property</em>는 <code>tabIndex</code>라 하며(대문자 I 사용), <code>elt</code> 함수는 속성 이름을 사용합니다. 해당 요소에 직접 키 이벤트 처리기를 등록합니다. 즉, 키보드와 상호 작용하기 전에 응용 프로그램을 클릭, 터치 또는 탭해야 합니다.</p>

<p><a class="p_ident" id="p_Yzx5/UnTtd" href="#p_Yzx5/UnTtd" tabindex="-1" role="presentation"></a>키보드 이벤트에는 해당 키가 눌려 있는지 여부를 확인하는데 사용할 수 있는 <code>ctrlKey</code> 및 <code>metaKey</code> (Mac의 경우는 <span class="keyname">command</span> 키) 속성이 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_9RBHLjfr9C" href="#c_9RBHLjfr9C" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The original PixelEditor class. Extend the constructor.</span>
  <span class="cm-keyword">class</span> <span class="cm-def">PixelEditor</span> {
    <span class="cm-property">constructor</span>(<span class="cm-def">state</span>, <span class="cm-def">config</span>) {
      <span class="cm-keyword">let</span> {<span class="cm-def">tools</span>, <span class="cm-def">controls</span>, <span class="cm-def">dispatch</span>} <span class="cm-operator">=</span> <span class="cm-variable-2">config</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>;

      <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">PictureCanvas</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>, <span class="cm-def">pos</span> <span class="cm-operator">=&gt;</span> {
        <span class="cm-keyword">let</span> <span class="cm-def">tool</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tools</span>[<span class="cm-keyword">this</span>.<span class="cm-property">state</span>.<span class="cm-property">tool</span>];
        <span class="cm-keyword">let</span> <span class="cm-def">onMove</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tool</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">state</span>, <span class="cm-variable-2">dispatch</span>);
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">onMove</span>) {
          <span class="cm-keyword">return</span> <span class="cm-def">pos</span> <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">onMove</span>(<span class="cm-variable-2">pos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">state</span>, <span class="cm-variable-2">dispatch</span>);
        }
      });
      <span class="cm-keyword">this</span>.<span class="cm-property">controls</span> <span class="cm-operator">=</span> <span class="cm-variable-2">controls</span>.<span class="cm-property">map</span>(
        <span class="cm-def">Control</span> <span class="cm-operator">=&gt;</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Control</span>(<span class="cm-variable-2">state</span>, <span class="cm-variable-2">config</span>));
      <span class="cm-keyword">this</span>.<span class="cm-property">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">&quot;div&quot;</span>, {}, <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">dom</span>, <span class="cm-variable">elt</span>(<span class="cm-string">&quot;br&quot;</span>),
                     <span class="cm-meta">...</span><span class="cm-keyword">this</span>.<span class="cm-property">controls</span>.<span class="cm-property">reduce</span>(
                       (<span class="cm-def">a</span>, <span class="cm-def">c</span>) <span class="cm-operator">=&gt;</span> <span class="cm-variable-2">a</span>.<span class="cm-property">concat</span>(<span class="cm-string">&quot; &quot;</span>, <span class="cm-variable-2">c</span>.<span class="cm-property">dom</span>), []));
    }
    <span class="cm-property">syncState</span>(<span class="cm-def">state</span>) {
      <span class="cm-keyword">this</span>.<span class="cm-property">state</span> <span class="cm-operator">=</span> <span class="cm-variable-2">state</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>);
      <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">ctrl</span> <span class="cm-keyword">of</span> <span class="cm-keyword">this</span>.<span class="cm-property">controls</span>) <span class="cm-variable-2">ctrl</span>.<span class="cm-property">syncState</span>(<span class="cm-variable-2">state</span>);
    }
  }

  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>)
    .<span class="cm-property">appendChild</span>(<span class="cm-variable">startPixelEditor</span>({}));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_xwvacRuw4q" href="#p_xwvacRuw4q" tabindex="-1" role="presentation"></a>문자 키에 대한 이벤트의 <code>key</code> 속성은 소문자 자체일 것입니다(<span class="keyname">shift</span>를 잡고 있지 않은 경우).</p>

<p><a class="p_ident" id="p_ODUWMiqiFq" href="#p_ODUWMiqiFq" tabindex="-1" role="presentation"></a><code>&quot;keydown&quot;</code> 처리기는 바로 가기의 일치 여부를 확인하기 위해 이벤트 객체를 검사할 수 있습니다. <code>tools</code> 객체에서 첫 글자 목록을 자동으로 가져올 수 있으므로 쓸 필요가 없습니다.</p>

<p><a class="p_ident" id="p_+R29awWdUv" href="#p_+R29awWdUv" tabindex="-1" role="presentation"></a>키 이벤트가 바로 가기와 일치하면 <code>preventDefault</code>를 호출하고 적절한 작업을 전달합니다.</p>

</div></div>

<h3><a class="i_ident" id="i_N6J15nL9us" href="#i_N6J15nL9us" tabindex="-1" role="presentation"></a>효과적인 그리기</h3>

<p><a class="p_ident" id="p_IwtJehHo1s" href="#p_IwtJehHo1s" tabindex="-1" role="presentation"></a>그림을 그리는 동안 응용 프로그램에서 수행하는 대부분의 작업은 <code>drawPicture</code>에서 잘생합니다. 새로운 상태를 만들고 DOM의 나머지 부분을 업데이트하는 것은 비용이 많이 들지 않지만 캔버스의 모든 픽셀을 다시 그리는 것은 꽤 많은 작업입니다.</p>

<p><a class="p_ident" id="p_ttnFBSQKkT" href="#p_ttnFBSQKkT" tabindex="-1" role="presentation"></a>픽셀이 실제 변경되는 경우에만 다시 그리기를 보다 빠르게 하기 위해 <code>PictureCanvas</code>의 <code>syncState</code> 메서드를 작성하는 방식을 나타냅니다.</p>

<p><a class="p_ident" id="p_usWBD49GQe" href="#p_usWBD49GQe" tabindex="-1" role="presentation"></a><code>drawPicture</code>는 또한 save 버튼에 사용됩니다. 변경이 과거의 것을 망가뜨리지 않도록 하거나 또는 상이한 이름의 새로운 버전을 생성할 수 있도록 변경합니다.</p>

<p><a class="p_ident" id="p_K1ZR/jxVLm" href="#p_K1ZR/jxVLm" tabindex="-1" role="presentation"></a><code>width</code> 또는 <code>height</code> 속성을 설정하여 <code>&lt;canvas&gt;</code> 요소의 크기를 변경하면 요소가 지워지고 다시 완전히 투명해집니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_WYxUTPFclW" href="#c_WYxUTPFclW" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// 메서드 변경</span>
  <span class="cm-variable">PictureCanvas</span>.<span class="cm-property">prototype</span>.<span class="cm-property">syncState</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">picture</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">==</span> <span class="cm-variable-2">picture</span>) <span class="cm-keyword">return</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">picture</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>;
    <span class="cm-variable">drawPicture</span>(<span class="cm-keyword">this</span>.<span class="cm-property">picture</span>, <span class="cm-keyword">this</span>.<span class="cm-property">dom</span>, <span class="cm-variable">scale</span>);
  };

  <span class="cm-comment">// You may want to use or change this as well</span>
  <span class="cm-keyword">function</span> <span class="cm-def">drawPicture</span>(<span class="cm-def">picture</span>, <span class="cm-def">canvas</span>, <span class="cm-def">scale</span>) {
    <span class="cm-variable-2">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>;
    <span class="cm-variable-2">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">height</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">&quot;2d&quot;</span>);

    <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">height</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">for</span> (<span class="cm-keyword">let</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">width</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
        <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">picture</span>.<span class="cm-property">pixel</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>);
        <span class="cm-variable-2">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">scale</span>);
      }
    }
  }

  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>)
    .<span class="cm-property">appendChild</span>(<span class="cm-variable">startPixelEditor</span>({}));
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_hWnsI+3L35" href="#p_hWnsI+3L35" tabindex="-1" role="presentation"></a>이 문제는 변경할 수 없는 데이터 구조가 코드를 더 빠르게 만드는 방법에 대한 좋은 예입니다. 이전 그림과 새 그림이 모두 있으므로 이를 비교하고 색상이 변경된 픽셀만 다시 그릴 수 있으므로 대부분의 경우 그리기 작업의 99% 이상을 절약할 수 있습니다.</p>

<p><a class="p_ident" id="p_tH/EgkLe4/" href="#p_tH/EgkLe4/" tabindex="-1" role="presentation"></a>새 함수 <code>updatePicture</code>를 작성하거나 <code>drawPicture</code>가 정의되지 않았거나 이전 그림일 수 있는 추가 인수를 사용할 수 있습니다. 각 픽셀에 대해 이 함수는 이전 그림이 이 위치에서 동일한 색상으로 전달되었는지 확인하고 그럴 경우 픽셀을 건너뜁니다.</p>

<p><a class="p_ident" id="p_iypPTMWN+N" href="#p_iypPTMWN+N" tabindex="-1" role="presentation"></a>캔버스의 크기를 변경하면 캔버스가 지워지므로 이전 그림과 새 그림의 크기가 같을 때 캔버스의 <code>width</code> 및 <code>height</code> 속성을 만지는 것도 피해야 합니다. 새 그림이 로드되었을 때 발생하는 서로 다른 경우 캔버스 크기를 변경한 후 픽셀을 건너뛰어서는 안 되므로 캔버스 크기를 변경한 후 이전 그림을 유지하는 바인딩을 null로 설정할 수 있습니다.</p>

</div></div>

<h3><a class="i_ident" id="i_lH0RbmdIJo" href="#i_lH0RbmdIJo" tabindex="-1" role="presentation"></a>원</h3>

<p><a class="p_ident" id="p_CKH37/aTkf" href="#p_CKH37/aTkf" tabindex="-1" role="presentation"></a>마우스를 끌어 채워진 원을 그리는 도구 <code>circle</code>을 정의합니다. 원의 중심은 드래그 또는 터치 제스처가 시작되는 지점에 있으며, 드래그한 거리에 따라 반지름이 결정됩니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_MYYVHp5bsE" href="#c_MYYVHp5bsE" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-def">circle</span>(<span class="cm-def">pos</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
    <span class="cm-comment">// 여기에 코드 작성</span>
  }

  <span class="cm-keyword">let</span> <span class="cm-def">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">startPixelEditor</span>({
    <span class="cm-property">tools</span>: <span class="cm-variable">Object</span>.<span class="cm-property">assign</span>({}, <span class="cm-variable">baseTools</span>, {<span class="cm-property">circle</span>})
  });
  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>).<span class="cm-property">appendChild</span>(<span class="cm-variable">dom</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_n8gcP1wK10" href="#p_n8gcP1wK10" tabindex="-1" role="presentation"></a><code>rectangle</code> 도구를 참조합니다. 그 도구와 마찬가지로 포인터가 움직일 때 현재 그림이 아니라 시작 그림에 계속 그리기를 원할 것입니다.</p>

<p><a class="p_ident" id="p_g4iL6doRwh" href="#p_g4iL6doRwh" tabindex="-1" role="presentation"></a>어떤 픽셀을 색칠할지 알아내려면 피타고라스 정리를 사용할 수 있습니다. 먼저 x-좌표 차이의 제곱합(<code>Math.pow(x, 2)</code>)의 제곱근(<code>Math.sqrt</code>)을 취하고 유사하게 y-좌표에 관해 유사 작업을 행합니다. 그런 다음 측면이 반경의 두 배 이상인 시작 위치 주변의 픽셀 사각형을 반복하고 원의 반경 내에 있는 픽셀에 색상을 지정합니다. 다시 피타고라스 공식을 사용하여 중심으로부터의 거리를 계산합니다.</p>

<p><a class="p_ident" id="p_6rR6tnEiD7" href="#p_6rR6tnEiD7" tabindex="-1" role="presentation"></a>그림의 경계 밖에 있는 픽셀에 색상을 지정하지 않도록 하십시오.</p>

</div></div>

<h3><a class="i_ident" id="i_gbSk/YiRrs" href="#i_gbSk/YiRrs" tabindex="-1" role="presentation"></a>적절한 선들</h3>

<p><a class="p_ident" id="p_9+5Lhu8/5P" href="#p_9+5Lhu8/5P" tabindex="-1" role="presentation"></a>이것은 앞의 두 가지 연습보다 더 고급 연습이며 사소한 문제에 대한 솔루션을 설계해야 합니다.</p>

<p><a class="p_ident" id="p_VU//OuPykO" href="#p_VU//OuPykO" tabindex="-1" role="presentation"></a>대부분의 브라우저에서 <code>draw</code> 도구를 선택하고 그림을 빠르게 드래그하면 닫힌 선이 표시되지 않습니다. 오히려 <code>&quot;mousemove&quot;</code> 또는 <code>&quot;touchmove&quot;</code> 이벤트가 모든 픽셀에 도달할 만큼 충분히 빠르게 실행되지 않았기 때문에 그 사이에 간격이 있는 점이 표시됩니다.</p>

<p><a class="p_ident" id="p_MVVAQugFEf" href="#p_MVVAQugFEf" tabindex="-1" role="presentation"></a>완전한 선을 그리도록 <code>draw</code> 도구를 개선하십시오. 즉, 모션 처리기 함수가 이전 위치를 기억하고 현재 위치에 연결해야 합니다.</p>

<p><a class="p_ident" id="p_7SM2TRnD47" href="#p_7SM2TRnD47" tabindex="-1" role="presentation"></a>이렇게 하려면 픽셀이 임의의 거리만큼 떨어져 있을 수 있으므로 일반적인 선 그리기 함수를 작성해야 합니다.</p>

<p><a class="p_ident" id="p_e6Gkv3bxv2" href="#p_e6Gkv3bxv2" tabindex="-1" role="presentation"></a>두 픽셀 사이의 선은 연결된 픽셀 체인으로 시작에서 끝까지 가능한 한 직선입니다. 대각선으로 인접한 픽셀은 연결된 것으로 간주됩니다. 따라서 사선은 오른쪽 그림이 아니라 왼쪽 그림과 같아야 합니다.</p>

<figure><img src="img/line-grid.svg" alt="Two pixelated lines, one light, skipping across pixels diagonally, and one heavy, with all pixels connected horizontally or vertically"></figure>

<p><a class="p_ident" id="p_+B4IUrham3" href="#p_+B4IUrham3" tabindex="-1" role="presentation"></a>마지막으로, 임의의 두 점 사이에 선을 그리는 코드가 있는 경우 드래그의 시작과 끝 사이에 직선을 그리는 <code>line</code> 도구를 정의하는 데 사용할 수도 있습니다.</p>

<pre class="snippet cm-s-default" data-language="text/html" ><a class="c_ident" id="c_lYipUdu4TJ" href="#c_lYipUdu4TJ" tabindex="-1" role="presentation"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">div</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old draw tool. Rewrite this.</span>
  <span class="cm-keyword">function</span> <span class="cm-def">draw</span>(<span class="cm-def">pos</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">drawPixel</span>({<span class="cm-def">x</span>, <span class="cm-def">y</span>}, <span class="cm-def">state</span>) {
      <span class="cm-keyword">let</span> <span class="cm-def">drawn</span> <span class="cm-operator">=</span> {<span class="cm-property">x</span>, <span class="cm-property">y</span>, <span class="cm-property">color</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">color</span>};
      <span class="cm-variable-2">dispatch</span>({<span class="cm-property">picture</span>: <span class="cm-variable-2">state</span>.<span class="cm-property">picture</span>.<span class="cm-property">draw</span>([<span class="cm-variable-2">drawn</span>])});
    }
    <span class="cm-variable-2">drawPixel</span>(<span class="cm-variable-2">pos</span>, <span class="cm-variable-2">state</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">drawPixel</span>;
  }

  <span class="cm-keyword">function</span> <span class="cm-def">line</span>(<span class="cm-def">pos</span>, <span class="cm-def">state</span>, <span class="cm-def">dispatch</span>) {
    <span class="cm-comment">// Your code here</span>
  }

  <span class="cm-keyword">let</span> <span class="cm-def">dom</span> <span class="cm-operator">=</span> <span class="cm-variable">startPixelEditor</span>({
    <span class="cm-property">tools</span>: {<span class="cm-property">draw</span>, <span class="cm-property">line</span>, <span class="cm-property">fill</span>, <span class="cm-property">rectangle</span>, <span class="cm-property">pick</span>}
  });
  <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">&quot;div&quot;</span>).<span class="cm-property">appendChild</span>(<span class="cm-variable">dom</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>

<div class="solution"><div class="solution-text">

<p><a class="p_ident" id="p_0Sbp4dO/v8" href="#p_0Sbp4dO/v8" tabindex="-1" role="presentation"></a>픽셀화된 선을 그리는 문제에 대한 문제는 실제로 네 가지가 유사하지만 약간 다른 문제라는 것입니다. 왼쪽에서 오른쪽으로 수평선을 그리는 것은 쉽습니다. x 좌표를 반복하고 모든 단계에서 픽셀에 색상을 지정합니다. 선에 약간의 기울기(45도 또는 ¼π 라디안 미만)가 있는 경우 기울기를 따라 y 좌표를 보간할 수 있습니다. 기울기에 의해 결정되는 해당 픽셀의 <em>y</em> 위치와 함께 <em>x</em> 위치 당 하나의 픽셀이 여전히 필요합니다.</p>

<p><a class="p_ident" id="p_mrTlGXQJo5" href="#p_mrTlGXQJo5" tabindex="-1" role="presentation"></a>그러나 기울기가 45도를 넘어가는 즉시 좌표를 처리하는 방식을 전환해야 합니다. 라인이 왼쪽보다 위로 올라가기 때문에 이제 y 위치 당 하나의 픽셀이 필요합니다. 그리고 나서, 135도를 넘을 때 x-좌표를 반복하는 것으로 돌아가야 합니다(오른쪽에서 왼쪽으로).</p>

<p><a class="p_ident" id="p_IfupYbaeUB" href="#p_IfupYbaeUB" tabindex="-1" role="presentation"></a>실제로 4개의 루프를 작성할 필요는 없습니다. <em>A</em>에서 <em>B</em>로 선 그리기는 <em>B</em>에서 <em>A</em>로 선 그리기와 겉기 때문에 오른쪽에서 왼쪽으로가는 라인의 시작과 끝 위치를 바꿀 수 있으며, 왼쪽에서 오른쪽으로 가는 것으로 취급합니다.</p>

<p><a class="p_ident" id="p_Hn7VorKX+l" href="#p_Hn7VorKX+l" tabindex="-1" role="presentation"></a>따라서 두 개의 서로 다른 루프가 필요합니다. 선 그리기 함수에서 가장 먼저 해야 할 일은 x 좌표의 차이가 y 좌표의 차이보다 큰지 확인하는 것입니다. 있으면 가로선이고 그렇지 않으면 세로선입니다.</p>

<p><a class="p_ident" id="p_J1kJbTfzUr" href="#p_J1kJbTfzUr" tabindex="-1" role="presentation"></a><em>x</em>와 <em>y</em> 차이의 절댓값을 비교해야 합니다(<code>Math.abs</code> 사용).</p>

<p><a class="p_ident" id="p_XJKDpy8qQW" href="#p_XJKDpy8qQW" tabindex="-1" role="presentation"></a>루핑할 축을 알게 되면 시작점이 끝점보다 해당 축을 따라 더 높은 좌표를 갖는지 확인하고 필요한 경우 교환할 수 있습니다. JavaScript에서 두 바인딩의 값을 바꾸는 간결한 방법은 다음과 같은 구조 해제 할당을 사용합니다.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/XtfsVpMBL" href="#c_/XtfsVpMBL" tabindex="-1" role="presentation"></a>[<span class="cm-variable">start</span>, <span class="cm-variable">end</span>] <span class="cm-operator">=</span> [<span class="cm-variable">end</span>, <span class="cm-variable">start</span>];</pre>

<p><a class="p_ident" id="p_kQN0DL7QjH" href="#p_kQN0DL7QjH" tabindex="-1" role="presentation"></a>그런 다음 주축을 따라 이동하는 각 단계에 대해 다른 축의 좌표가 변경되는 양을 결정하는 선의 기울기를 계산할 수 있습니다. 이를 통해 다른 축의 해당 위치를 추적하면서 주 축을 따라 루프를 실행할 수 있으며 모든 반복에서 픽셀을 그릴 수 있습니다. 비주축 좌표는 분수일 가능성이 있고 <code>draw</code> 메서드가 분수 좌표에 잘 응답하지 않으므로 반올림해야 합니다.</p>

</div></div><nav><a href="18_http.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="20_node.html" title="next chapter">▶</a></nav>
</article>
